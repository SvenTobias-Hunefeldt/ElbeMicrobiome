---
title: "Organise data"
author: "Sven Tobias-HÃ¼nefeldt"
date: "2023-11-28"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Load packages
```{r}
require(RCurl)
require(R.utils)
require(phyloseq)
require(plotly)
require(forcats)
require(vegan)
require(dplyr)
require(ggpubr)
library(stringr)

require(WGCNA)

library(Hmisc)
library(igraph)
library(tidyverse)     # tidyverse will pull in ggplot2, readr, other useful libraries
library(magrittr)      # provides the %>% operator
library(genefilter)

library(Hmisc)

```

#Make environment and functions
```{r Set up environment}
#Set seed to make results more reproducible
set.seed(2)
#Set language to english
Sys.setenv(LANG = "en")
#Set up working directory
setwd("E:/Functional_R_analysis/")
#Define theme for plotting
My_Theme = theme_bw()+
  theme(axis.title.x = element_text(size=18),
       # theme_grey(base_size = 22),
        axis.text.x = element_text(angle=0, colour = "black", vjust=1, hjust = 0.5, size=18), 
        axis.text.y = element_text(colour = "black", size=18),
        axis.title.y = element_text(size=18),
        plot.title = element_text(size = 18, hjust = 0.5),
        legend.title =element_text(size = 18),
        legend.text = element_text(size = 16),
        legend.position="right",
        legend.key.size = unit(1, "cm"),
        strip.text.x = element_text(size=18, face="bold"),
        strip.text.y = element_text(size=18, face="bold"),
        #panel.background = element_blank(),
        panel.border = element_rect(fill = NA, colour = "black"),
        strip.background = element_rect(colour="black"),
       text = element_text(family = "sans"))

Poster_Theme = theme_bw()+
  theme(axis.title.x = element_text(size=28),
       # theme_grey(base_size = 22),
        axis.text.x = element_text(angle=0, colour = "black", vjust=1, hjust = 0.5, size=24), 
        axis.text.y = element_text(colour = "black", size=24),
        axis.title.y = element_text(size=28),
        plot.title = element_text(size = 24, hjust = 0.5),
        legend.title =element_text(size = 28),
        legend.text = element_text(size = 24),
        legend.position="right",
        legend.key.size = unit(1, "cm"),
        strip.text.x = element_text(size=24, face="bold"),
        strip.text.y = element_text(size=24, face="bold"),
        #panel.background = element_blank(),
        panel.border = element_rect(fill = NA, colour = "black"),
        strip.background = element_rect(colour="black"),
       text = element_text(family = "sans"))

#Station specific colours for consistency
Station_colour_list <- c("Muelenberger Loch" =  "black",
                "Twielenfleth" = "red",
                #"" = "violet",
                #"" = "violetred4", 
                "Schwarztonnensand" = "navy",
                #"" = "",
                #"" = "thistle3", 
                "Brunbuettel" = "forestgreen",
                #"" = "darkred",
                "Medemgrund" = "green",
                #"" = "orange",
                #"" = "turquoise",
                #"" = "cornflowerblue",
                #"" = "beige",
                "Station6" = "magenta")

Date_colour_list <- c("Jul 21" =  "forestgreen",
                "May 21" = "red",
                #"" = "violet",
                #"" = "violetred4", 
                "Nov 22" = "navy",
                #"" = "",
                #"" = "thistle3", 
                "Feb 22" = "black",
                #"" = "darkred",
                #"" = "turquoise",
                #"" = "cornflowerblue",
                #"" = "beige",
                #"" = "orange",
                "May 22" = "green",
                "Jun 22" = "magenta"
                )

#Colourblind friendly pallete
cbbPalette <- c("black",
                "red",
                "navy", 
                "green", 
                "magenta",
                "forestgreen")
#If more options are needed
expanded_cbbPalette <- c("#000000", #Black
                "#E69F00", #Orange
                "#56B4E9", #Blue (light)
                "#009E73", #Sea green
                "#CC79A7", #Magenta (light)
                "#F0E442", #Yellow
                "#0072B2", #Blue
                "#D55E00", #Burnt orange
                "dodgerblue4",
                "rosybrown",
                "floralwhite",
                "lightgoldenrod4",
                "cornsilk3",
                "coral4",
                "gray38",
                "turquoise4",
                "springgreen3",
                "slateblue3",
                "forestgreen",
                "lightgreen") 

#Shapes for ggplot2
Shape_list = c(0, #Hollow square
               15, #Filled square
               1, #Hollow circle
               16, #Filled circle
               2, #Hollow triangle
               17, #Filled triangle
               5, #Hollow diamond
               23) #Filled diamond
                
#Set up position dodge for ggplot2
pd = position_dodge(0.15)

ConditionColourList <- c("AlcianBlue" = "black",
                         "CBBG" = "red")

#Colourblind friendly pallete
FractionColourList <- c("Suspended" = "grey50",
                        "Sinking" = "black")
FractionSecondaryColourList <- c(#"Suspended" = "black",
                                 #"Sinking" = "red",
                                 #"navy",
                                 "Suspended" = "grey", 
                                 "Sinking" = "grey40")


Group_colours = c("Dissolved Organic" = "#000000", #Black
                                           "Dissolved Inorganic" =  "#E69F00", #Orange
                                           "Free-Living Organisms"= "#56B4E9", #Blue (light),
                                           "Suspended PAO" = "#009E73", #Sea green,
                                           "Sinking PAO" = "#CC79A7", #Magenta (light),
                                           "Suspended Organic Particles" = "#F0E442", #Yellow,
                                           "Suspended Inorganic Particles" = "#0072B2", #Blue,
                                           "Sinking Organic Particles" = "#D55E00", #Burnt orange,
                                           "Sinking Inorganic Particles" = "dodgerblue4")

```
```{r Hour:Minute to Hour function}
i="1"
#hours_minutes = Results.df$TimeDiff
hours_minutes_to_hours <- function(hours_minutes) {
  #print(length(hours_minutes))
  
  output =list()
  
  for (i in 1:length(hours_minutes)) {
    if(grepl(pattern =":",  x = hours_minutes[i]) == T) {
    
      splitNumbers = strsplit(hours_minutes[i], split = ":")
      minutes = as.numeric(splitNumbers[[1]][2])/60
      hours = as.numeric(splitNumbers[[1]][1])
    
      tmp_output = as.numeric(hours + minutes)
    
      output = c(output, tmp_output)
    
    }
    else if (grepl(pattern =".",  x = hours_minutes[i]) == T) {
      
      tmp_output = as.numeric(hours_minutes[i])
    
      output = c(output, tmp_output)
    
    }
  else {
    print("Sample did not match format, hours and minutes must be separated by :")
  }  
  }
  
  return(output)
}

```
```{r String cutting function}

substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))
}

```
#Import dataframes and make analysis data frames - metagenomes and metatranscriptomes
```{r}
####Download, unzip, and load in metagenome/metatranscriptome data ####
path= "E:/Functional_R_analysis"
#path <- getwd()

h <- curl::new_handle()
curl::handle_setopt(
  handle = h,
  httpauth = 1,
  userpwd = "BICEST:vJGDYLs7"
)

#url_geneabund <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gene_catalog/GROS22__insertcounts.lengthnorm.profile.cellab.profile.gz" 
#curl::curl_download(url_geneabund,paste(path,"/BICEST_cellabund.tsv.gz", sep=""), handle =  h)
#gunzip(paste(path,"/BICEST_cellabund.tsv.gz", sep=""))
geneabund <- read.csv(paste0(path,"/BICEST_cellabund.tsv"), sep="\t", skip=1, header = TRUE, row.names = 1)

#url_annot <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gene_catalog/GROS22.kegg-annotations.tsv.gz" 
#curl::curl_download(url_annot,paste(path,"/GROS22.kegg-annotations.tsv.gz", sep=""), handle =  h)
#gunzip(paste(path,"/GROS22.kegg-annotations.tsv.gz", sep=""))
annot <- read.csv(paste0(path,"/GROS22.kegg-annotations.tsv"), sep="\t", skip=0, header = TRUE, row.names = 1, quote="")

#url_clstr <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gene_catalog/GROS22.clstr.gz" 
#curl::curl_download(url_clstr,paste(path,"/GROS22.clstr.gz", sep=""), handle =  h)
#gunzip(paste(path,"/GROS22.clstr.gz", sep=""))
clstr <- read.csv(paste0(path,"/GROS22.clstr"), sep="\t", skip=0, header = FALSE)
colnames(clstr) <- c("gene_cluster", "mem", "gene", "length", "pos")


#url_taxa <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-2.prok.genomes_2_gtdb.tsv.gz"
#curl::curl_download(url_taxa,paste(path,"/GROS22-2.gtdb.gz", sep=""), handle =  h)
#gunzip(paste(path,"/GROS22-2.gtdb.gz", sep=""))

#url_taxa2 <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-1.prok.genomes_2_gtdb.tsv.gz"
#curl::curl_download(url_taxa2,paste(path,"/GROS22-1.gtdb.gz", sep=""), handle =  h)
#gunzip(paste(path,"/GROS22-1.gtdb.gz", sep=""))

taxa <- read.csv(paste0(path,"/GROS22-2.gtdb"), sep="\t", skip=0, header = TRUE)
taxa <- rbind(taxa,read.csv(paste0(path,"/GROS22-2.gtdb"), sep="\t", header = TRUE))
taxa <- taxa %>% 
  separate(GTDBTK_TAXONOMY, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";")


##### Process abundance data ####
geneabund_2 <- geneabund %>% 
  rownames_to_column("gene_cluster") # remove rownames and rename to gene_cluster

geneabund_KO <- annot %>% 
  rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  dplyr::select(gene_cluster, KO) %>% # select only the columns titled gene_sluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values


geneabund_ko_otu_table <-
  geneabund_KO %>% 
  column_to_rownames("KO") %>% # remove rownames and rename to gene_cluster
  otu_table(., taxa_are_rows = TRUE) #make as a otu_table to generate a phyloseq object

sample_names(geneabund_ko_otu_table)
taxa_names(geneabund_ko_otu_table)

gene_abund_ko_annots <- annot %>%
 rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  dplyr::select(-"gene_cluster") %>% # remove the gene_cluster column
  distinct(., .keep_all = TRUE ) %>% # keep only unique KO id's
  rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  dplyr::select(KO, everything()) %>%  # reorders - so KO is in front
  column_to_rownames("KO") %>% # remove column named KO and make it the rowname
  as.matrix() %>% # convert to a matrix
  tax_table() # convert to a taxa table object for phyloseq object creation


taxa_names(gene_abund_ko_annots)


#####
metadata <- read.csv("F:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT


metadata2 <- read.csv("F:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
rownames(metadata)<-metadata$sampleid

genecat_ps <- phyloseq(geneabund_ko_otu_table, gene_abund_ko_annots, metadata)  # Combine into a single phyloseq object


gene_cluster_taxa <- clstr %>% 
  dplyr::select("gene_cluster", "gene") %>%  # retrieve the gene cluster and gene column
  dplyr::mutate(genome=stringr::str_replace(gene, "-scaf.*", "")) # remove the scaffold information to only keep the MAG ID the gene cluster is associated with.

```
##mOTUs
```{r Download data}
h <- curl::new_handle()
curl::handle_setopt(
  handle = h,
  httpauth = 1,
  userpwd = "BICEST:vJGDYLs7"
)

##Download Data##

# url_new_motus <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/motus/mag_2_new_motus" 
# url_ref_motus <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/motus/mag_2_existing_motus" 
# url_tax_bac <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gtdb/gtdbtk.bac120.summary.R214.tsv"
# url_tax_arc <-"https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gtdb/gtdbtk.ar53.summary.R214.tsv"
# url_tax_motus <- "https://zenodo.org/records/10275750/files/mOTUs3.1.0.genome_metadata.tsv.gz?download=1"
# url_checkm <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-2.prok.genomes_2_quality.tsv.gz"
# url_checkm2 <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-1.prok.genomes_2_quality.tsv.gz"
# motus_pkg_url <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/motus/motus/GROS22_mOTUs3.1.grosextended.motus"
# drep_url <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/drep/drep-099/data_tables/Cdb.csv.gz"
# url_16S_1 <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-1.prok.barrnap.0.9.tsv.gz"
# url_16S_2 <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-2.prok.barrnap.0.9.tsv.gz"
# 
# curl::curl_download(url_new_motus,paste(path,"/BICEST_mag_2_new_motus", sep=""), handle =  h)
# curl::curl_download(url_ref_motus,paste(path,"/BICEST_mag_2_existing_motus", sep=""), handle =  h)
# curl::curl_download(url_tax_bac,paste(path,"/BICEST_gtdbtk.bac120.summary.R214.tsv", sep=""), handle =  h)
# curl::curl_download(url_tax_arc,paste(path,"/BICEST_gtdbtk.ar53.summary.R214.tsv", sep=""), handle =  h)
# curl::curl_download(url_tax_motus,paste(path,"/mOTUs3.1.0.genome_metadata.tsv.gz", sep=""), handle =  h)
# curl::curl_download(url_checkm,paste(path,"/GROS22-2.prok.genomes_2_quality.tsv.gz", sep=""), handle =  h)
# curl::curl_download(url_checkm2,paste(path,"/GROS22-1.prok.genomes_2_quality.tsv.gz", sep=""), handle =  h)
# curl::curl_download(motus_pkg_url,paste(path,"/GROS22_mOTUs3.1.grosextended.motus", sep=""), handle =  h)
# curl::curl_download(drep_url,paste(path,"/Cdb.csv.gz", sep=""), handle =  h)
# curl::curl_download(url_16S_1,paste(path,"/GROS22-1.prok.barrnap.0.9.tsv.gz", sep=""), handle =  h)
# curl::curl_download(url_16S_2,paste(path,"/GROS22-2.prok.barrnap.0.9.tsv.gz", sep=""), handle =  h)

# gunzip(paste0(path,"/mOTUs3.1.0.genome_metadata.tsv.gz"), overwrite = T)
# gunzip(paste0(path,"/Cdb.csv.gz"), overwrite = T)
# gunzip(paste0(path,"/GROS22-2.prok.genomes_2_quality.tsv.gz"), overwrite = T)
# gunzip(paste0(path,"/GROS22-1.prok.genomes_2_quality.tsv.gz"), overwrite = T)
# gunzip(paste0(path,"/GROS22-1.prok.barrnap.0.9.tsv.gz"), overwrite = T)
# gunzip(paste0(path,"/GROS22-2.prok.barrnap.0.9.tsv.gz"), overwrite = T)
```


```{r Import data}
##Read mOTUs##

motus <- read.csv(paste0(path,"/GROS22_mOTUs3.1.grosextended.motus"), sep="\t", skip=2, header = TRUE, row.names = 1) ##Theres some junk in the first two lines
colnames(motus) <- gsub(".*_S", "S", colnames(motus) ) ##here im just removing the projectid for whatever reason. If you want to add this to gene_cat or remove here
rownames(motus) <- gsub(".* ", "", gsub("\\[|\\]", "", rownames(motus))) ##mOTUs contain a taxonomy followed by [mOTU_id] i just want mOTU_id


##Now we want to create  a list which matches each genome to its mOTU 
membership.new = read.csv(paste0(path, "/BICEST_mag_2_new_motus"), sep = "\t", header = FALSE) %>%
  dplyr::rename(mOTU = V1, reps=V2) %>%
  separate_wider_delim(reps, ";", names_sep = "split", too_few=c("align_start")) %>% 
  pivot_longer(!mOTU, values_to = "user_genome",values_drop_na = TRUE) %>% 
  select(user_genome, mOTU)
membership.ref = read.csv(paste0(path, "/BICEST_mag_2_existing_motus"), sep = "\t", header = FALSE, quote="") %>% 
  select(V1, V2)%>%
  dplyr::rename(., user_genome=V1, mOTU=V2)
membership <- rbind(membership.ref, membership.new)
nrow(membership)## 13765
##Read mOTUs Taxonomic Data

bac_gtdb = read.csv(paste0(path, "/BICEST_gtdbtk.bac120.summary.R214.tsv"), sep = "\t", header = TRUE) 
arc_gtdb = read.csv(paste0(path, "/BICEST_gtdbtk.ar53.summary.R214.tsv"), sep = "\t", header = TRUE)
gtdb = rbind(bac_gtdb, arc_gtdb) %>% 
  select(user_genome, classification )##Read in both archaea and bacteria
nrow(gtdb)## 13765
###Read in dRep data 

drep <- read.csv("Cdb.csv") %>% 
  select(genome, secondary_cluster)%>%
  dplyr::rename(user_genome=genome, drep_cluster = secondary_cluster) %>% 
  mutate(user_genome = gsub(".fa", "", user_genome))
nrow(drep) ## 13765
##Read in qa data 

qa <- read.csv(paste0(path,"/GROS22-2.prok.genomes_2_quality.tsv"), sep="\t", quote="") %>% 
  rbind(., read.csv(paste0(path,"/GROS22-1.prok.genomes_2_quality.tsv"), sep="\t", quote="")) %>% 
  dplyr::rename(user_genome = GENOME, completeness=COMPLETENESS, contamination=CONTAMINATION, genome_size=GENOME_SIZE) %>% 
  select(user_genome, completeness, contamination, N50, genome_size)
nrow(qa) ## 13765


##Read in barrnap (16S data)

barrnap <- read.csv(paste0(path, "/GROS22-1.prok.barrnap.0.9.tsv"), sep="\t", quote="") %>% 
  rbind(., read.csv(paste0(path, "/GROS22-2.prok.barrnap.0.9.tsv"), sep="\t", quote="")) %>% 
  dplyr::rename(user_genome = genome, full_16S_rRNA = X16S_rRNA, partial_16S_rRNA = X16S_rRNA_partial) %>%
  select(user_genome, full_16S_rRNA, partial_16S_rRNA)

###Combine all together
genome_stats <- left_join(membership, gtdb) %>% 
  left_join(drep) %>% 
  left_join(qa) %>%
  left_join(barrnap)
nrow(genome_stats) ## 13765
```

###Make dataframes 
```{r}
motu_stats <- genome_stats %>%
  mutate(type = if_else(grepl("NotEnoughMGs", mOTU), "Unassigned", if_else(grepl("ELB", mOTU), "BICEST", "mOTUs.3.1.0"))) 

###If you want to you can use this opportunity to reassign some of your MAGs from Unassigned using dRep clusters###
motu_stats %>% 
  group_by(drep_cluster, mOTU) %>%
  dplyr::summarise(n_mags = n_distinct(user_genome))

##You can already see that for instance 1000_1 has a MAG annotated as NotEnoughMGs, but this probably is ELBEEST_794
##However 1002_1  has 6 MAgs that are NotEnoughMGs, but then 2 that are ELBEEST_87 and ELBEEST_88. It would be nice to know which.
##This can also work in reverse, if we write this to output and search for ext_mOTU_v31_19264, we find around 10 drep clusters, 
##one of these has 141 and the rest 1 MAG each. Here I would tend towards assuming that each of these should be associated to this single mOTU
##Like i said before bad quality MAGs might not cluster with dREp but we find the MGs.
##Just be careful, if you want to modify the easiest way would be
motu_stats %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(n_drep = n_distinct(drep_cluster)) %>%
  filter(n_drep >1) %>% 
  arrange(desc(n_drep))

##This gives you a list of all the mOTUs with lots of drep clusters, 

##Double check the data 
motu_stats[which(motu_stats$mOTU == "ELBEEST_35"),] %>% 
  select(mOTU, drep_cluster, user_genome) %>% 
  group_by(drep_cluster) %>% 
  dplyr::summarise(n_mags = n_distinct(user_genome)) %>% 
  arrange(desc(n_mags))

##Now a quick one liner will rename all the drep_clusters to match the major mOTU cluster
motu_stats[which(motu_stats$mOTU == "ELBEEST_35"), "drep_cluster"] <- "568_8" ##This will remove the additional drep clusters
##Now just rerun the code block above to see that it worked and move on to the next one. 

##Now thats sorted lets see about those NotEnoughMG annots, here we are only interested in those that have 2 unique mOTU, ie un-/classified

motu_stats %>% 
  group_by(drep_cluster, mOTU) %>%
  dplyr::summarise(n_mags = n_distinct(user_genome)) %>% 
  ungroup() %>%
  group_by(drep_cluster) %>% 
  dplyr::summarise(n_mOTU = n_distinct(mOTU), n_mags=sum(n_mags)) %>%
  filter(n_mOTU ==2) %>% 
  arrange(desc(n_mags))

##This gives you a list of all the drep_clusters with lots of mOTUs, 

##Double check the data 
motu_stats[which(motu_stats$drep_cluster == "616_1"),] %>% 
  select(mOTU, drep_cluster, user_genome) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(n_mags = n_distinct(user_genome)) %>% 
  arrange(desc(n_mags))

##So we can see here that there are 134 assigned to ELBEEST_33 and 3 unassigned, lets go ahead and assign these. 
##Again a quick one liner
motu_stats[which(motu_stats$drep_cluster == "616_1"), "mOTU"] <- "ELBEEST_33" ##This will remove the additional drep clusters
##rerun the chunk above and we can see that now all are assigned to ELBEEST_33. 

###Lets plot the data to see how its looking. 
###We dont want to plot all groups so lets see which ones to focus on 
motu_stats %>% 
  separate(classification, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";") %>%
  group_by(phylum) %>%
  dplyr::summarise(n_mags = n_distinct(user_genome)) %>% 
  arrange(desc(n_mags))

##Lets select the top 7 to plot and assign the rest to the "Other" bin

motu_stats %>% 
  separate(classification, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";") %>% 
  mutate(Phylum_plot = ifelse(grepl("p__Pseudomonadota|p__Actinomycetota|p__Bacteroidota|p__Verrucomicrobiota|p__Patescibacteria|p__Planctomycetota|p__Chloroflexota", phylum), phylum, "Other")) %>%
  mutate(Phylum_plot = gsub("p__", "", Phylum_plot)) %>%
  group_by(type, Phylum_plot) %>%
  dplyr::summarise(n_mags = n_distinct(user_genome), PRESENT = sum(partial_16S_rRNA, full_16S_rRNA), ABSENT = n_mags-PRESENT) %>% 
  pivot_longer(cols = c("PRESENT", "ABSENT"), names_to = "rRNA", values_to ="counts") %>% 
  ggplot(aes(y=factor(type, levels=c("Unassigned", "mOTUs.3.1.0", "BICEST")), 
             x = n_mags, 
             alpha = factor(rRNA, levels=c("PRESENT","ABSENT")),
             fill=factor(type, levels=c("Unassigned", "mOTUs.3.1.0", "BICEST")))) + 
  geom_col() + scale_alpha_manual(values = c(1,0.5)) +
  theme_bw() +
  facet_grid(rows=vars(factor(Phylum_plot, levels=c("Actinomycetota", "Bacteroidota", "Chloroflexota", "Patescibacteria", "Planctomycetota",  "Pseudomonadota", "Verrucomicrobiota", "Other"))), 
             drop = TRUE, 
             scales="free", 
             switch = "y", 
             as.table = TRUE
  ) + xlab(label = "MAGs with and without partial 16S rRNA") +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        strip.text.y.left = element_text(angle = 0),
        strip.text = element_text(angle = 90),
        strip.background = element_blank(),
        legend.position = "bottom",
        panel.spacing = unit(0,'lines'),
        panel.border = element_blank()) + 
  labs (fill= "Database Sournce", alpha = "Contains full/partial 16S rRNA") +
  guides(fill = guide_legend(order=2, ncol=3, title.position = "top", 
                             label.hjust = 0, title.vjust = 1,
                             keywidth = unit(0.5, 'cm'), override.aes=list(size = 1)),
         alpha = guide_legend(order=2, ncol=3, title.position = "top", 
                              label.hjust = 0, title.vjust = 1,
                              keywidth = unit(0.5, 'cm')))

#####Ok so we have all that information together.

```

###Plot for instance genome completeness, size etc
```{r}
##First we need to create a single taxonomy for each of the new ELBEEST/BICEST mOTUs

genome_stats %>% 
  select(mOTU) %>% 
  unique() %>% 
  nrow() ## So I get 1172 unique mOTUs, including 874 ELBEEST mOTUs. Depending on your cleaning steps (drep etc) the following might change a bit
##particularly when we look at unique classifications. Lets keep that in mind and go forward

genome_stats %>% 
  select(mOTU, classification) %>% 
  unique() %>% 
  nrow() ## 1946, so now we have added classification and so we have a few hundred examples where there is more than one classification for a mOTU

genome_stats %>% 
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  arrange(desc(count))

##Ok that was a false alarm as we have 732 classifications for unclassified mOTUs

genome_stats %>% 
  filter(mOTU != "NotEnoughMGs") %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  arrange(desc(count)) %>% 
  nrow() ##ok so we need to resolve 40, this might differ when you add unclassified mOTUs into mOTU clusters above. 

##Ok so lets go through and see if we can do this relatively quickly 

motu_to_check <- genome_stats %>% 
  filter(mOTU != "NotEnoughMGs") %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  select(mOTU) %>% 
  pull()

##Ok so we have our list of 40 mOTUs that are conflicting

genome_stats %>% 
  filter(mOTU %in% motu_to_check) %>% 
  select(mOTU, classification, user_genome) %>% 
  group_by(mOTU, classification) %>%
  dplyr::summarise(count = n_distinct(user_genome)) %>%
  arrange(mOTU) %>% 
  print(n=100)
  
##Here we see at a first look that usually there is a more complete and less complete taxonomy. 
##Wracking my brain to automate this but I think we need to do a manual curate so lets set that up.
```

###Curate data
```{r Curate data}
##Just a quick note, how do we make sense of different level tax assignments. Lets say there are 10 MAGs belonging to a mOTU and 9 are assigned to species and 1 not. 
##This is an easy fix, ok lets just take the majority and go to species level. 
##Now what about if we have 9 not assigned and 1 is. Well this might be because only 1 was HQ and able to be assigned to species level. Shouldn't we trust the info from our HQ mag. I say yes!
##Of course with 10 it would be better if a few MAGs were assigned to species not just 1. 
##Generally most of your analysis will occur at the mOTU level or higher taxonomy (family or even phylum ) so dont stress about the need to assign each mOTU to species level. 

##You will also get mOTUs that are assigned to the same species but are two distinct mOTUs, so its not all that simple.

##code hidden here
genome_stats[which(genome_stats$mOTU == "ELBEEST_124" & genome_stats$classification == "d__Bacteria;p__Nitrospirota;c__Nitrospiria;o__Nitrospirales;f__Nitrospiraceae;g__Nitrospira_F;s__"), "classification"] <- "d__Bacteria;p__Nitrospirota;c__Nitrospiria;o__Nitrospirales;f__Nitrospiraceae;g__Nitrospira_F;s__Nitrospira_F sp919902665"
#The next example has two genus annotations for one mOTU, but the major is assigned to a single so we take that one 
genome_stats[which(genome_stats$mOTU == "ELBEEST_125" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Xanthomonadales;f__SZUA-36;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Xanthomonadales;f__SZUA-36;g__JABDPF01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_125" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Xanthomonadales;f__SZUA-36;g__JAHEFT01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Xanthomonadales;f__SZUA-36;g__JABDPF01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_174" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__Halioglobus;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_193" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__UBA3439;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__UBA3439;s__UBA3439 sp016778825"
genome_stats[which(genome_stats$mOTU == "ELBEEST_194" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__UBA3439;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__UBA3439;s__UBA3439 sp016778825"
genome_stats[which(genome_stats$mOTU == "ELBEEST_200" & genome_stats$classification == "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__"), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sulfonica"
genome_stats[which(genome_stats$mOTU == "ELBEEST_221" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Porticoccaceae;g__HTCC2207;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Porticoccaceae;g__HTCC2207;s__HTCC2207 sp002685195"
##Again here we have a genus conflict with 12/14 mOTUs assigned to a single genus which we will take
genome_stats[which(genome_stats$mOTU == "ELBEEST_272" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__SG8-39;g__CAILKO01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__SG8-39;g__SG8-39;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_310" & genome_stats$classification == "d__Bacteria;p__Actinomycetota;c__Acidimicrobiia;o__Acidimicrobiales;f__Ilumatobacteraceae;g__UBA3006;s__"), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Acidimicrobiia;o__Acidimicrobiales;f__Ilumatobacteraceae;g__UBA3006;s__UBA3006 sp903850275"
genome_stats[which(genome_stats$mOTU == "ELBEEST_362" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_A;g__JAHDXY01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_A;g__JAHDXY01;s__JAHDXY01 sp023257915"
genome_stats[which(genome_stats$mOTU == "ELBEEST_370" & genome_stats$classification == "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Pedosphaerales;f__AAA164-E04;g__;s__"), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Pedosphaerales;f__AAA164-E04;g__AAA164-E04;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_376" & genome_stats$classification == "d__Bacteria;p__Desulfobacterota_B;c__Binatia;o__HRBIN30;f__;g__;s__"), "classification"] <- "d__Bacteria;p__Desulfobacterota_B;c__Binatia;o__HRBIN30;f__JAGDMS01;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_403" & genome_stats$classification == "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__UBA3478;s__"), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__UBA3478;s__UBA3478 sp016780435"
genome_stats[which(genome_stats$mOTU == "ELBEEST_412" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_A;g__UBA2463;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_A;g__UBA2463;s__UBA2463 sp945901825"
genome_stats[which(genome_stats$mOTU == "ELBEEST_427" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Micavibrionales;f__UBA2020;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Micavibrionales;f__UBA2020;g__UBA2020;s__"
##here the most are unclassifed at the species level with 3 and 1 assigned to two genera. Lets be rational and take up to family 
genome_stats[which(genome_stats$mOTU == "ELBEEST_439" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__PHCI01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_439" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__JAKFVA01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__;s__"
##Again two genera 5/1 split
genome_stats[which(genome_stats$mOTU == "ELBEEST_455" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__Rhodoferax_A;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__CAIKVZ01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_458" & genome_stats$classification == "d__Bacteria;p__Patescibacteria;c__Paceibacteria;o__UBA9983_A;f__JAACPR01;g__;s__"), "classification"] <- "d__Bacteria;p__Patescibacteria;c__Paceibacteria;o__UBA9983_A;f__JAACPR01;g__JAGOTN01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_492" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudohongiellaceae;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudohongiellaceae;g__CAILUG01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_504" & genome_stats$classification == "d__Bacteria;p__Myxococcota;c__UBA727;o__UBA727;f__JABDBI01;g__;s__"), "classification"] <- "d__Bacteria;p__Myxococcota;c__UBA727;o__UBA727;f__JABDBI01;g__JAHFEG01;s__"
##Here we have a family split 10/4. im tempted to take to order level but for now will select dominant family
genome_stats[which(genome_stats$mOTU == "ELBEEST_514" & genome_stats$classification == "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__DEV007;g__;s__"), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__SKLO01;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_517" & genome_stats$classification == "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__;g__;s__"), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__SKLO01;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_519" & genome_stats$classification == "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__;s__"), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__Lutibacter;s__"
##genus 6/1 split
genome_stats[which(genome_stats$mOTU == "ELBEEST_542" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Methylophilaceae;g__BACL14;s__BACL14 sp905181685"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Methylophilaceae;g__BACL14;s__BACL14 sp019823025"
genome_stats[which(genome_stats$mOTU == "ELBEEST_58" & genome_stats$classification == "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__"), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp014190015"
genome_stats[which(genome_stats$mOTU == "ELBEEST_585" & genome_stats$classification == "d__Bacteria;p__Acidobacteriota;c__Vicinamibacteria;o__Vicinamibacterales;f__UBA2999;g__;s__"), "classification"] <- "d__Bacteria;p__Acidobacteriota;c__Vicinamibacteria;o__Vicinamibacterales;f__UBA2999;g__CADEFD01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_59" & genome_stats$classification == "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__"), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp014190015"
##Family 3/1 split 
genome_stats[which(genome_stats$mOTU == "ELBEEST_601" & genome_stats$classification == "d__Bacteria;p__Patescibacteria;c__Paceibacteria;o__UBA9983_A;f__W02-35-19;g__;s__"), "classification"] <- "d__Bacteria;p__Patescibacteria;c__Paceibacteria;o__UBA9983_A;f__JAGLPS01;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_623" & genome_stats$classification == "d__Bacteria;p__Bdellovibrionota;c__UBA1018;o__UBA1018;f__UBA1018;g__;s__"), "classification"] <- "d__Bacteria;p__Bdellovibrionota;c__UBA1018;o__UBA1018;f__UBA1018;g__CAINWE01;s__"
##Genus 2/1 split, definately going up to family level
genome_stats[which(genome_stats$mOTU == "ELBEEST_700" & genome_stats$classification == "d__Bacteria;p__Cyanobacteriota;c__Vampirovibrionia;o__LMEP-6097;f__LMEP-6097;g__JAJTHA01;s__"), "classification"] <- "d__Bacteria;p__Cyanobacteriota;c__Vampirovibrionia;o__LMEP-6097;f__LMEP-6097;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_700" & genome_stats$classification == "d__Bacteria;p__Cyanobacteriota;c__Vampirovibrionia;o__LMEP-6097;f__LMEP-6097;g__CAIYXB01;s__"), "classification"] <- "d__Bacteria;p__Cyanobacteriota;c__Vampirovibrionia;o__LMEP-6097;f__LMEP-6097;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_779" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Rickettsiales;f__UBA1997;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Rickettsiales;f__UBA1997;g__UBA2645;s__"


##So that is all of the BICEST mOTUs, we will deal with the mOTUs3.1 seperately because they are built from MAGs that might have a better taxonomic assignment than ours. 
##

genome_stats %>% 
  filter(mOTU != "NotEnoughMGs") %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  select(mOTU) %>% 
  pull()

##Ok so now we only have a few conflicts relating to the ext_mOTUs, first lets extract the classificaiton for the BICEST mOTUs

elbe_taxa <- genome_stats %>% 
  filter(grepl("ELBEEST", mOTU)) %>% 
  select(mOTU, classification) %>% 
  group_by(mOTU) %>%
  unique()
##Quick sanity check

length(unique(elbe_taxa$mOTU)) ##1046
nrow(elbe_taxa) ##1046

##Ok so now we have a single taxonomy for each BICEST mOTU!!

##Lets deal with the reference mOTUs. 

motus_taxa <- read.table(paste0(path, "/mOTUs3.1.0.genome_metadata.tsv"), sep="\t", header=TRUE, quote="") %>% 
  select(GENOME..MOTU, GTDB.R207) %>% 
  dplyr::rename(mOTU = GENOME..MOTU, classification = GTDB.R207)
nrow(motus_taxa) ## so we have taxonomy for 700K MAGs/genomes!!
length(unique(motus_taxa$mOTU)) ## This is around 34195 mOTUs

##Lets see how many are in our profile

motus %>% 
  rownames_to_column("mOTU") %>% 
  select(mOTU) %>%
  filter(!grepl("ELBE", mOTU)) %>% 
  nrow() ## so we have 34341 mOTUs 

##This is a very similar number to the total number of mOTUs so maybe there are quite some zero values

refmOTUs_in_profile <- motus %>% 
  rownames_to_column("mOTU") %>% 
  pivot_longer(!mOTU, names_to = "samples", values_to = "counts") %>% 
  group_by(mOTU) %>%
  dplyr::mutate(total = sum(counts)) %>% 
  filter(total != 0) %>%
  ungroup() %>%
  select(-total) %>% 
  select(mOTU)  %>% 
  unique() %>%
  filter(!grepl("ELBE", mOTU)) %>% 
  pull() ##%>%
  #length() ## Ok so now we have only 2072 ref mOTUs, also for sanity we can remove ! from filter and see that all 1046 BICEST mOTUs are also detected in our profiles.  
length(refmOTUs_in_profile)

##Ok lets check some taxonomy!!  

##First lets remove all of the information for mOTUs not in our profiles      
  
motus_taxa <- motus_taxa %>% 
    rownames_to_column("user_genome") %>% 
    filter(mOTU %in% refmOTUs_in_profile) %>% 
    select(mOTU, classification, user_genome)

nrow(motus_taxa) ##Ok so we are down from 700K genomes to 126k. 
length(unique(motus_taxa$mOTU)) ##Now we lost 11 mOTUs. This is meta_mOTUs which dont have taxonomy associated with them, they are built on MG profiles not MAGs (check paper for details) - we will fix later

##Lets add also our genome taxonomy information incase this helps 

motus_taxa <- genome_stats %>% 
  filter(mOTU %in% motu_to_check) %>% 
  select(mOTU, classification, user_genome) %>% 
  rbind(motus_taxa) 

##So we added around 180 MAGs to the 126K (obviously not much) mOTUs3.1.0 metadata file from our own dataset

##Now we make again a list of taxa with conflict
motu_to_check <- motus_taxa %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  select(mOTU) %>% 
  pull()
length(motu_to_check)
##Great so now we have a list of around 218 mOTUs to check. Lets do this!!

motus_taxa %>% 
  filter(mOTU %in% motu_to_check) %>% 
  select(mOTU, classification, user_genome) %>% 
  group_by(mOTU, classification) %>%
  dplyr::summarise(count = n_distinct(user_genome)) %>%
  arrange(mOTU) %>% 
  print(n=800)

##Now I just realised that this could be a lot more efficient than what we did above.

##code hidden here
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_14660"), "classification"] <- "d__Archaea;p__Thermoproteota;c__Nitrososphaeria;o__Nitrososphaerales;f__Nitrosopumilaceae;g__Nitrosarchaeum;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_15383"), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Coriobacteriia;o__Coriobacteriales;f__Atopobiaceae;g__NM07-P-09;s__NM07-P-09 sp004793665"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_15977"), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__S36-B12;g__S36-B12;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_16111"), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Rhodoferax;s__Rhodoferax sp014190675"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_16115"), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Crocinitomicaceae;g__UBA952;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_16131"), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Polynucleobacter;s__Polynucleobacter sp009927445"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_17177"), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Pelagibacterales;f__Pelagibacteraceae;g__Pelagibacter;s__Pelagibacter sp902565935"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_17878"), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Phocaeicola;s__Phocaeicola vulgatus"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19170" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Crocinitomicaceae;g__M0103;s__M0103 sp903930085"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19171" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp009702965"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19172" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Nanopelagicus;s__Nanopelagicus sp001437855"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19173" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Nanopelagicus;s__Nanopelagicus sp001437855"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19207" ), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__V1-33;g__CAJBME01;s__CAJBME01 sp903954065"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19221" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Chitinophagales;f__Saprospiraceae;g__BJGN01;s__BJGN01 sp014190515"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19232" ), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Opitutales;f__UBA953;g__UBA953;s__UBA953 sp004293385"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19239" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Limnohabitans_A;s__Limnohabitans_A sp001517545"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19252" ), "classification"] <- "dd__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp014190015"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19259" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Nanopelagicus;s__Nanopelagicus sp003569185"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19260" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Methylophilaceae;g__Methylotenera;s__Methylotenera sp903951385"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19262" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila vernalis"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19273" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Chitinophagales;f__Chitinophagaceae;g__Sediminibacterium;s__Sediminibacterium sp017987615"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19287" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__Flavobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19290" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Crocinitomicaceae;g__Fluviicola;s__Fluviicola sp017983675"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19295" ), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp014190015"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19298" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Caulobacterales;f__Hyphomonadaceae;g__Hyphomonas;s__Hyphomonas sp016124495"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19383" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Schleiferiaceae;g__TMED14;s__TMED14 sp005786915"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19415" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Cytophagales;f__Cyclobacteriaceae;g__ELB16-189;s__ELB16-189 sp016787665"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19437" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Thermoleophilia;o__Gaiellales;f__F1-60-MAGs149;g__F1-60-MAGs149;s__F1-60-MAGs149 sp903960645"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19455" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp903839585"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19461" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Crocinitomicaceae;g__Fluviicola;s__Fluviicola sp017983675"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19467" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingorhabdus_B;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19767" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__MED-G116;s__MED-G116 sp004212735"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_21813" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__S36-B12;g__S36-B12;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_22053" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Nitrincolaceae;g__ASP10-02a;s__ASP10-02a sp002335115"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_21767" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__MED-G116;s__MED-G116 sp004212735"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_28513" ), "classification"] <- "d__Bacteria;p__Chloroflexota;c__Limnocylindria;o__Limnocylindrales;f__Limnocylindraceae;g__Limnocylindrus;s__Limnocylindrus sp903937225"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_28707" ), "classification"] <- "d__Bacteria;p__Planctomycetota;c__Planctomycetia;o__Gemmatales;f__Gemmataceae;g__UBA969;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_28709" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Chitinophagales;f__Chitinophagaceae;g__OLB11;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12332" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__Prevotella copri_A"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12366" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Lachnospirales;f__Lachnospiraceae;g__Agathobacter;s__Agathobacter faecis"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12572" ), "classification"] <- "d__Archaea;p__Thermoproteota;c__Nitrososphaeria;o__Nitrososphaerales;f__Nitrosopumilaceae;g__Nitrosopumilus;s__Nitrosopumilus sp002690535"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12608" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__HIMB59;f__HIMB59;g__HIMB59;s__HIMB59 sp902529795"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12714" ), "classification"] <- "d__;p__;c__;o__;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12781" ), "classification"] <- "d__Archaea;p__Thermoplasmatota;c__Poseidoniia;o__Poseidoniales;f__Poseidoniaceae;g__MGIIa-L2;s__MGIIa-L2 sp002171315"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12833" ), "classification"] <- "d__Bacteria;p__;c__;o__;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12945" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Rhodothermia;o__Balneolales;f__Balneolaceae;g__UBA1275;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13018" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Puniceispirillales;f__AAA536-G10;g__AAA536-G10;s__AAA536-G10 sp016777705"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13056" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__Luminiphilus;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13185" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhodobacterales;f__Rhodobacteraceae;g__MED-G52;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13209" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__Luminiphilus;s__Luminiphilus sp905182485"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13257" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhodobacterales;f__Rhodobacteraceae;g__GCA-2697345;s__GCA-2697345 sp002697345"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13622" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__GCA-002733185;s__GCA-002733185 sp002713705"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13782" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__UBA10066;g__MED-G20;s__MED-G20 sp016780365"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_14148" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_14237" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__Luminiphilus;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_14284" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__SAR86;f__SAR86;g__GCA-2707915;s__GCA-2707915 sp016777005"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_14430" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00049" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00050" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00051" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00052" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00056" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00085" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Enterobacteriaceae;g__Klebsiella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00086" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Enterobacteriaceae;g__Klebsiella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00095" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Enterobacteriaceae;g__Escherichia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00122" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00129" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00131" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00133" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00140" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00150" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00164" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00167" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00168" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00169" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00170" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00188" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00201" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00206" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00215" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00227" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00259" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Acinetobacter;s__Acinetobacter baumannii"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00267" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Acinetobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00283" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Lactobacillales;f__Streptococcaceae;g__Streptococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00296" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Lactobacillales;f__Streptococcaceae;g__Streptococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00312" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Lactobacillales;f__Streptococcaceae;g__Streptococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00328" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Bacillales;f__Bacillaceae_G;g__Bacillus_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00344" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Staphylococcales;f__Staphylococcaceae;g__Staphylococcus;s__Staphylococcus hominis"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00424" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Janthinobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00444" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Curvibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00453" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Acidovorax_A;s_"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00459" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Comamonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00474" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Variovorax;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00483" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Variovorax;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00485" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Variovorax;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00487" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Variovorax;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00520" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00521" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Duganella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00547" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Achromobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00576" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Vibrionaceae;g__Photobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00728" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Micromonosporaceae;g__Micromonospora;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00738" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Micromonosporaceae;g__Micromonospora;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00772" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Rhizobiaceae;g__Mesorhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00800" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Propionibacteriales;f__Propionibacteriaceae;g__Cutibacterium;s__Cutibacterium acnes"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00802" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Corynebacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00853" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Oscillospirales;f__Acutalibacteraceae;g__Ruminococcus_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00855" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Bacteroides;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00870" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00871" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00873" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00881" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00882" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Comamonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00964" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Micrococcaceae;g__Micrococcus;s__Micrococcus luteus"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00996" ), "classification"] <- "d__Bacteria;p__Campylobacterota;c__Campylobacteria;o__Campylobacterales;f__Campylobacteraceae;g__Campylobacter_B;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00999" ), "classification"] <- "d__Bacteria;p__Fusobacteriota;c__Fusobacteriia;o__Fusobacteriales;f__Fusobacteriaceae;g__Fusobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01010" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rickettsiales;f__Rickettsiaceae;g__Rickettsia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01011" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rickettsiales;f__Rickettsiaceae;g__Rickettsia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01035" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Oleiphilaceae;g__Marinobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01043" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Rhizobiaceae;g__Rhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01071" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Caulobacterales;f__Caulobacteraceae;g__Brevundimonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01089" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Enterobacteriaceae;g__Yersinia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01096" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Pseudoduganella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01141" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Beijerinckiaceae;g__Methylobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01170" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Tannerellaceae;g__Macellibacteroides;s__Macellibacteroides fermentans"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01185" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Xanthobacteraceae;g__Bradyrhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01191" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Xanthobacteraceae;g__Bradyrhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01211" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01213" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Rhodococcus;s_"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01234" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Paraburkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01241" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Cupriavidus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01242" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Cupriavidus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01243" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Cupriavidus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01274" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Mycobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01337" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01338" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01361" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Chromatiales;f__Chromatiaceae;g__Marichromatium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01404" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Vibrionaceae;g__Vibrio;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01513" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhodobacterales;f__Rhodobacteraceae;g__Cereibacter_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01518" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Azospirillales;f__Azospirillaceae;g__Azospirillum;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01547" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Sphingobacteriales;f__Sphingobacteriaceae;g__Pedobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01556" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Bacillales;f__Bacillaceae;g__Bacillus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01692" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Xanthobacteraceae;g__Bradyrhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01693" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Xanthobacteraceae;g__Bradyrhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01786" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Stenotrophomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01789" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingomonas;s__Sphingomonas aquatilis"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01861" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Alteromonadaceae;g__Pseudoalteromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01862" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Alteromonadaceae;g__Pseudoalteromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01866" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Alteromonadaceae;g__Pseudoalteromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01874" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Microbacteriaceae;g__Clavibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01920" ), "classification"] <- "d__Bacteria;p__Cyanobacteria;c__Cyanobacteriia;o__PCC-6307;f__Cyanobiaceae;g__Synechococcus_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01940" ), "classification"] <- "d__Bacteria;p__Firmicutes_C;c__Negativicutes;o__Veillonellales;f__Veillonellaceae;g__Veillonella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01941" ), "classification"] <- "d__Bacteria;p__Firmicutes_C;c__Negativicutes;o__Veillonellales;f__Veillonellaceae;g__Veillonella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01953" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02019" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Actinomycetaceae;g__Actinomyces;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02037" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Weeksellaceae;g__Elizabethkingia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02129" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Rhizobiaceae;g__Aurantimonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02154" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Lachnospirales;f__Lachnospiraceae;g__Blautia_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02348" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Stappiaceae;g__Pannonibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02367" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Phocaeicola;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02398" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02485" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Vibrionaceae;g__Vibrio;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02580" ), "classification"] <- "d__Bacteria;p__Cyanobacteria;c__Cyanobacteriia;o__Cyanobacteriales;f__Microcystaceae;g__Microcystis;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02588" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_K;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02642" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Polaromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02650" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Acinetobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02696" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Caulobacterales;f__Caulobacteraceae;g__Brevundimonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02700" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Bifidobacteriaceae;g__Bifidobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02783" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Lactobacillales;f__Enterococcaceae;g__Enterococcus_D;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02795" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02801" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Staphylococcales;f__Staphylococcaceae;g__Staphylococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02804" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Rhodanobacteraceae;g__Rhodanobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02810" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Bacteroides;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03205" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Acinetobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03341" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Oscillospirales;f__Oscillospiraceae;g__Dysosmobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03342" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Lachnospirales;f__Lachnospiraceae;g__Blautia_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03567" ), "classification"] <- "d__Bacteria;p__Cyanobacteria;c__Cyanobacteriia;o__Cyanobacteriales;f__Microcoleaceae;g__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03572" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Tissierellales;f__Peptoniphilaceae;g__Finegoldia;s_"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03577" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Bifidobacteriaceae;g__Bifidobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03591" ), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__Akkermansiaceae;g__Akkermansia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03640" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Tannerellaceae;g__Parabacteroides;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03657" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Lachnospirales;f__Lachnospiraceae;g__Agathobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03701" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03761" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03850" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Lysobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03854" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Sphaerotilus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04025" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Oleiphilaceae;g__Marinobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04078" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Vibrionaceae;g__Vibrio;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04204" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhodobacterales;f__Rhodobacteraceae;g__Ascidiaceihabitans;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04231" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Arenimonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04265" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Pelagibacterales;f__Pelagibacteraceae;g__Pelagibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04339" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Staphylococcales;f__Staphylococcaceae;g__Staphylococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04469" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Lysobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04470" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Lysobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04516" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04596" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Rhizobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04616" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Microbacteriaceae;g__Plantibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04737" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04792" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Sphingobacteriales;f__Sphingobacteriaceae;g__Sphingobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04802" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Corynebacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04827" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Halomonadaceae;g__Halomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05125" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Pseudonocardiaceae;g__Pseudonocardia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05354" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Mycobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05380" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Lysobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05437" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Caulobacterales;f__Caulobacteraceae;g__Phenylobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05522" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05841" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Marinomonadaceae;g__Marinomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05975" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06002" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Moraxella_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06109" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Oscillospirales;f__Ruminococcaceae;g__Faecalibacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06146" ), "classification"] <- "d__Bacteria;p__Campylobacterota;c__Campylobacteria;o__Campylobacterales;f__Arcobacteraceae;g__Aliarcobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06160" ), "classification"] <- "d__Bacteria;p__Myxococcota;c__Myxococcia;o__Myxococcales;f__Anaeromyxobacteraceae;g__Anaeromyxobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06277" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Stenotrophomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06494" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Pelagibacterales;f__Pelagibacteraceae;g__IMCC9063;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06514" ), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Pedosphaerales;f__AAA164-E04;g__AAA164-E04;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_07361" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__SAR86;f__D2472;g__D2472;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_09389" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Peptostreptococcales;f__Peptostreptococcaceae;g__Romboutsia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_10657" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Pelagibacterales;f__Pelagibacteraceae;g__Pelagibacter_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_12136" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Nanopelagicus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_12137" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__"


motus_taxa %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  select(mOTU) %>% 
  pull()

##Hurrah so now we have a single taxonomy for each of the mOTUs3.1.0 db mOTUs. 

motu_final_taxa <- motus_taxa %>% 
  select(mOTU, classification) %>% 
  group_by(mOTU) %>%
  unique()

##Quick sanity check

length(unique(motu_final_taxa$mOTU)) ##2063
nrow(motu_final_taxa) ##2063

##If this doesnt look right reload mOTUs db and try again, i was having some issues.

elbe_motu_taxa <- rbind(elbe_taxa, motu_final_taxa) %>% 
  separate(classification, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";")

#Fix errors
elbe_motu_taxa[c(1394,1660,1683,1684),]
elbe_motu_taxa[c(1394,1660,1683,1684),]$domain = c("d__Bacteria", "d__Bacteria","d__Bacteria","d__Bacteria")
elbe_motu_taxa[c(1394,1660,1683,1684),]$phylum = c("p__Cyanobacteria", "p__","p__","p__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$class = c("c__Cyanobacteriia", "c__","c__","c__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$order = c("o__Cyanobacteriales", "o__","o__","o__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$family = c("f__Microcoleaceae ", "f__","f__","f__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$genus = c("g__", "g__","g__","g__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$species = c("s__", "s__","s__","s__")
elbe_motu_taxa[c(1394,1660,1683,1684),]
```

###Create tables to use
```{r Create final tables}
##Lets also do what we didnt before and create a simplified mOTU table

motus_final <- motus %>% 
  rownames_to_column("mOTU") %>% 
  pivot_longer(!mOTU, names_to = "samples", values_to = "counts") %>% 
  group_by(mOTU) %>%
  dplyr::mutate(total = sum(counts)) %>% 
  filter(total != 0) %>%
  ungroup() %>%
  select(-total) %>% 
  pivot_wider(names_from = "samples", values_from = "counts")

nrow(motus_final) #3118 which is longer than our 3109 taxa, this includes some meta_motus that dont have taxonomy, as well as unclassified seqs, lets fix this.

elbe_motu_taxa <- motus_final %>%
  select(mOTU) %>% 
  filter(!mOTU %in% elbe_motu_taxa$mOTU) %>% 
  dplyr::mutate(classification = "d__;p__;c__;o__;f__;g__;s__") %>%
  separate(classification, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";") %>%
  rbind(.,elbe_motu_taxa) %>%
  distinct()
dim(elbe_motu_taxa)  
##Great so now we have taxonomy for the 3118 mOTUs (inc unassigned) that occur in our profile
```


```{r Add metadata and assess fraction splits}
#All we are missing is the metadata, I steal code chunk from the functional profile##

metadata <- read.csv("SAMEAID_SampleID.csv", header=TRUE, sep=";", dec=",") %>% 
  mutate(sampleid=paste0(BioSample,"_METAT")) %>%
  mutate(data_type="METAT")

metadata2 <- read.csv("SAMEAID_SampleID.csv", header=TRUE, sep=";", dec=",") %>% 
  mutate(sampleid=paste0(BioSample,"_METAG"))%>%
  mutate(data_type="METAG")

metadata <- rbind(metadata, metadata2) 
##There are some missing values for replicates and I want to simplify headers using good practice (lowercases, no special char, english)

metadata <- metadata %>% 
  select(sampleid, station=Station, station_km = Stromkilometer, sample_type = Sample_type, date=Sample_date, o2_sat=Sat_O2_TBDHereon, wtemp=Temperature_TBDHereon, 
         salinity=Salinity_TBDHereon, turbidty=Turbidity_TBDHereon, ph=pH_TBDHereon, o2_conc=O2_TBDHereon, spm_mg_l=SPM_mgperL, doc_mg_l=DOC_mg.L, tn_mg_l=TN_mg.L,
         dic_mg_l=DIC_mg.L, si_mg_l=Silicate_mg.L, nh4_mg_l=Ammonium_mg.L, no2_mg_l=Nitrite_mg.L, no3_mg_l=Nitrate_mg.L, din_um=Total_DIN_ÂµM, srp_ml_l=SRP_mgperL,
         tdp_mg_l=TotalDissolvedPhosphate_mg.L, nh4_um = Ammonium_ÂµM, no2_um = Nitrite_ÂµM, no3_um = Nitrate_ÂµM, srp_um = SRP_ÂµM, tdp_um = Phosphate_ÂµM,
         si_um = Silicate_ÂµM, doc_um = DOC_uM.L, dic_um = DIC_uM.L, respiration_o2_ug_l_h=RespirationRate_O2ug.L.h, poc_mg_l = POC_mgperL, ptc_mg_l = PTC_mgperL, 
         ptn_mg_l = PTN_mgperL, pth_mg_l = PTH_mgperL, BioSample, ERANumber, data_type)

##Sometimes the replicates miss values, to correct we will group by station, date, sample_type(fraction), then calculate the mean value ignoring na. 
##If there isnt a measurement it returns a NaN value

metadata <- metadata %>% 
  group_by(station, date, sample_type) %>%
  mutate(across(where(is.numeric), ~mean(., na.rm = TRUE))) %>% 
  ungroup()

#Check if there's any duplicates
metadata$duplicate = duplicated(metadata) | duplicated(metadata, fromLast = TRUE)
unique(metadata$duplicate)

metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(714.98, 613, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)

write.csv(metadata, "metadata.csv")
#saveRDS(metadata, file="metadata.RDS")

##Lets create a dataframe to hold all the data (yes this can be done with phyloseq but phyloseq has its own problems and we usually end up exporting tables back out for vegan anyway so we can work from here )

motus_final_taxa_metadata <- motus_final %>%
  pivot_longer(!mOTU, names_to = "sampleid", values_to = "counts") %>% 
  left_join(., elbe_motu_taxa) %>% 
  left_join(., metadata)

##Lets save what we have produced and cleanup some of the rubbish
##Its a good idea to hash this out so we dont accidentally overwrite anything

saveRDS(motus_final_taxa_metadata, file="motus_final_taxa_metadata.RDS")
saveRDS(motu_stats, file="motu_stats.RDS")
saveRDS(metadata, file="metadata.RDS")

rm(list=ls())
```



```{r Re-read in saved data}
motus_final_taxa_metadata <- readRDS(file="E:/Functional_R_analysis/motus_final_taxa_metadata.RDS")
metadata <- readRDS(file="E:/Functional_R_analysis/metadata.RDS")
##Lets check out experimental scheme

setwd("E:/Functional_R_analysis/")
path <- getwd()

motus_final_taxa_metadata %>% 
  select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, date) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##So when we consider fraction and date we see that Nov 21 has few samples, we should consider removing

motus_final_taxa_metadata %>% 
  select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, station) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##By station we see that Kollmar, SeemanshÃÂ¶ft and BunthausSpitze also were sampled infrequently, lets also remove these. 

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date))
```


```{r Check counts}
####Lets see how our counts look across all the samples, im going to create sub_files for plotting rather than piping directly to ggplot because it takes time
##when we want to adjust visuals

sample_specific_counts <- motus_final_taxa_metadata %>% 
  group_by(sampleid) %>%
  dplyr::mutate(sample_sums=sum(counts)) %>% 
  select(sampleid, data_type, sample_type, sample_sums)


  ggplot(sample_specific_counts,aes(x=sampleid, y=sample_sums)) + geom_point() 

##Ok there are clearly some samples with far fewer mOTU counts. Lets see how this looks when we compare metaT and metaG, also for the different size fractions

sample_specific_counts %>%
  ggplot() +
  geom_point(aes(x=sampleid, y=sample_sums)) +
  facet_wrap(~data_type*sample_type, scales="free_y", nrow=2)

###So take homes. We shouldnt compare metaG an metaT because the counts are an order of magnitude. You can look at metaT later. For now i will ignore. 
###Should we compare FL and PA (maybe but also maybe not), 
###There is an argument for comparing FL and PA but generally you want to explore what are the drivers of composition independent of fraction anyway. 
##Lets split the files, i will keep heavy and light together, splitting more reduces the number of pairwise comparisons which also helps.

colnames(motus_final_taxa_metadata)

motus_metadata_metag_fl <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG" & sample_type == "Free_living")

motus_metadata_metag_pa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG" & sample_type != "Free_living")

##Lets start with free-living by first checking the sample_sums again

motus_metadata_metag_fl %>% 
  group_by(sampleid) %>%
  mutate(sample_sums=sum(counts)) %>%
  select(sampleid, station, date, sample_sums) %>%
  unique() %>% 
  arrange(sample_sums) %>% 
  print(n=61)

##So we can see here that counts from Feb 22 are also quite low from all free-living samples. 

motus_metadata_metag_pa %>% 
  group_by(sampleid) %>%
  mutate(sample_sums=sum(counts)) %>%
  select(sampleid, station, date, sample_sums) %>%
  unique() %>% 
  arrange(sample_sums) %>% 
  print(n=61)

##So we can see here that counts from Feb 22 are also quite low from all particle-associated samples. These are in theory the only winter samples. 
##These samples generally had lower read counts. Anyway lets compare this also with the functional profiles to make an assessment. 
##We dont want to throw away a whole month of samples if the data are biologically interesting but also we shouldnt force a perspective based on sampling depth

##For now I will remove them

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Feb 22", date))

motus_metadata_metag_fl <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG" & sample_type == "Free_living")

motus_metadata_metag_pa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG" & sample_type != "Free_living")

##Lets check again

motus_metadata_metag_fl %>% 
  group_by(sampleid) %>%
  mutate(sample_sums=sum(counts)) %>%
  select(sampleid, station, date, sample_sums) %>%
  unique() %>% 
  arrange(sample_sums) %>% 
  print(n=61)

##Theres two samples with low counts (lower than 14k), lets remove these also

motus_metadata_metag_fl <- motus_metadata_metag_fl %>% 
  filter(!grepl("SAMEA112714820_METAG|SAMEA110290254_METAG", sampleid))

##and the particle associated

motus_metadata_metag_pa %>% 
  group_by(sampleid) %>%
  mutate(sample_sums=sum(counts)) %>%
  select(sampleid, station, date, sample_sums) %>%
  unique() %>% 
  arrange(sample_sums) %>% 
  print(n=61)

#Here the sums are genearlly lower with a plateau around 8k reads. For now we will leave everything and come back if these cause issues.
```
###Make phyloseq ovbject

```{r}
#so to do a ternary plot we actually need to create a physeq object really quick 
motus_table <- motus_final_taxa_metadata %>%
  filter(data_type == "METAG") %>%
  select(mOTU, sampleid, counts) %>%
  group_by(sampleid) %>% 
  mutate(total=sum(counts)) %>% 
  filter(total > 2400) %>%  ##Here we just remove those with low counts
  select(-total) %>% 
  ungroup() %>% 
  pivot_wider(names_from = sampleid, values_from = counts, values_fill = 0) %>% 
  column_to_rownames("mOTU") %>% 
  phyloseq::otu_table(taxa_are_rows = TRUE)
motus_taxa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  select(mOTU, phylum, class, order, family, genus, species) %>% 
  unique() %>% 
  column_to_rownames("mOTU") %>% 
  as.matrix() %>%
  phyloseq::tax_table()
motus_sampledata <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  select(-phylum, -class, -order, -family, -genus, -species, -counts, -mOTU, -domain) %>% 
  unique() %>%  
  column_to_rownames("sampleid") %>% 
  sample_data()
bicest_motu_ps <- phyloseq(motus_table, motus_taxa, motus_sampledata)
bicest_motu_ps
#bicest_motu_ps_v0 = bicest_motu_ps
```


#Carbon producing vs utilising
 - use this paper ?
 Genome content predicts the carbon catabolic preferences of heterotrophic bacteria - Otto Cordero

##Heat plot of CO2/CH4 utilising genes
```{r}
#Import gene list
CarbonGenelist.df = read.csv("CarbonGeneList.csv", header = T, sep = ";")

#Import gene list
CarbonGenelist.df = read.csv("CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% BugHunt_GeneList.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% BugHunt_GeneList.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
  
amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% BugHunt_GeneList.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(BugHunt_GeneList.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') # remove sample from BunthausSpitze
  

dim(amoAClean_CO2CH4_tbl_long)

#CO2CH4_tbl_long %>% separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName"))

#Reorder factors for better plotting
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("Mai 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "Mai 22",
                                              "Jun 22",
                                              "Nov 22"))

#Adjust values for accuracy and log transform
amoAClean_CO2CH4_tbl_long$counts = (amoAClean_CO2CH4_tbl_long$counts/1000)#+1
#CO2CH4_tbl_long$counts = CO2CH4_tbl_long$counts + 1

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)
```
##Significant fraction/date/Station differences
```{r}

####Prepare dataframe####


#Import gene list
CarbonGenelist.df = read.csv("CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

#Correct abundance
amoAClean_geneabund_KO[c(2:264)] = amoAClean_geneabund_KO[c(2:264)] / 1000


amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")


####Run tests####

amoAClean_CO2CH4_tbl_long = read.csv( "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")
#Remove all but the relevant object to run anova models
#library(gdata)
#keep(amoAClean_CO2CH4_tbl_long)
#keep(amoAClean_CO2CH4_tbl_long, sure = TRUE, all = TRUE)

#CO2CH4_tbl_long %>% separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName"))

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("Mai 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "Mai 22",
                                              "Jun 22",
                                              "Nov 22"))

#Adjust values for accuracy and log transform
#amoAClean_CO2CH4_tbl_long$counts = (amoAClean_CO2CH4_tbl_long$counts/1000)#+1
#CO2CH4_tbl_long$counts = CO2CH4_tbl_long$counts + 1

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)

#BugHunt.df = amoAClean_CO2CH4_tbl_long[c(1:200000),]


uniquegenes.ls = unique(amoAClean_CO2CH4_tbl_long$SName)
uniquegenes.ls


#Make results table
Results.df = data.frame(Gene = "DELETEME",
                        Sample_type.eta2 = 9999,
                        Sample_type.p = 9999,
                        Station.eta2 = 9999,
                        Station.p = 9999,
                        Sample_date.eta2 = 9999,
                        Sample_date.p = 9999,
                        "Sample_type:Station.eta2" = 9999,
                        "Sample_type:Station.p" = 9999,
                        "Sample_type:Sample_date.eta2" = 9999,
                        "Sample_type:Sample_date.p" = 9999,
                        "Station:Sample_date.eta2" = 9999,
                        "Station:Sample_date.p" = 9999,
                        "Sample_type:Station:Sample_date.eta2" = 9999,
                        "Sample_type:Station:Sample_date.p" = 9999,
                        "TukeyGroupsFraction<0.05" = paste(tmp_G.ptuk, collapse = ','),
                        data_type = "DELETEME")

i="ME2, sfcA, maeA"
#Get significant differences over space
for (i in uniquegenes.ls) {
  print(paste0("Working on ", i))
  
  tmp_G.sbst = subset(amoAClean_CO2CH4_tbl_long, SName == i & data_type == "Metagenomes")
  #tmp_G.sbst
  
  tmp_T.sbst = subset(amoAClean_CO2CH4_tbl_long, SName == i & data_type =="Transcriptomes")
  #tmp_T.sbst
  
  tmp_G.aov = aov(counts ~ Sample_type * Station * Sample_date, data = tmp_G.sbst)
  tmp_T.aov = aov(counts ~ Sample_type * Station * Sample_date, data = tmp_T.sbst)
  
  #summary(tmp_G.aov)
  #summary(tmp_T.aov)
  
  tmp_G.eta2 = lsr::etaSquared(tmp_G.aov)
  tmp_T.eta2 = lsr::etaSquared(tmp_T.aov)
  
  tmp_G.tuk = TukeyHSD(tmp_G.aov)
  tmp_T.tuk = TukeyHSD(tmp_T.aov)
  
  colnames(tmp_G.tuk$Sample_type) = gsub(" ", "_", colnames(tmp_G.tuk$Sample_type))
  tmp_G.ptuk = tmp_G.tuk$Sample_type %>%
    as.data.frame() %>%
    filter(p_adj < 0.05) %>%
    rownames()
  colnames(tmp_T.tuk$Sample_type) = gsub(" ", "_", colnames(tmp_T.tuk$Sample_type))
  tmp_T.ptuk = tmp_T.tuk$Sample_type %>%
    as.data.frame() %>%
    filter(p_adj < 0.05) %>%
    rownames()
  
  #tmp_G.ptuk
  #tmp_T.ptuk
  
  
  tmp_G.res = data.frame(Gene = paste0(i),
                         Sample_type.eta2 = tmp_G.eta2[1,1],
                         Sample_type.p = summary(tmp_G.aov)[[1]][["Pr(>F)"]][1],
                         Station.eta2 = tmp_G.eta2[2,1],
                         Station.p = summary(tmp_G.aov)[[1]][["Pr(>F)"]][2],
                         Sample_date.eta2 = tmp_G.eta2[3,1],
                         Sample_date.p = summary(tmp_G.aov)[[1]][["Pr(>F)"]][3],
                         "Sample_type:Station.eta2" = tmp_G.eta2[4,1],
                         "Sample_type:Station.p" = summary(tmp_G.aov)[[1]][["Pr(>F)"]][4],
                         "Sample_type:Sample_date.eta2" = tmp_G.eta2[5,1],
                         "Sample_type:Sample_date.p" = summary(tmp_G.aov)[[1]][["Pr(>F)"]][5],
                         "Station:Sample_date.eta2" = tmp_G.eta2[6,1],
                         "Station:Sample_date.p" = summary(tmp_G.aov)[[1]][["Pr(>F)"]][6],
                         "Sample_type:Station:Sample_date.eta2" = tmp_G.eta2[7,1],
                         "Sample_type:Station:Sample_date.p" = summary(tmp_G.aov)[[1]][["Pr(>F)"]][7],
                         "TukeyGroupsFraction<0.05" = paste(tmp_G.ptuk, collapse = ','),
                         data_type = "Metagenomes")
  tmp_T.res = data.frame(Gene = paste0(i),
                         Sample_type.eta2 = tmp_T.eta2[1,1],
                         Sample_type.p = summary(tmp_T.aov)[[1]][["Pr(>F)"]][1],
                         Station.eta2 = tmp_T.eta2[2,1],
                         Station.p = summary(tmp_T.aov)[[1]][["Pr(>F)"]][2],
                         Sample_date.eta2 = tmp_T.eta2[3,1],
                         Sample_date.p = summary(tmp_T.aov)[[1]][["Pr(>F)"]][3],
                         "Sample_type:Station.eta2" = tmp_T.eta2[4,1],
                         "Sample_type:Station.p" = summary(tmp_T.aov)[[1]][["Pr(>F)"]][4],
                         "Sample_type:Sample_date.eta2" = tmp_T.eta2[5,1],
                         "Sample_type:Sample_date.p" = summary(tmp_T.aov)[[1]][["Pr(>F)"]][5],
                         "Station:Sample_date.eta2" = tmp_T.eta2[6,1],
                         "Station:Sample_date.p" = summary(tmp_T.aov)[[1]][["Pr(>F)"]][6],
                         "Sample_type:Station:Sample_date.eta2" = tmp_T.eta2[7,1],
                         "Sample_type:Station:Sample_date.p" = summary(tmp_T.aov)[[1]][["Pr(>F)"]][7],
                         "TukeyGroupsFraction<0.05" = paste(tmp_T.ptuk, collapse = ','),
                         data_type = "Transcriptomes")
  
  
  Results.df = rbind(Results.df, tmp_G.res, tmp_T.res)
}
Results.df = Results.df[-1,]
Results.df


Results.df$TukeyGroupsFraction.0.05 = gsub("_fraction", "", Results.df$TukeyGroupsFraction.0.05)
Results.df$TukeyGroupsFraction.0.05 = gsub("_living", "", Results.df$TukeyGroupsFraction.0.05)


Results_Fraction.df = subset(Results.df, Sample_type.p < 0.05)
Results_Station.df = subset(Results.df, Station.p < 0.05)
Results_Date.df = subset(Results.df, Sample_date.p < 0.05)


####Combine and export####
#Results.df = rbind(Results_Utilising.df, Results_Producing.df, Results_Both.df, Results_Unknown.df)

write.csv(Results_Fraction.df, "GeneSignificant_Fraction.csv")
write.csv(Results_Station.df, "GeneSignificant_Station.csv")
write.csv(Results_Date.df, "GeneSignificant_Date.csv")

```

##Significant changes associated with salinity

```{r}

####Create dataframe####
#Import gene list
CarbonGenelist.df = read.csv("CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

#Correct abundance
amoAClean_geneabund_KO[c(2:264)] = amoAClean_geneabund_KO[c(2:264)] / 1000


amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2)

View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")

####Run test####

amoAClean_CO2CH4_tbl_long = read.csv( "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")
#Remove all but the relevant object to run anova models
#library(gdata)
#keep(amoAClean_CO2CH4_tbl_long)
#keep(amoAClean_CO2CH4_tbl_long, sure = TRUE, all = TRUE)

#CO2CH4_tbl_long %>% separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName"))

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("Mai 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "Mai 22",
                                              "Jun 22",
                                              "Nov 22"))

#Adjust values for accuracy and log transform
#amoAClean_CO2CH4_tbl_long$counts = (amoAClean_CO2CH4_tbl_long$counts/1000)#+1
#CO2CH4_tbl_long$counts = CO2CH4_tbl_long$counts + 1

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)

#BugHunt.df = amoAClean_CO2CH4_tbl_long[c(1:200000),]

Complete_Metadata.df = read.csv("SAMEAID_SampleID.csv", sep = ";", header = T)[,c(1,10:15)]

amoAClean_CO2CH4_tbl_long = amoAClean_CO2CH4_tbl_long %>%
  select(-X) %>%
  left_join(Complete_Metadata.df, by = c("BioSample" = "AccessionNumber_TBDSven")) %>%
  mutate_at(c('counts'), as.numeric) %>%
  distinct()
dim(amoAClean_CO2CH4_tbl_long)
amoAClean_CO2CH4_tbl_long$Salinity_TBDHereon = as.numeric(gsub(",", ".", gsub("\\.", "", amoAClean_CO2CH4_tbl_long$Salinity_TBDHereon)))


uniquegenes.ls = unique(amoAClean_CO2CH4_tbl_long$SName)
uniquegenes.ls


#Make results table
Results_Sal.df = data.frame(Gene = "DELETEME",
                        Salinity.rho = 9999,
                        Salinity.p = 9999,
                        data_type = "DELETEME")

i="ME2, sfcA, maeA"
#Get significant differences over space
for (i in uniquegenes.ls) {
  print(paste0("Working on ", i))
  
  tmp_G.sbst = subset(amoAClean_CO2CH4_tbl_long, SName == i & data_type == "Metagenomes")
  tmp_G.sbst
  
  tmp_T.sbst = subset(amoAClean_CO2CH4_tbl_long, SName == i & data_type =="Transcriptomes")
  tmp_T.sbst
  
  tryCatch({
    tmp_G.spear = cor.test(tmp_G.sbst$counts, tmp_G.sbst$Salinity_TBDHereon, method = "s")
    tmp_T.spear = cor.test(tmp_T.sbst$counts, tmp_T.sbst$Salinity_TBDHereon, method = "s")
    tmp_G.res = data.frame(Gene = paste0(i),
                         Salinity.rho = tmp_G.spear$estimate,
                         Salinity.p = tmp_G.spear$p.value,
                         data_type = "Metagenomes")
    tmp_T.res = data.frame(Gene = paste0(i),
                         Salinity.rho = tmp_T.spear$estimate,
                         Salinity.p = tmp_T.spear$p.value,
                         data_type = "Transcriptomes")
  
  
   Results_Sal.df = rbind(Results_Sal.df, tmp_G.res, tmp_T.res)}, 
    
   error=function(e){cat("ERROR :", conditionMessage(e), "\n")})
  
  
  
  
}
Results_Sal.df = Results_Sal.df[-1,]
Results_Sal.df
dim(Results_Sal.df)

Results_Sal.df = subset(Results_Sal.df, Salinity.p < 0.05)
dim(Results_Sal.df)

####Combine and export####
#Results.df = rbind(Results_Utilising.df, Results_Producing.df, Results_Both.df, Results_Unknown.df)

Results_Sal.df$TukeyGroupsFraction.0.05 = gsub("_fraction", "", Results_Sal.df$TukeyGroupsFraction.0.05)
Results_Sal.df$TukeyGroupsFraction.0.05 = gsub("_living", "", Results_Sal.df$TukeyGroupsFraction.0.05)

write.csv(Results_Sal.df, "GeneSignificant_Salinity.csv")


```
##Plots
###Fractions
```{r}

#Read in dataframe
SignGenes_Fraction.df = read.csv("GeneSignificant_Fraction.csv", header = T, sep = ";")

SignGenes_Fraction.df = subset(SignGenes_Fraction.df, Sample_type.eta2 > 0.3)
dim(SignGenes_Fraction.df)
# Plot preferences
amoAClean_CO2CH4Profiles.plt = ggplot(SignGenes_Fraction.df) + 
  geom_tile(aes(x=data_type, y=fct_reorder(.f = Gene, .x = Sample_type.eta2, .fun = mean, .na_rm = T, .desc = F), fill=Sample_type.eta2)) +
  #facet_wrap(Direction ~ data_type * Sample_date, ncol = 9)+
  scale_fill_gradient2(expression(paste("eta"^{2})), low= "magenta", mid = "white", high = "black", na.value = "red")+
  ggtitle("CO2/CH4")+
  ylab("Significantly changing \nCO2/CH4 Genes")+
  xlab("Sequencing type")+
  My_Theme+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
# visualise
amoAClean_CO2CH4Profiles.plt 

#Save plots
#pdf("Figures/CO2CH4_Unknown Reversibility.pdf", width = 12, height = 12)
#CO2CH4Profiles.plt
#dev.off()

png("Figures/CO2CH4_Signfraction0.3.png", width = 10, height = 12, units = "in", res = 120)
amoAClean_CO2CH4Profiles.plt
dev.off()




```

###Salinity

```{r}

#Read in dataframe
SignGenes_Salinity.df = read.csv("GeneSignificant_Salinity.csv", header = T, sep = ";")

SignGenes_Salinity.df = subset(SignGenes_Salinity.df, Sample_type.eta2 > 0.3)
dim(SignGenes_Salinity.df)
# Plot preferences
amoAClean_CO2CH4Profiles.plt = ggplot(SignGenes_Salinity.df) + 
  geom_tile(aes(x=data_type, y=fct_reorder(.f = Gene, .x = Sample_type.eta2, .fun = mean, .na_rm = T, .desc = F), fill=Sample_type.eta2)) +
  #facet_wrap(Direction ~ data_type * Sample_date, ncol = 9)+
  scale_fill_gradient2(expression(paste("eta"^{2})), low= "magenta", mid = "white", high = "black", na.value = "red")+
  ggtitle("CO2/CH4")+
  ylab("Significantly changing \nCO2/CH4 Genes")+
  xlab("Sequencing type")+
  My_Theme+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
# visualise
amoAClean_CO2CH4Profiles.plt 

#Save plots
#pdf("Figures/CO2CH4_Unknown Reversibility.pdf", width = 12, height = 12)
#CO2CH4Profiles.plt
#dev.off()

png("Figures/CO2CH4_SignSalinity0.3.png", width = 30, height = 45, units = "in", res = 120)
amoAClean_CO2CH4Profiles.plt
dev.off()




```




#Comparisons - mantel

##Distances for metatranscriptomes
```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(stringr::str_detect(genus,"Nitros") & stringr::str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  dplyr::select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long_MT <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  dplyr::select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Associatednumber > 115) %>% # remove samples that have no metagenome samples
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long_MT$counts = amoAClean_CO2CH4_tbl_long_MT$counts / 1000


#View(amoAClean_CO2CH4_tbl_long_MT)
dim(amoAClean_CO2CH4_tbl_long_MT)

#write.csv(amoAClean_CO2CH4_tbl_long_MT, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_V3_TG.csv")

#amoAClean_CO2CH4_tbl_long_MT = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_V3_TG.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long_MT$Station = factor(amoAClean_CO2CH4_tbl_long_MT$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long_MT$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long_MT$Sample_date)

amoAClean_CO2CH4_tbl_long_MT$Sample_date = factor(amoAClean_CO2CH4_tbl_long_MT$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_MT$data_type)
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_MT$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long_MT[ , ! names(amoAClean_CO2CH4_tbl_long_MT) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_MT)
dim(CO2CH4_TG.df)


#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG.df = CO2CH4_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "IncompleteMetagenome")) #Replace Infin with #/0, as Metagenome likely incomplete

####Calculate distances between samples####

MT_matrix_mantel <- CO2CH4_TG.df %>%
  filter(KO!="K10945" & KO!="K10946") %>%
  filter(TranscriptsPerGenome!="IncompleteMetagenome") %>% # Remove genes that had transcripts but not metagenome counts
  dplyr::select(Associatednumber, KO, TranscriptsPerGenome) %>% # select only relevant columns
  mutate(TranscriptsPerGenome = as.numeric(TranscriptsPerGenome)) %>% # convert the column to numeric
  pivot_wider(names_from = KO, values_from = TranscriptsPerGenome, values_fn = mean) %>% # long to wide
  magrittr::set_rownames(NULL) %>% #remove row names
  tibble::column_to_rownames('Associatednumber') %>% #change row name to sample number
  mutate_if(is.numeric, ~replace(., is.na(.), 0)) # replace NAs with 0
  

MT_matrix_mantel.dist = dist(MT_matrix_mantel) # Run distance calculation


#View(as.data.frame(as.matrix(MT_matrix_mantel.dist)))
dim(as.matrix(MT_matrix_mantel.dist))


```
##Distances for metagenomes
```{r}

####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  dplyr::select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long_MG <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  dplyr::select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  distinct()
amoAClean_CO2CH4_tbl_long_MG$counts = amoAClean_CO2CH4_tbl_long_MG$counts / 1000

#View(amoAClean_CO2CH4_tbl_long_MG)
dim(amoAClean_CO2CH4_tbl_long_MG)

#Reorder factors
amoAClean_CO2CH4_tbl_long_MG$Station = factor(amoAClean_CO2CH4_tbl_long_MG$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long_MG$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long_MG$Sample_date)

amoAClean_CO2CH4_tbl_long_MG$Sample_date = factor(amoAClean_CO2CH4_tbl_long_MG$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_MG$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_MG$data_type)

dim(amoAClean_CO2CH4_tbl_long_MG)



####Calculate distances between samples####


MG_matrix_mantel <- amoAClean_CO2CH4_tbl_long_MG %>%
  filter(KO!="K10945" & KO!="K10946") %>%
  dplyr::select(Associatednumber, KO, counts) %>%
  pivot_wider(names_from = KO, values_from = counts, values_fn = mean) %>%
  magrittr::set_rownames(NULL) %>%
  tibble::column_to_rownames('Associatednumber')


MG_matrix_mantel.dist = dist(MG_matrix_mantel)


#View(as.data.frame(as.matrix(MG_matrix_mantel.dist)))
dim(as.matrix(MG_matrix_mantel.dist))

  
```
##Distances for mOTUs
```{r }

motus_final_taxa_metadata <- readRDS(file="F:/Functional_R_analysis/motus_final_taxa_metadata.RDS")

##Lets check out experimental scheme

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date))


Stupidworkaround.df = read.csv("F:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", sep = ";")
dim(motus_final_taxa_metadata)

i=1
x=1
for (i in 1:length(Stupidworkaround.df$BioSample)) {
  for (x in 1:length(motus_final_taxa_metadata$BioSample)) {
  if(grepl(Stupidworkaround.df$BioSample[i], motus_final_taxa_metadata$BioSample[x]) == T) {
    
    motus_final_taxa_metadata$Associatednumber[x] = Stupidworkaround.df$Associatednumber[i]
    
    print(paste0("Matching ", motus_final_taxa_metadata$BioSample[x], " with ", Stupidworkaround.df$BioSample[i]))
    
  }
  }
}


##First we want to covert our data back to an OTU table 
motus_MG_df <- motus_final_taxa_metadata %>%
  filter(data_type == "METAG") %>%
  dplyr::select(mOTU, Associatednumber, counts) %>%
  transform(counts = as.numeric(counts)) %>%
  pivot_wider(names_from="mOTU", values_from="counts", values_fill = 0) %>% 
  column_to_rownames("Associatednumber") %>%
  as.data.frame()

motus_MT_df <- motus_final_taxa_metadata %>%
  filter(data_type == "METAT") %>%
  dplyr::select(mOTU, Associatednumber, counts) %>%
  transform(counts = as.numeric(counts)) %>%
  pivot_wider(names_from="mOTU", values_from="counts", values_fill = 0) %>% 
  column_to_rownames("Associatednumber") %>%
  as.data.frame()

motus_MG_matrix_mantel.dist <- dist(motus_MG_df)
motus_MT_matrix_mantel.dist <- dist(motus_MT_df)

```


##Set up physicochemical characteristics
```{r}

#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("F:/Functional_R_analysis/PhysicochemicalParameters_mod2.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Make relevant columns numeric
#Physicochem.df = Physicochem.df %>% mutate_at(c('SPM_mgperL', 'POC_mgperL'), as.numeric)
Physicochem.df$SPM_mgperL = as.numeric(Physicochem.df$SPM_mgperL)
Physicochem.df$POC_mgperL = as.numeric(Physicochem.df$POC_mgperL)
Physicochem.df$PTC_mgperL = as.numeric(Physicochem.df$PTC_mgperL)
Physicochem.df$PTN_mgperL = as.numeric(Physicochem.df$PTN_mgperL)
Physicochem.df$PTH_mgperL = as.numeric(Physicochem.df$PTH_mgperL)
Physicochem.df$TEP_um2perL = as.numeric(Physicochem.df$TEP_um2perL)
Physicochem.df$CSP_um2perL = as.numeric(Physicochem.df$CSP_um2perL)
Physicochem.df$ParticleArea_um2perL = as.numeric(Physicochem.df$ParticleArea_um2perL)


#Add PA PP to Free-living rows 

#Extract sample numbers for FL - MG
FL_samples.df = Physicochem.df %>%
  filter(Sample_type == "Free_living")
PA_PP.ls = c("SPM_mgperL", "POC_mgperL", "PTC_mgperL", "PTN_mgperL", "PTH_mgperL", "TEP_um2perL", "CSP_um2perL", "ParticleArea_um2perL")
count = 1
i=92
x="TEP_um2perL"
for (i in 1:length(Physicochem.df$Associatednumber)) {
  if (grepl(Physicochem.df$Sample_type[i], "Free_living") == T ) {
    #Bug hunting
    #print(paste0("Match ",count, " found"))
    PA_sub.df = subset(Physicochem.df, Sample_type!="Free_living" & 
                         station_km == Physicochem.df$station_km[i] & 
                         Sample_date == Physicochem.df$Sample_date[i])
    for (x in PA_PP.ls) {
      
      print(x)
      #Bug hunting
      #print(paste0("Matching ", x))
      mean.tmp = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
      #Bug hunt
      print(paste0("Getting ", mean.tmp))
      Physicochem.df[i,x] = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
    }
    count = count + 1
  }
}

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DOC_uM.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

colnames(PP_totest.df)
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% 
  dplyr::select(all_of(PP_totest.ls))

#Make sure rownames have been preserved
rownames(PP_totest.df)
dim(PP_totest.df)


#Apply row numbers from sample IDs
rownames(PP_totest.df) = PP_totest.df$Associatednumber
PP_totest.df$Associatednumber = NULL


#Add density data - calculated from dry-weight and area
PP_totest.df$Density_gpercm3 = (as.numeric(PP_totest.df$SPM_mgperL) / (as.numeric(PP_totest.df$ParticleArea_um2perL))) * 10^5

#Flip so columns are samples for dissimilarity assessment
PP_totest.df = t(PP_totest.df)

#Get sample names for microbiome comparison
PP_totest.ls = rownames(PP_totest.df)



```
##Calculate dissimilarity with mantel tests
###Whole community - Attic
```{r}

####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_matrix_mantel.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_matrix_mantel.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>% # read in data as a data frame
  select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
mantel(MG_matrix_mantel_sub.dist, MT_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.1273
#      Significance: 0.048
#Significantly similar






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_matrix_mantel.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_matrix_mantel.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>% # read in data as a data frame
  select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
mantel(MG_matrix_mantel_sub.dist, motus_MG_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.3968
#      Significance: 0.001
#This means that they are very similar






####MT - motus ####



#Extract sample numbers
MT_samples = data.frame(MT_samples = sort(as.numeric(colnames(as.matrix(MT_matrix_mantel.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MT_matrix_mantel.dist)))))


#Compare and put into dataframe
MT_samples$motu_match = match(MT_samples$MT_sample, motus_samples$motus_samples)
motus_samples$MT_match = match(motus_samples$motus_samples, MT_samples$MT_samples)


#Extract only matching samples
MT_motu_matches = subset(MT_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>% # read in data as a data frame
  select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
mantel(MT_matrix_mantel_sub.dist, motus_MT_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.1753
#      Significance: 0.073
#This means that they are very similar



####MG vs Individual PP ####
#Run loop for motus vs individual physicochemical parameters
Results_MG.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)
i=1
x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_matrix_mantel.dist)))))


    #Compare and put into dataframe
    PP_samples$MG_match = match(PP_samples$PP_sample, MG_samples$MG_sample)
    MG_samples$PP_match = match(MG_samples$MG_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_matches = subset(PP_samples, MG_match!="NA")


    #Subset distance matrices by matching samples
    MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>% # read in data as a data frame
      select(paste0(PP_MG_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      select(paste0(PP_MG_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG.df = rbind(Results_MG.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }


#Check results and clean up dataframe
Results_MG.df = Results_MG.df[-1,]
Results_MG.df

#Check if each PP was included
unique(Results_MG.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_sign.df = subset(Results_MG.df, pvalue < 0.05)
dim(Results_MG_sign.df)
Results_MG_sign.df



####motu_MG vs Individual PP ####

#Run loop for motus vs individual physicochemical parameters
Results_motus_MG.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)
i=1
x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_samples = data.frame(motus_MG_sample = sort(as.numeric(colnames(as.matrix(motus_MG_matrix_mantel.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MG_match = match(PP_samples$PP_sample, motus_MG_samples$motus_MG_sample)
    motus_MG_samples$PP_match = match(motus_MG_samples$motus_MG_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_matches = subset(PP_samples, motus_MG_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>% # read in data as a data frame
      select(paste0(PP_motus_MG_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      select(paste0(PP_motus_MG_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG.df = rbind(Results_motus_MG.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  


#Check results and clean up dataframe
Results_motus_MG.df = Results_motus_MG.df[-1,]
Results_motus_MG.df

#Check if each PP was included
unique(Results_motus_MG.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_sign.df = subset(Results_motus_MG.df, pvalue < 0.05)
dim(Results_motus_MG.df)
Results_motus_MG_sign.df



####MT vs Individual PP ####
#Run loop for MTs vs individual physicochemical parameters
Results_MT.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)
i=1
x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_matrix_mantel.dist)))))


    #Compare and put into dataframe
    PP_samples$MT_match = match(PP_samples$PP_sample, MT_samples$MT_sample)
    MT_samples$PP_match = match(MT_samples$MT_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_matches = subset(PP_samples, MT_match!="NA")


    #Subset distance matrices by matching samples
    MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>% # read in data as a data frame
      select(paste0(PP_MT_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      select(paste0(PP_MT_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT.df = rbind(Results_MT.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT.df = Results_MT.df[-1,]
Results_MT.df

#Check if each PP was included
unique(Results_MT.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_sign.df = subset(Results_MT.df, pvalue < 0.05)
dim(Results_MT_sign.df)
Results_MT_sign.df




####motu_MT vs Individual PP ####

#Run loop for motus vs individual physicochemical parameters
Results_motus_MT.df = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)
i=1
x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MT_samples = data.frame(motus_MT_sample = sort(as.numeric(colnames(as.matrix(motus_MT_matrix_mantel.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MT_match = match(PP_samples$PP_sample, motus_MT_samples$motus_MT_sample)
    motus_MT_samples$PP_match = match(motus_MT_samples$motus_MT_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MT_matches = subset(PP_samples, motus_MT_match!="NA")


    #Subset distance matrices by matching samples
    motus_MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>% # read in data as a data frame
      select(paste0(PP_motus_MT_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      select(paste0(PP_motus_MT_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MT_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MT.df = rbind(Results_motus_MT.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  


#Check results and clean up dataframe
Results_motus_MT.df = Results_motus_MT.df[-1,]
Results_motus_MT.df

#Check if each PP was included
unique(Results_motus_MT.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MT_sign.df = subset(Results_motus_MT.df, pvalue < 0.05)
dim(Results_motus_MT_sign.df)
Results_motus_MT_sign.df


```

###Free_living
```{r}

####Subset to only Free_living ####

#Extract sample numbers for FL - MG
FL_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MG_matrix_mantel.dist))))
#Extract only FL samples
MG_FL.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(FL_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% FL_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for FL - mOTUs MG
FL_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MG_matrix_mantel.dist))))
#Extract only FL samples
motus_MG_FL.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(FL_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% FL_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid


#Extract sample numbers for FL - MT
FL_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MT_matrix_mantel.dist))))
#Extract only FL samples
MT_FL.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(FL_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% FL_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for FL - mOTUs MT
FL_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MT_matrix_mantel.dist))))
#Extract only FL samples
motus_MT_FL.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(FL_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% FL_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid






####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_FL.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_FL.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_FL_sub.dist = as.data.frame(as.matrix(MG_FL.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_FL_sub.dist = as.data.frame(as.matrix(MT_FL.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_FL_sub.dist, MT_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.004013
#      Significance: 0.35






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_FL.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_FL.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_FL_sub.dist = as.data.frame(as.matrix(MG_FL.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_FL_sub.dist = as.data.frame(as.matrix(motus_MG_FL.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_FL_sub.dist, motus_MG_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.3726 
#      Significance: 0.001 






####MT - motus ####



#Extract sample numbers
MT_samples = data.frame(MT_samples = sort(as.numeric(colnames(as.matrix(MT_FL.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MT_FL.dist)))))


#Compare and put into dataframe
MT_samples$motu_match = match(MT_samples$MT_sample, motus_samples$motus_samples)
motus_samples$MT_match = match(motus_samples$motus_samples, MT_samples$MT_samples)


#Extract only matching samples
MT_motu_matches = subset(MT_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MT_FL_sub.dist = as.data.frame(as.matrix(MT_FL.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MT_FL_sub.dist = as.data.frame(as.matrix(motus_MT_FL.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MT_FL_sub.dist, motus_MT_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.1062
#      Significance: 0.217





####MG vs Individual PP ####
#Run loop for MG_FLs vs individual physicochemical parameters
Results_MG_FL.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   dplyr::mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_FL_samples = data.frame(MG_FL_sample = sort(as.numeric(colnames(as.matrix(MG_FL.dist)))))


    #Compare and put into dataframe
    PP_samples$MG_FL_match = match(PP_samples$PP_sample, MG_FL_samples$MG_FL_sample)
    MG_FL_samples$PP_match = match(MG_FL_samples$MG_FL_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_FL_matches = subset(PP_samples, MG_FL_match!="NA")


    #Subset distance matrices by matching samples
    MG_FL_sub.dist = as.data.frame(as.matrix(MG_FL.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MG_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MG_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_FL.df = rbind(Results_MG_FL.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MG_FL.df = Results_MG_FL.df[-1,]
Results_MG_FL.df

#Check if each PP was included
unique(Results_MG_FL.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_FL_sign.df = subset(Results_MG_FL.df, pvalue < 0.05)
dim(Results_MG_FL_sign.df)
Results_MG_FL_sign.df





####motus_MG vs Individual PP ####
#Run loop for motus_MG_FLs vs individual physicochemical parameters
Results_motus_MG_FL.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_FL_samples = data.frame(motus_MG_FL_sample = sort(as.numeric(colnames(as.matrix(motus_MG_FL.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MG_FL_match = match(PP_samples$PP_sample, motus_MG_FL_samples$motus_MG_FL_sample)
    motus_MG_FL_samples$PP_match = match(motus_MG_FL_samples$motus_MG_FL_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_FL_matches = subset(PP_samples, motus_MG_FL_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_FL_sub.dist = as.data.frame(as.matrix(motus_MG_FL.dist)) %>% # read in data as a data frame
     dplyr::select(paste0(PP_motus_MG_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG_FL.df = rbind(Results_motus_MG_FL.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MG_FL.df = Results_motus_MG_FL.df[-1,]
Results_motus_MG_FL.df

#Check if each PP was included
unique(Results_motus_MG_FL.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_FL_sign.df = subset(Results_motus_MG_FL.df, pvalue < 0.05)
dim(Results_motus_MG_FL_sign.df)
Results_motus_MG_FL_sign.df





####MT vs Individual PP ####
#Run loop for MT_FLs vs individual physicochemical parameters
Results_MT_FL.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_FL_samples = data.frame(MT_FL_sample = sort(as.numeric(colnames(as.matrix(MT_FL.dist)))))


    #Compare and put into dataframe
    PP_samples$MT_FL_match = match(PP_samples$PP_sample, MT_FL_samples$MT_FL_sample)
    MT_FL_samples$PP_match = match(MT_FL_samples$MT_FL_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_FL_matches = subset(PP_samples, MT_FL_match!="NA")


    #Subset distance matrices by matching samples
    MT_FL_sub.dist = as.data.frame(as.matrix(MT_FL.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MT_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MT_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_FL.df = rbind(Results_MT_FL.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT_FL.df = Results_MT_FL.df[-1,]
Results_MT_FL.df

#Check if each PP was included
unique(Results_MT_FL.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_FL_sign.df = subset(Results_MT_FL.df, pvalue < 0.05)
dim(Results_MT_FL_sign.df)
Results_MT_FL_sign.df





####motus_MT vs Individual PP ####
#Run loop for motus_MT_FLs vs individual physicochemical parameters
Results_motus_MT_FL.df = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MT_FL_samples = data.frame(motus_MT_FL_sample = sort(as.numeric(colnames(as.matrix(motus_MT_FL.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MT_FL_match = match(PP_samples$PP_sample, motus_MT_FL_samples$motus_MT_FL_sample)
    motus_MT_FL_samples$PP_match = match(motus_MT_FL_samples$motus_MT_FL_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MT_FL_matches = subset(PP_samples, motus_MT_FL_match!="NA")


    #Subset distance matrices by matching samples
    motus_MT_FL_sub.dist = as.data.frame(as.matrix(motus_MT_FL.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MT_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MT_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MT_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MT_FL.df = rbind(Results_motus_MT_FL.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MT_FL.df = Results_motus_MT_FL.df[-1,]
Results_motus_MT_FL.df

#Check if each PP was included
unique(Results_motus_MT_FL.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MT_FL_sign.df = subset(Results_motus_MT_FL.df, pvalue < 0.05)
dim(Results_motus_MT_FL_sign.df)
Results_motus_MT_FL_sign.df





```

###Particle associated
```{r}

####Remove Free_living ####

#Extract sample numbers for PA - MG
PA_samples.ls = Physicochem.df %>%
  filter(Sample_type!= "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MG_matrix_mantel.dist))))
#Extract only PA samples
MG_PA.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(PA_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% PA_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for PA - mOTUs MG
PA_samples.ls = Physicochem.df %>%
  filter(Sample_type!= "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MG_matrix_mantel.dist))))
#Extract only PA samples
motus_MG_PA.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(PA_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% PA_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid


#Extract sample numbers for PA - MT
PA_samples.ls = Physicochem.df %>%
  filter(Sample_type!= "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MT_matrix_mantel.dist))))
#Extract only PA samples
MT_PA.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(PA_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% PA_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for PA - mOTUs MT
PA_samples.ls = Physicochem.df %>%
  filter(Sample_type!= "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MT_matrix_mantel.dist))))
#Extract only PA samples
motus_MT_PA.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(PA_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% PA_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid






####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_PA.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_PA.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_PA_sub.dist = as.data.frame(as.matrix(MG_PA.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_PA_sub.dist = as.data.frame(as.matrix(MT_PA.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_PA_sub.dist, MT_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.1222
#      Significance: 0.055






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_PA.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_PA.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_PA_sub.dist = as.data.frame(as.matrix(MG_PA.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_PA_sub.dist = as.data.frame(as.matrix(motus_MG_PA.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_PA_sub.dist, motus_MG_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.4817
#      Significance: 0.001






####MT - motus ####



#Extract sample numbers
MT_samples = data.frame(MT_samples = sort(as.numeric(colnames(as.matrix(MT_PA.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MT_PA.dist)))))


#Compare and put into dataframe
MT_samples$motu_match = match(MT_samples$MT_sample, motus_samples$motus_samples)
motus_samples$MT_match = match(motus_samples$motus_samples, MT_samples$MT_samples)


#Extract only matching samples
MT_motu_matches = subset(MT_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MT_PA_sub.dist = as.data.frame(as.matrix(MT_PA.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MT_PA_sub.dist = as.data.frame(as.matrix(motus_MT_PA.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MT_PA_sub.dist, motus_MT_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.3594
#      Significance: 0.006




####MG vs Individual PP ####
#Run loop for MG_PAs vs individual physicochemical parameters
Results_MG_PA.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=24
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_PA_samples = data.frame(MG_PA_sample = sort(as.numeric(colnames(as.matrix(MG_PA.dist)))))


    #Compare and put into dataframe
    PP_samples$MG_PA_match = match(PP_samples$PP_sample, MG_PA_samples$MG_PA_sample)
    MG_PA_samples$PP_match = match(MG_PA_samples$MG_PA_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_PA_matches = subset(PP_samples, MG_PA_match!="NA")


    #Subset distance matrices by matching samples
    MG_PA_sub.dist = as.data.frame(as.matrix(MG_PA.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MG_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MG_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    #dim(MG_PA_sub.dist)
    #dim(PP_sub.tmp)
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_PA.df = rbind(Results_MG_PA.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MG_PA.df = Results_MG_PA.df[-1,]
Results_MG_PA.df

#Check if each PP was included
unique(Results_MG_PA.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_PA_sign.df = subset(Results_MG_PA.df, pvalue < 0.05)
dim(Results_MG_PA_sign.df)
Results_MG_PA_sign.df





####motus_MG vs Individual PP ####
#Run loop for motus_MG_PAs vs individual physicochemical parameters
Results_motus_MG_PA.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_PA_samples = data.frame(motus_MG_PA_sample = sort(as.numeric(colnames(as.matrix(motus_MG_PA.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MG_PA_match = match(PP_samples$PP_sample, motus_MG_PA_samples$motus_MG_PA_sample)
    motus_MG_PA_samples$PP_match = match(motus_MG_PA_samples$motus_MG_PA_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_PA_matches = subset(PP_samples, motus_MG_PA_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_PA_sub.dist = as.data.frame(as.matrix(motus_MG_PA.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG_PA.df = rbind(Results_motus_MG_PA.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MG_PA.df = Results_motus_MG_PA.df[-1,]
Results_motus_MG_PA.df

#Check if each PP was included
unique(Results_motus_MG_PA.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_PA_sign.df = subset(Results_motus_MG_PA.df, pvalue < 0.05)
dim(Results_motus_MG_PA_sign.df)
Results_motus_MG_PA_sign.df





####MT vs Individual PP ####
#Run loop for MT_PAs vs individual physicochemical parameters
Results_MT_PA.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_PA_samples = data.frame(MT_PA_sample = sort(as.numeric(colnames(as.matrix(MT_PA.dist)))))


    #Compare and put into dataframe
    PP_samples$MT_PA_match = match(PP_samples$PP_sample, MT_PA_samples$MT_PA_sample)
    MT_PA_samples$PP_match = match(MT_PA_samples$MT_PA_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_PA_matches = subset(PP_samples, MT_PA_match!="NA")


    #Subset distance matrices by matching samples
    MT_PA_sub.dist = as.data.frame(as.matrix(MT_PA.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MT_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MT_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_PA.df = rbind(Results_MT_PA.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT_PA.df = Results_MT_PA.df[-1,]
Results_MT_PA.df

#Check if each PP was included
unique(Results_MT_PA.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_PA_sign.df = subset(Results_MT_PA.df, pvalue < 0.05)
dim(Results_MT_PA_sign.df)
Results_MT_PA_sign.df





####motus_MT vs Individual PP ####
#Run loop for motus_MT_PAs vs individual physicochemical parameters
Results_motus_MT_PA.df = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MT_PA_samples = data.frame(motus_MT_PA_sample = sort(as.numeric(colnames(as.matrix(motus_MT_PA.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MT_PA_match = match(PP_samples$PP_sample, motus_MT_PA_samples$motus_MT_PA_sample)
    motus_MT_PA_samples$PP_match = match(motus_MT_PA_samples$motus_MT_PA_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MT_PA_matches = subset(PP_samples, motus_MT_PA_match!="NA")


    #Subset distance matrices by matching samples
    motus_MT_PA_sub.dist = as.data.frame(as.matrix(motus_MT_PA.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MT_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MT_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MT_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MT_PA.df = rbind(Results_motus_MT_PA.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MT_PA.df = Results_motus_MT_PA.df[-1,]
Results_motus_MT_PA.df

#Check if each PP was included
unique(Results_motus_MT_PA.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MT_PA_sign.df = subset(Results_motus_MT_PA.df, pvalue < 0.05)
dim(Results_motus_MT_PA_sign.df)
Results_motus_MT_PA_sign.df





```

###Suspended
```{r}

####Select Suspended (Light) fraction ####

#Extract sample numbers for Susp - MG
Susp_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Light_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MG_matrix_mantel.dist))))
#Extract only Susp samples
MG_Susp.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Susp_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Susp_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for Susp - mOTUs MG
Susp_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Light_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MG_matrix_mantel.dist))))
#Extract only Susp samples
motus_MG_Susp.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Susp_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Susp_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid


#Extract sample numbers for Susp - MT
Susp_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Light_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MT_matrix_mantel.dist))))
#Extract only Susp samples
MT_Susp.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Susp_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Susp_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for Susp - mOTUs MT
Susp_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Light_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MT_matrix_mantel.dist))))
#Extract only Susp samples
motus_MT_Susp.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Susp_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Susp_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid






####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_Susp.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_Susp.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_Susp_sub.dist = as.data.frame(as.matrix(MG_Susp.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_Susp_sub.dist = as.data.frame(as.matrix(MT_Susp.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_Susp_sub.dist, MT_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.1355
#      Significance: 0.123






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_Susp.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_Susp.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_Susp_sub.dist = as.data.frame(as.matrix(MG_Susp.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_Susp_sub.dist = as.data.frame(as.matrix(motus_MG_Susp.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_Susp_sub.dist, motus_MG_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.4739
#      Significance: 0.001






####MT - motus ####



#Extract sample numbers
MT_samples = data.frame(MT_samples = sort(as.numeric(colnames(as.matrix(MT_Susp.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MT_Susp.dist)))))


#Compare and put into dataframe
MT_samples$motu_match = match(MT_samples$MT_sample, motus_samples$motus_samples)
motus_samples$MT_match = match(motus_samples$motus_samples, MT_samples$MT_samples)


#Extract only matching samples
MT_motu_matches = subset(MT_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MT_Susp_sub.dist = as.data.frame(as.matrix(MT_Susp.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MT_Susp_sub.dist = as.data.frame(as.matrix(motus_MT_Susp.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MT_Susp_sub.dist, motus_MT_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.4816
#      Significance: 0.012



####MG vs Individual PP ####
#Run loop for MG_Susps vs individual physicochemical Susprameters
Results_MG_Susp.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_Susp_samples = data.frame(MG_Susp_sample = sort(as.numeric(colnames(as.matrix(MG_Susp.dist)))))


    #ComSuspre and put into dataframe
    PP_samples$MG_Susp_match = match(PP_samples$PP_sample, MG_Susp_samples$MG_Susp_sample)
    MG_Susp_samples$PP_match = match(MG_Susp_samples$MG_Susp_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_Susp_matches = subset(PP_samples, MG_Susp_match!="NA")


    #Subset distance matrices by matching samples
    MG_Susp_sub.dist = as.data.frame(as.matrix(MG_Susp.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MG_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MG_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_Susp.df = rbind(Results_MG_Susp.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Susprameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MG_Susp.df = Results_MG_Susp.df[-1,]
Results_MG_Susp.df

#Check if each PP was included
unique(Results_MG_Susp.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_Susp_sign.df = subset(Results_MG_Susp.df, pvalue < 0.05)
dim(Results_MG_Susp_sign.df)
Results_MG_Susp_sign.df





####motus_MG vs Individual PP ####
#Run loop for motus_MG_Susps vs individual physicochemical Susprameters
Results_motus_MG_Susp.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_Susp_samples = data.frame(motus_MG_Susp_sample = sort(as.numeric(colnames(as.matrix(motus_MG_Susp.dist)))))


    #ComSuspre and put into dataframe
    PP_samples$motus_MG_Susp_match = match(PP_samples$PP_sample, motus_MG_Susp_samples$motus_MG_Susp_sample)
    motus_MG_Susp_samples$PP_match = match(motus_MG_Susp_samples$motus_MG_Susp_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_Susp_matches = subset(PP_samples, motus_MG_Susp_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_Susp_sub.dist = as.data.frame(as.matrix(motus_MG_Susp.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG_Susp.df = rbind(Results_motus_MG_Susp.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Susprameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MG_Susp.df = Results_motus_MG_Susp.df[-1,]
Results_motus_MG_Susp.df

#Check if each PP was included
unique(Results_motus_MG_Susp.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_Susp_sign.df = subset(Results_motus_MG_Susp.df, pvalue < 0.05)
dim(Results_motus_MG_Susp_sign.df)
Results_motus_MG_Susp_sign.df





####MT vs Individual PP ####
#Run loop for MT_Susps vs individual physicochemical Susprameters
Results_MT_Susp.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_Susp_samples = data.frame(MT_Susp_sample = sort(as.numeric(colnames(as.matrix(MT_Susp.dist)))))


    #ComSuspre and put into dataframe
    PP_samples$MT_Susp_match = match(PP_samples$PP_sample, MT_Susp_samples$MT_Susp_sample)
    MT_Susp_samples$PP_match = match(MT_Susp_samples$MT_Susp_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_Susp_matches = subset(PP_samples, MT_Susp_match!="NA")


    #Subset distance matrices by matching samples
    MT_Susp_sub.dist = as.data.frame(as.matrix(MT_Susp.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MT_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MT_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_Susp.df = rbind(Results_MT_Susp.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Susprameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT_Susp.df = Results_MT_Susp.df[-1,]
Results_MT_Susp.df

#Check if each PP was included
unique(Results_MT_Susp.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_Susp_sign.df = subset(Results_MT_Susp.df, pvalue < 0.05)
dim(Results_MT_Susp_sign.df)
Results_MT_Susp_sign.df





####motus_MT vs Individual PP ####
#Run loop for motus_MT_Susps vs individual physicochemical Susprameters
Results_motus_MT_Susp.df = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MT_Susp_samples = data.frame(motus_MT_Susp_sample = sort(as.numeric(colnames(as.matrix(motus_MT_Susp.dist)))))


    #ComSuspre and put into dataframe
    PP_samples$motus_MT_Susp_match = match(PP_samples$PP_sample, motus_MT_Susp_samples$motus_MT_Susp_sample)
    motus_MT_Susp_samples$PP_match = match(motus_MT_Susp_samples$motus_MT_Susp_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MT_Susp_matches = subset(PP_samples, motus_MT_Susp_match!="NA")


    #Subset distance matrices by matching samples
    motus_MT_Susp_sub.dist = as.data.frame(as.matrix(motus_MT_Susp.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MT_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MT_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MT_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MT_Susp.df = rbind(Results_motus_MT_Susp.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Susprameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MT_Susp.df = Results_motus_MT_Susp.df[-1,]
Results_motus_MT_Susp.df

#Check if each PP was included
unique(Results_motus_MT_Susp.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MT_Susp_sign.df = subset(Results_motus_MT_Susp.df, pvalue < 0.05)
dim(Results_motus_MT_Susp_sign.df)
Results_motus_MT_Susp_sign.df





```

###Sinking
```{r}

####Select Sinking (Light) fraction ####

#Extract sample numbers for Sink - MG
Sink_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Heavy_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MG_matrix_mantel.dist))))
#Extract only Sink samples
MG_Sink.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Sink_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Sink_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for Sink - mOTUs MG
Sink_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Heavy_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MG_matrix_mantel.dist))))
#Extract only Sink samples
motus_MG_Sink.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Sink_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Sink_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid


#Extract sample numbers for Sink - MT
Sink_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Heavy_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MT_matrix_mantel.dist))))
#Extract only Sink samples
MT_Sink.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Sink_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Sink_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for Sink - mOTUs MT
Sink_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Heavy_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MT_matrix_mantel.dist))))
#Extract only Sink samples
motus_MT_Sink.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Sink_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Sink_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid






####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_Sink.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_Sink.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_Sink_sub.dist = as.data.frame(as.matrix(MG_Sink.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_Sink_sub.dist = as.data.frame(as.matrix(MT_Sink.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_Sink_sub.dist, MT_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.06807
#      Significance: 0.225






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_Sink.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_Sink.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_Sink_sub.dist = as.data.frame(as.matrix(MG_Sink.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_Sink_sub.dist = as.data.frame(as.matrix(motus_MG_Sink.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_Sink_sub.dist, motus_MG_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.494
#      Significance: 0.001






####MT - motus ####



#Extract sample numbers
MT_samples = data.frame(MT_samples = sort(as.numeric(colnames(as.matrix(MT_Sink.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MT_Sink.dist)))))


#Compare and put into dataframe
MT_samples$motu_match = match(MT_samples$MT_sample, motus_samples$motus_samples)
motus_samples$MT_match = match(motus_samples$motus_samples, MT_samples$MT_samples)


#Extract only matching samples
MT_motu_matches = subset(MT_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MT_Sink_sub.dist = as.data.frame(as.matrix(MT_Sink.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MT_Sink_sub.dist = as.data.frame(as.matrix(motus_MT_Sink.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MT_Sink_sub.dist, motus_MT_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.09249
#      Significance: 0.229


####MG vs Individual PP ####

#Run loop for MG_Sinks vs individual physicochemical Sinkrameters
Results_MG_Sink.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_Sink_samples = data.frame(MG_Sink_sample = sort(as.numeric(colnames(as.matrix(MG_Sink.dist)))))


    #Compare and put into dataframe
    PP_samples$MG_Sink_match = match(PP_samples$PP_sample, MG_Sink_samples$MG_Sink_sample)
    MG_Sink_samples$PP_match = match(MG_Sink_samples$MG_Sink_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_Sink_matches = subset(PP_samples, MG_Sink_match!="NA")


    #Subset distance matrices by matching samples
    MG_Sink_sub.dist = as.data.frame(as.matrix(MG_Sink.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MG_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MG_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_Sink.df = rbind(Results_MG_Sink.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MG_Sink.df = Results_MG_Sink.df[-1,]
Results_MG_Sink.df

#Check if each PP was included
unique(Results_MG_Sink.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_Sink_sign.df = subset(Results_MG_Sink.df, pvalue < 0.05)
dim(Results_MG_Sink_sign.df)
Results_MG_Sink_sign.df





####motus_MG vs Individual PP ####
#Run loop for motus_MG_Sinks vs individual physicochemical Sinkrameters
Results_motus_MG_Sink.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_Sink_samples = data.frame(motus_MG_Sink_sample = sort(as.numeric(colnames(as.matrix(motus_MG_Sink.dist)))))


    #ComSinkre and put into dataframe
    PP_samples$motus_MG_Sink_match = match(PP_samples$PP_sample, motus_MG_Sink_samples$motus_MG_Sink_sample)
    motus_MG_Sink_samples$PP_match = match(motus_MG_Sink_samples$motus_MG_Sink_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_Sink_matches = subset(PP_samples, motus_MG_Sink_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_Sink_sub.dist = as.data.frame(as.matrix(motus_MG_Sink.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG_Sink.df = rbind(Results_motus_MG_Sink.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Sinkrameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MG_Sink.df = Results_motus_MG_Sink.df[-1,]
Results_motus_MG_Sink.df

#Check if each PP was included
unique(Results_motus_MG_Sink.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_Sink_sign.df = subset(Results_motus_MG_Sink.df, pvalue < 0.05)
dim(Results_motus_MG_Sink_sign.df)
Results_motus_MG_Sink_sign.df





####MT vs Individual PP ####
#Run loop for MT_Sinks vs individual physicochemical Sinkrameters
Results_MT_Sink.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_Sink_samples = data.frame(MT_Sink_sample = sort(as.numeric(colnames(as.matrix(MT_Sink.dist)))))


    #ComSinkre and put into dataframe
    PP_samples$MT_Sink_match = match(PP_samples$PP_sample, MT_Sink_samples$MT_Sink_sample)
    MT_Sink_samples$PP_match = match(MT_Sink_samples$MT_Sink_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_Sink_matches = subset(PP_samples, MT_Sink_match!="NA")


    #Subset distance matrices by matching samples
    MT_Sink_sub.dist = as.data.frame(as.matrix(MT_Sink.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MT_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MT_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_Sink.df = rbind(Results_MT_Sink.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Sinkrameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT_Sink.df = Results_MT_Sink.df[-1,]
Results_MT_Sink.df

#Check if each PP was included
unique(Results_MT_Sink.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_Sink_sign.df = subset(Results_MT_Sink.df, pvalue < 0.05)
dim(Results_MT_Sink_sign.df)
Results_MT_Sink_sign.df





####motus_MT vs Individual PP ####
#Run loop for motus_MT_Sinks vs individual physicochemical Sinkrameters
Results_motus_MT_Sink.df = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MT_Sink_samples = data.frame(motus_MT_Sink_sample = sort(as.numeric(colnames(as.matrix(motus_MT_Sink.dist)))))


    #ComSinkre and put into dataframe
    PP_samples$motus_MT_Sink_match = match(PP_samples$PP_sample, motus_MT_Sink_samples$motus_MT_Sink_sample)
    motus_MT_Sink_samples$PP_match = match(motus_MT_Sink_samples$motus_MT_Sink_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MT_Sink_matches = subset(PP_samples, motus_MT_Sink_match!="NA")


    #Subset distance matrices by matching samples
    motus_MT_Sink_sub.dist = as.data.frame(as.matrix(motus_MT_Sink.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MT_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MT_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MT_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MT_Sink.df = rbind(Results_motus_MT_Sink.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Sinkrameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MT_Sink.df = Results_motus_MT_Sink.df[-1,]
Results_motus_MT_Sink.df

#Check if each PP was included
unique(Results_motus_MT_Sink.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MT_Sink_sign.df = subset(Results_motus_MT_Sink.df, pvalue < 0.05)
dim(Results_motus_MT_Sink_sign.df)
Results_motus_MT_Sink_sign.df


```




##Make plots

```{r}
####Combine all results above into one dataframe and extract significant ones ####
Mantel_IndPP_Comm.df = rbind(#Results_MG.df, Results_motus_MG.df, Results_MT.df, Results_motus_MT.df,
                             Results_MG_FL.df, Results_motus_MG_FL.df, Results_MT_FL.df, Results_motus_MT_FL.df,
                             Results_MG_PA.df, Results_motus_MG_PA.df, Results_MT_PA.df, Results_motus_MT_PA.df,
                             Results_MG_Susp.df, Results_motus_MG_Susp.df, Results_MT_Susp.df, Results_motus_MT_Susp.df,
                             Results_MG_Sink.df, Results_motus_MG_Sink.df, Results_MT_Sink.df, Results_motus_MT_Sink.df
                             )
#Remove DELETEME rows
Mantel_IndPP_Comm.df = subset(Mantel_IndPP_Comm.df, PhysicochemicalParameter!="DELETEME")

#Mantel_IndPP_Comm.df = subset(Mantel_IndPP_Comm.df, PhysicochemicalParameter!="PTH_mg.L")
#Mantel_IndPP_Comm.df = subset(Mantel_IndPP_Comm.df, PhysicochemicalParameter!="Sat_O2_Perc")

#Keep as backup (and read in in case of catastrophy)
write.csv(Mantel_IndPP_Comm.df, "F:/Functional_R_analysis/Mantel_IndPP_Comm.csv")
#Mantel_IndPP_Comm.df = read.csv("E:/Functional_R_analysis/Mantel_IndPP_Comm.csv")

#Subset to only significant results
Mantel_IndPP_Comm_sign.df = subset(Mantel_IndPP_Comm.df, pvalue < 0.05)


####Make pretty for plotting ####

#Make groups for better information when plotting
Mantel_IndPP_Comm.df$Groups = c(paste0(Mantel_IndPP_Comm.df$Data_type, " - ", Mantel_IndPP_Comm.df$Community_type))

#Reorder for easy interpretation
Mantel_IndPP_Comm.df$Groups = factor(Mantel_IndPP_Comm.df$Groups,
                                          levels = c(
                                            "mOTU_TranscriptsPerGene - Sinking",
                                            "mOTU_TranscriptsPerGene - Suspended",
                                            "mOTU_TranscriptsPerGene - Particle_Associated",
                                            "mOTU_TranscriptsPerGene - Free-living",
                                            "mOTU_Metagenomes - Sinking",
                                            "mOTU_Metagenomes - Suspended",
                                            "mOTU_Metagenomes - Particle_Associated",
                                            "mOTU_Metagenomes - Free-living",
                                            "TranscriptsPerGene - Sinking",
                                            "TranscriptsPerGene - Suspended",
                                            "TranscriptsPerGene - Particle_Associated",
                                            "TranscriptsPerGene - Free-living",
                                            "Metagenomes - Sinking",
                                            "Metagenomes - Suspended",
                                            "Metagenomes - Particle_Associated",
                                            "Metagenomes - Free-living"
                                            ))
#Mantel_IndPP_Comm.df$Groups = factor(Mantel_IndPP_Comm.df$Groups,
 #                                         levels = c(
  #                                          "mOTU_TranscriptsPerGene - Sinking",
   #                                         "mOTU_Metagenomes - Sinking",
    #                                        "TranscriptsPerGene - Sinking",
     #                                       "Metagenomes - Sinking",
      #                                      "mOTU_TranscriptsPerGene - Suspended",
       #                                     "mOTU_Metagenomes - Suspended",
        #                                    "TranscriptsPerGene - Suspended",
         #                                   "Metagenomes - Suspended",
          #                                  "mOTU_TranscriptsPerGene - Particle_Associated",
           #                                 "mOTU_Metagenomes - Particle_Associated",
            #                                "TranscriptsPerGene - Particle_Associated",
             #                               "Metagenomes - Particle_Associated",
              #                              "mOTU_TranscriptsPerGene - Free-living",
               #                             "mOTU_Metagenomes - Free-living",
                #                            "TranscriptsPerGene - Free-living",
                 #                           "Metagenomes - Free-living",
                  #                          "mOTU_TranscriptsPerGene - Whole",
                   #                         "mOTU_Metagenomes - Whole",
                    #                        "TranscriptsPerGene - Whole",
                     #                       "Metagenomes - Whole"
                      #                      ))
#Change variable names for nice plots
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("station_km", "Elbe km", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Salinity_PSU", "Salinity (PSU)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Temperature_TBDHereon", "Temperature (Â°C)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("dCO2_uM", "dCO2 (ÂµM)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("dCH4_nM", "dCH4 (nM)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)

Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("O2_uM", "dO2 (ÂµM)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Turbidity_NTU", "Turbidity (NTU)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("PTC_mgperL", "PTC (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("SPM_mgperL", "Dry-weight (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("POC_mgperL", "POC (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("DOC_mg.L", "DOC (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("DIC_mg.L", "DIC (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)

Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("PTN_mgperL", "PTN (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("TN_mg.L", "DTN (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Ammonium_mg.L", "NH4+ (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Nitrite_mg.L", "NO2- (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Nitrate_mg.L", "NO3- (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Silicate_mg.L", "Si (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("TotalDissolvedPhosphate_mg.L", "DP (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("SRP_mgperL", "SRP (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("TEP_um2perL", "TEP (Âµm2 L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("CSP_um2perL", "CSP (Âµm2 L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Density_mgperL_um2perL", "Density (mgL-1 Âµm2L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("ParticleArea_um2perL", "Particle area (um2 L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)

#Reorder for easy interpretation
Mantel_IndPP_Comm.df$PhysicochemicalParameter = factor(Mantel_IndPP_Comm.df$PhysicochemicalParameter,
                                          levels = c(
                                            "CSP (Âµm2 L-1)",
                                            "TEP (Âµm2 L-1)",
                                            "Si (mg L-1)",
                                            "SRP (mg L-1)",
                                            "DP (mg L-1)",
                                            "pH",
                                            "NO3- (mg L-1)",
                                            "NO2- (mg L-1)",
                                            "NH4+ (mg L-1)",
                                            "DTN (mg L-1)",
                                            "PTN (mg L-1)",
                                            "dO2 (ÂµM)",
                                            "dCH4 (nM)",
                                            "dCO2 (ÂµM)",
                                            "DIC (mg L-1)",
                                            "DOC (mg L-1)",
                                            "POC (mg L-1)",
                                            "PTC (mg L-1)",
                                            "Density (mgL-1 Âµm2L-1)",
                                            "Particle area (um2 L-1)",
                                            "Dry-weight (mg L-1)",
                                            "Turbidity (NTU)",
                                            "Temperature (Â°C)",
                                            "Salinity (PSU)",
                                            "Elbe km"
                                            ))


#Remove PA
Mantel_IndPP_Comm.df = subset(Mantel_IndPP_Comm.df, Community_type!="Particle_Associated")

####Make actual plot ####

Comm_PP_rhovalue.plt = ggplot(Mantel_IndPP_Comm.df, aes(x = PhysicochemicalParameter, y = Groups, fill = ifelse(pvalue <= 0.05, Mantel_Rvalue, 0)))+
  geom_tile()+
  geom_text(aes(label = ifelse(pvalue > 0.05, "", 
                               ifelse(pvalue > 0.01, "*", 
                                      ifelse(pvalue > 0.001, "**", 
                                             ifelse(pvalue <= 0.001, "***", ""))))),
            size = 20 / .pt,
            colour = "black")+
  scale_fill_gradient2("Mantel Correlation", low = "navy", mid = "white", high = "red", midpoint = 0)+ 
  scale_x_discrete(
    expand = expansion(mult = c(0,0)), guide = guide_axis(angle = 90),
    position = "top",
    limits = rev
  )+
  scale_y_discrete(
    expand = expansion(mult = c(0,0)),
    position = "right"
  )+
  xlab("Physicochemical parameters") + 
  ylab("Community")+
  My_Theme
Comm_PP_rhovalue.plt


pdf("E:/Functional_R_analysis/Figures/Comm_PP_heatmap_pearson.pdf", width = 17, height = 8)
Comm_PP_rhovalue.plt 
dev.off()




```
## Attic - Mantel MG vs MT vs mOTU
```{r}

####Generate MG dataframe ####
#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")
dim(distinct(CarbonGenelist.df))
#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#Correct abundance
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000

#write.csv(amoAClean_CO2CH4_tbl_long, "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")

#amoAClean_CO2CH4_tbl_long = read.csv( "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)

#Subset to split metagenomes and metatranscriptomes and remove superflous columns
amoAClean_CO2CH4_tbl_long_MG = subset(amoAClean_CO2CH4_tbl_long, data_type == "Metagenomes") %>%
  select(counts, KO, Associatednumber)

dim(amoAClean_CO2CH4_tbl_long_MG)
amoAClean_CO2CH4_tbl_long_MG = unique(amoAClean_CO2CH4_tbl_long_MG)
dim(amoAClean_CO2CH4_tbl_long_MG)



#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MG <- data.frame(spread(amoAClean_CO2CH4_tbl_long_MG,
                       key = Associatednumber, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MG)
#View(amoAClean_CO2CH4_wide_MG)

#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MG) = amoAClean_CO2CH4_wide_MG$KO
amoAClean_CO2CH4_wide_MG$KO = NULL

#So I don't need to waste time rerunning this every time
write.csv(amoAClean_CO2CH4_wide_MG, "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv")
#amoAClean_CO2CH4_wide_MG = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)

#Remove x from column names
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))

####Generate MT dataframe ####


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

#Correct abundance
amoAClean_geneabund_KO[c(2:264)] = amoAClean_geneabund_KO[c(2:264)] / 1000


amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)



#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)




#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG.df = CO2CH4_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG.lng = gather(CO2CH4_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber)
dim(CO2CH4_TG.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG.lng$counts = as.numeric(as.character(CO2CH4_TG.lng$counts))
CO2CH4_TG.lng$Associatednumber = as.character(CO2CH4_TG.lng$Associatednumber)

#Long to wide
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MT <- data.frame(spread(unique(CO2CH4_TG.lng),
                       key = Associatednumber, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MT)
#View(amoAClean_CO2CH4_wide_MT)

#Bug check
max(amoAClean_CO2CH4_wide_MT$X117) # should be ~673.5397

#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MT) = amoAClean_CO2CH4_wide_MT$KO
amoAClean_CO2CH4_wide_MT$KO = NULL


#So I don't need to waste time rerunning this every time
write.csv(amoAClean_CO2CH4_wide_MT, "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv")
#amoAClean_CO2CH4_wide_MT = read.csv("E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove x from column names
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))


####Import mOTU dataframe####

Microbiome_wide_mOTU = read.csv("E:/Functional_R_analysis/mOTU_SamplesSpecies.csv", row.names = 1)

####Match samples between functional potential and mOTUs and run dissimilarities####

#Read in dataframes
amoAClean_CO2CH4_wide_MG = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)
Microbiome_wide_mOTU = read.csv("E:/Functional_R_analysis/mOTU_SamplesSpecies.csv", row.names = 1)
amoAClean_CO2CH4_wide_MT = read.csv("E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove any potential x's from column names for both dataframes
colnames(Microbiome_wide_mOTU) = gsub("X", "", colnames(Microbiome_wide_mOTU))
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))

#Get an idea of how many samples MG and mOTUs have
dim(Microbiome_wide_mOTU)
dim(amoAClean_CO2CH4_wide_MG)

#Extract only matched samples for dissimilarity, otherwise mantel doesn't work
Microbiome_wide_mOTU = Microbiome_wide_mOTU[names(Microbiome_wide_mOTU) %in% colnames(amoAClean_CO2CH4_wide_MG)]
amoAClean_CO2CH4_wide_MG = amoAClean_CO2CH4_wide_MG[names(amoAClean_CO2CH4_wide_MG) %in% colnames(Microbiome_wide_mOTU)]

#Sanity check to see if it worked
dim(Microbiome_wide_mOTU)
dim(amoAClean_CO2CH4_wide_MG)


#Set seed for reproducibility
set.seed(2)

#Run dissimilarity comparison between samples
##Microbial
Microbiome_wide_mOTU.diss = vegan::vegdist(t(Microbiome_wide_mOTU), method = "bray", na.rm = T)
amoAClean_CO2CH4_wide_MG.diss = vegan::vegdist(t(amoAClean_CO2CH4_wide_MG), method = "bray", na.rm = T)

#Run mantel test
vegan::mantel(Microbiome_wide_mOTU.diss, amoAClean_CO2CH4_wide_MG.diss) 







####Match samples between transcripts and mOTUs and run dissimilarities####

#Read in dataframes
amoAClean_CO2CH4_wide_MG = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)
Microbiome_wide_mOTU = read.csv("E:/Functional_R_analysis/mOTU_SamplesSpecies.csv", row.names = 1)
amoAClean_CO2CH4_wide_MT = read.csv("E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove any potential x's from column names for both dataframes
colnames(Microbiome_wide_mOTU) = gsub("X", "", colnames(Microbiome_wide_mOTU))
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))

#Get an idea of how many samples MG and mOTUs have
dim(Microbiome_wide_mOTU)
dim(amoAClean_CO2CH4_wide_MT)

#Extract only matched samples for dissimilarity, otherwise mantel doesn't work
Microbiome_wide_mOTU = Microbiome_wide_mOTU[names(Microbiome_wide_mOTU) %in% colnames(amoAClean_CO2CH4_wide_MT)]
amoAClean_CO2CH4_wide_MT = amoAClean_CO2CH4_wide_MT[names(amoAClean_CO2CH4_wide_MT) %in% colnames(Microbiome_wide_mOTU)]

#Sanity check to see if it worked
dim(Microbiome_wide_mOTU)
dim(amoAClean_CO2CH4_wide_MT)


#Set seed for reproducibility
set.seed(2)

#Run dissimilarity comparison between samples
##Microbial
Microbiome_wide_mOTU.diss = vegan::vegdist(t(Microbiome_wide_mOTU), method = "bray", na.rm = T)
amoAClean_CO2CH4_wide_MT.diss = vegan::vegdist(t(amoAClean_CO2CH4_wide_MT), method = "bray", na.rm = T)

#Run mantel test
vegan::mantel(Microbiome_wide_mOTU.diss, amoAClean_CO2CH4_wide_MT.diss)





####Match samples between transcripts and metagenomes and run dissimilarities####

#Read in dataframes
amoAClean_CO2CH4_wide_MG = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)
Microbiome_wide_mOTU = read.csv("E:/Functional_R_analysis/mOTU_SamplesSpecies.csv", row.names = 1)
amoAClean_CO2CH4_wide_MT = read.csv("E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove any potential x's from column names for both dataframes
colnames(Microbiome_wide_mOTU) = gsub("X", "", colnames(Microbiome_wide_mOTU))
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))

#Get an idea of how many samples MG and mOTUs have
dim(amoAClean_CO2CH4_wide_MG)
dim(amoAClean_CO2CH4_wide_MT)

#Extract only matched samples for dissimilarity, otherwise mantel doesn't work
amoAClean_CO2CH4_wide_MG = amoAClean_CO2CH4_wide_MG[names(amoAClean_CO2CH4_wide_MG) %in% colnames(amoAClean_CO2CH4_wide_MT)]
amoAClean_CO2CH4_wide_MT = amoAClean_CO2CH4_wide_MT[names(amoAClean_CO2CH4_wide_MT) %in% colnames(amoAClean_CO2CH4_wide_MG)]

#Sanity check to see if it worked
dim(amoAClean_CO2CH4_wide_MG)
dim(amoAClean_CO2CH4_wide_MT)


#Set seed for reproducibility
set.seed(2)

#Run dissimilarity comparison between samples
##Microbial
amoAClean_CO2CH4_wide_MG.diss = vegan::vegdist(t(amoAClean_CO2CH4_wide_MG), method = "bray", na.rm = T)
amoAClean_CO2CH4_wide_MT.diss = vegan::vegdist(t(amoAClean_CO2CH4_wide_MT), method = "bray", na.rm = T)

#Run mantel test
vegan::mantel(amoAClean_CO2CH4_wide_MG.diss, amoAClean_CO2CH4_wide_MT.diss)

```

#Alpha diversity
##Alpha diversity for metagenomes
```{r}

####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long_MG <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()
amoAClean_CO2CH4_tbl_long_MG$counts = amoAClean_CO2CH4_tbl_long_MG$counts / 1000

#View(amoAClean_CO2CH4_tbl_long_MG)
dim(amoAClean_CO2CH4_tbl_long_MG)

#Reorder factors
amoAClean_CO2CH4_tbl_long_MG$Station = factor(amoAClean_CO2CH4_tbl_long_MG$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long_MG$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long_MG$Sample_date)

amoAClean_CO2CH4_tbl_long_MG$Sample_date = factor(amoAClean_CO2CH4_tbl_long_MG$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

dim(amoAClean_CO2CH4_tbl_long_MG)


####Calculate alpha diversity for each samples####

MG_rich.df <- amoAClean_CO2CH4_tbl_long_MG %>%
  filter(counts > 0) %>% # Remove genes that had transcripts but not metagenome counts
  select(Associatednumber, KO) %>% # select only relevant columns
  dplyr::mutate(Associatednumber = as.character(Associatednumber)) %>%
  group_by(Associatednumber) %>%
  dplyr::mutate(MG_gene_richness = n_distinct(KO)) %>%
  select(Associatednumber, MG_gene_richness) %>%
  distinct() %>%
  dplyr::mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  left_join(metadata) %>% # add metadata
  filter(data_type == "METAG") %>%
  select(Associatednumber, MG_gene_richness)
MG_rich.df

  
```
##Alpha diversity for metatranscriptomes
```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long_MT <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Associatednumber > 115) %>% # remove samples that have no metagenome samples
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long_MT$counts = amoAClean_CO2CH4_tbl_long_MT$counts / 1000


#View(amoAClean_CO2CH4_tbl_long_MT)
dim(amoAClean_CO2CH4_tbl_long_MT)

#write.csv(amoAClean_CO2CH4_tbl_long_MT, "F:/Functional_R_analysis/moAClean_CO2CH4_OccurrenceFiltered_V2_TG.csv")

#amoAClean_CO2CH4_tbl_long_MT = read.csv( "F:/Functional_R_analysis/moAClean_CO2CH4_OccurrenceFiltered_V2_TG.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long_MT$Station = factor(amoAClean_CO2CH4_tbl_long_MT$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long_MT$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long_MT$Sample_date)

amoAClean_CO2CH4_tbl_long_MT$Sample_date = factor(amoAClean_CO2CH4_tbl_long_MT$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_MT$data_type)
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_MT$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long_MT[ , ! names(amoAClean_CO2CH4_tbl_long_MT) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_MT)
dim(CO2CH4_TG.df)


#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG.df = CO2CH4_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "IncompleteMetagenome")) #Replace Infin with #/0, as Metagenome likely incomplete

####Calculate alpha diversity for each samples####

MT_rich.df <- CO2CH4_TG.df %>%
  filter(TranscriptsPerGenome > 0) %>% # Remove genes that had transcripts but not metagenome counts
  select(Associatednumber, KO) %>% # select only relevant columns
  dplyr::mutate(Associatednumber = as.character(Associatednumber)) %>%
  group_by(Associatednumber) %>%
  dplyr::mutate(MT_gene_richness = n_distinct(KO)) %>%
  select(Associatednumber, MT_gene_richness) %>%
  distinct() %>%
  dplyr::mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  left_join(metadata) %>% # add metadata
  filter(data_type == "METAT") %>%
  select(Associatednumber, MT_gene_richness)
MT_rich.df

```
##Alpha diversity for mOTUs
```{r }

####Update motu table with working sample numbers####
motus_final_taxa_metadata <- readRDS(file="E:/Functional_R_analysis/motus_final_taxa_metadata.RDS")

##Lets check out experimental scheme

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date))


Stupidworkaround.df = read.csv("E:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", sep = ";")
dim(motus_final_taxa_metadata)

motus_final_taxa_metadata
i=1
x=1
for (i in 1:length(Stupidworkaround.df$BioSample)) {
  for (x in 1:length(motus_final_taxa_metadata$BioSample)) {
  if(grepl(Stupidworkaround.df$BioSample[i], motus_final_taxa_metadata$BioSample[x]) == T) {
    
    motus_final_taxa_metadata$Associatednumber[x] = Stupidworkaround.df$Associatednumber[i]
    
    print(paste0("Matching ", motus_final_taxa_metadata$BioSample[x], " with ", Stupidworkaround.df$BioSample[i], " thereby matching ", motus_final_taxa_metadata$Associatednumber[x], " and ", Stupidworkaround.df$Associatednumber[i]))
    
  }
  }
}

#Export to never have to do this again
#saveRDS(motus_final_taxa_metadata, file="E:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS")

#### Import modified dataframe ####

#Import modified dataframe
motus_final_taxa_metadata <- readRDS(file="E:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS")


####Calculate alpha diversity for each samples####


#Now calculate the richness
motus_MG_rich.df <- motus_final_taxa_metadata %>%
  filter(data_type == "METAG") %>%
  filter(counts > 0) %>% # Remove genes that had transcripts but not metagenome counts
  select(Associatednumber, mOTU) %>% # select only relevant columns
  dplyr::mutate(Associatednumber = as.character(Associatednumber)) %>%
  group_by(Associatednumber) %>%
  dplyr::mutate(motu_MG_richness = n_distinct(mOTU)) %>%
  select(Associatednumber, motu_MG_richness) %>%
  distinct() %>%
  dplyr::mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  left_join(metadata) %>% # add metadata
  filter(data_type == "METAG") %>%
  select(Associatednumber, motu_MG_richness)
motus_MG_rich.df

motus_MT_rich.df <- motus_final_taxa_metadata %>%
  filter(data_type == "METAT") %>%
  filter(counts > 0) %>% # Remove genes that had transcripts but not metagenome counts
  select(Associatednumber, mOTU) %>% # select only relevant columns
  dplyr::mutate(Associatednumber = as.character(Associatednumber)) %>%
  group_by(Associatednumber) %>%
  dplyr::mutate(motu_MT_richness = n_distinct(mOTU)) %>%
  select(Associatednumber, motu_MT_richness) %>%
  distinct() %>%
  dplyr::mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  left_join(metadata) %>% # add metadata
  filter(data_type == "METAT") %>%
  select(Associatednumber, motu_MT_richness)
motus_MT_rich.df

```
##Combine dataframe and plot

```{r}

AlphaDiv.df = MG_rich.df %>% 
  left_join(MT_rich.df,by = 'Associatednumber') %>% 
  mutate(MT_gene_richness = replace(MT_gene_richness, is.na(MT_gene_richness), 0)) %>% 
  left_join(motus_MG_rich.df,by = 'Associatednumber') %>% 
  mutate(motu_MG_richness = replace(motu_MG_richness, is.na(motu_MG_richness), 0)) %>% 
  left_join(motus_MT_rich.df,by = 'Associatednumber') %>% 
  mutate(motu_MT_richness = replace(motu_MT_richness, is.na(motu_MT_richness), 0)) %>%
  pivot_longer(!Associatednumber , names_to = "richness_type", values_to = "Richness") %>% 
  left_join(distinct(metadata[,c(1:2,4:18)]), relationship = "many-to-one")  %>% # add metadata
  mutate(lifestyle = ifelse(grepl("fraction", Sample_type), "PA", "FL"))
AlphaDiv.df


test = AlphaDiv.df %>%
  filter(lifestyle == "PA") %>%
  select(Associatednumber, Richness) %>%
  group_by(Associatednumber) %>%
  summarize(mean_val = mean(Richness))
test

AlphaDiv.df$richness_type = gsub("MG_gene_richness", "Metagenome genes", AlphaDiv.df$richness_type)
AlphaDiv.df$richness_type = gsub("MT_gene_richness", "Transcripts per genome genes", AlphaDiv.df$richness_type)
AlphaDiv.df$richness_type = gsub("motu_MG_richness", "Metagenome derived mOTUs", AlphaDiv.df$richness_type)
AlphaDiv.df$richness_type = gsub("motu_MT_richness", "Metatranscriptome derived mOTUs", AlphaDiv.df$richness_type)

AlphaDiv.df$richness_type = factor(AlphaDiv.df$richness_type,
                                 levels = c("Metagenome genes",
                                            "Transcripts per genome genes",
                                            "Metagenome derived mOTUs",
                                            "Metatranscriptome derived mOTUs"))


AlphaDiv.df$Sample_type = gsub("Free_living", "Free-living", AlphaDiv.df$Sample_type)
AlphaDiv.df$Sample_type = gsub("Light_fraction", "Suspended", AlphaDiv.df$Sample_type)
AlphaDiv.df$Sample_type = gsub("Heavy_fraction", "Sinking", AlphaDiv.df$Sample_type)

AlphaDiv.df$Sample_type = factor(AlphaDiv.df$Sample_type,
                                 levels = c("Free-living",
                                            "Suspended",
                                            "Sinking"))

Richness.plt = ggplot(AlphaDiv.df, aes(x = Sample_type, y = Richness))+
  geom_violin() +
  facet_wrap(. ~ richness_type) +
  ggpubr::stat_compare_means(comparisons = list(c("Free-living", "Sinking"), c("Free-living", "Suspended"), c("Sinking", "Suspended")), aes(label = after_stat(p.signif))) +
  xlab("Life-style")+
  My_Theme
Richness.plt

pdf("E:/Functional_R_analysis/Figures/Richness.pdf", width = 10, height = 8)
Richness.plt
dev.off()


test = AlphaDiv.df %>%
  group_by(Sample_type,richness_type) %>%
  summarize(mean_val = mean(Richness))
test

test = AlphaDiv.df %>%
  group_by(richness_type,Sample_type) %>%
  summarize(mean_val = mean(Richness))
test

model = aov(Richness ~ richness_type * Sample_type, data = AlphaDiv.df)
summary(model)
test = as.data.frame(TukeyHSD(model)$`richness_type:Sample_type`)
test
#No significant differences between metagenome-metagenome and metatranscriptome-metatranscriptome fractions

pairwise.wilcox.test(AlphaDiv.df$Richness, AlphaDiv.df$richness_type)
pairwise.wilcox.test(AlphaDiv.df$Richness, AlphaDiv.df$Sample_type)

test = AlphaDiv.df %>%
  filter(lifestyle == "PA")

#No significant differences between sample types - FL etc.
```


#NMDS
##Metagenome
```{r}
####Metadata ####
metadata <- read.csv("SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT


metadata2 <- read.csv("SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)


#Add relevant rownames for making the phyloseq object
rownames(metadata) = metadata$sampleid
#Change names for consistency
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
#Reorder station km 
metadata$Station = factor(metadata$Station,
                          levels = c("Medemgrund",
                                     "Brunsbuettel",
                                     "Schwarztonnensand",
                                     "Twielenfleth",
                                     "Muehlenberger Loch",
                                     "Kollmar"))
#Reorder Dates
metadata$Sample_date = factor(metadata$Sample_date,
                          levels = c("May 21",
                                     "Jul 21",
                                     "Nov 21",
                                     "Feb 22",
                                     "May 22",
                                     "Jun 22",
                                     "Nov 22"))


#### gene abundance ####

geneabund_2 <- geneabund %>% 
  rownames_to_column("gene_cluster") # remove rownames and rename to gene_cluster

geneabund_KO <- annot %>% 
  rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  select(gene_cluster, KO) %>% # select only the columns titled gene_sluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values


geneabund_ko_otu_table <-
  geneabund_KO %>% 
  column_to_rownames("KO") %>% # remove rownames and rename to gene_cluster
  otu_table(., taxa_are_rows = TRUE) #make as a otu_table to generate a phyloseq object

gene_abund_ko_annots <- annot %>%
 rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  select(-"gene_cluster") %>% # remove the gene_cluster column
  distinct(., .keep_all = TRUE ) %>% # keep only unique KO id's
  rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  select(KO, everything()) %>%  # reorders - so KO is in front
  column_to_rownames("KO") %>% # remove column named KO and make it the rowname
  as.matrix() %>% # convert to a matrix
  tax_table() # convert to a taxa table object for phyloseq object creation

####Combine into phyloseq object and run####


metadata$station_km = as.factor(metadata$station_km)

#Reorder station km 
metadata$Station = factor(metadata$Station,
                          levels = c("713",
                                     "692",
                                     "665",
                                     "651",
                                     "633"))

#Edit fraction for plot
metadata$Sample_type = gsub("Heavy_fraction", "SI", metadata$Sample_type)
metadata$Sample_type = gsub("Light_fraction", "SU", metadata$Sample_type)
metadata$Sample_type = gsub("Free_living", "FL", metadata$Sample_type)


#Make phyloseq object
genecat_ps <- phyloseq(geneabund_ko_otu_table, gene_abund_ko_annots, sample_data(metadata))

#Subset to samples we want
genecat_pgene_abund_ko_annotsgenecat_ps = subset_samples(genecat_ps, data_type=="METAG")


#Clean up samples for the relevant ones
#genecat_LH.ps = subset_samples(genecat_pgene_abund_ko_annotsgenecat_ps, Sample_type!="Free_living")
#genecat_LH.ps = subset_samples(genecat_LH_ps, station_km > 613 & Sample_date!="Nov 21" )
genecat_LH.ps = subset_samples(genecat_pgene_abund_ko_annotsgenecat_ps, station_km!="713" | Sample_date!="Jun 22")

genecat_LH.ps = subset_samples(genecat_LH.ps, Sample_date!="Nov 21")

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(genecat_LH.ps, method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.1199889

####Make plots ####

#Design plot
NMDS_Gene.plt = plot_ordination(genecat_LH.ps, 
                             Gene.ord, 
                             color = "Sample_date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = Sample_date), show.legend = F)+
  geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  #facet_grid(. ~ data_type)+
  annotate("text", x=-0.22, y=0.3, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("Functional potential NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene.plt

#png("Figures/DFG_Gene_METAG_NMDS.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

pdf("Figures/NMDS_Gene_METAG.pdf", width = 11, height = 8)
NMDS_Gene.plt
dev.off()

#saveRDS(NMDS_Gene.plt, "Figures/DFG_Gene_METAG_NMDS.RDS")

####Other NMDS options ####
#Pairwise PERMANOVA - Sample_date
Sample_date_group = get_variable(genecat_LH.ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(genecat_LH.ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, Sample_date_group, nperm = 999, p.method = "bonferroni")
Depth_ado
#All are unique.

#Design plot
NMDS_Gene.plt = plot_ordination(genecat_LH.ps, 
                             Gene.ord, 
                             color = "station_km", 
                             shape = "Sample_date"
                             ) + 
  theme(legend.position = "right")+
  stat_ellipse(aes(group = station_km, color = station_km), lwd = 1)+
  scale_shape_manual("Sample Date", values = c(15,17, 16,18,25))+
  #scale_color_gradient2("Elbe km", 
   #                     low="green", 
    #                    mid="blue",
     #                   high="red", 
      #                  midpoint=680,
       #                 guide = "colourbar")+
  geom_point(aes(size = 2, color = station_km), show.legend = F)+
  #facet_grid(. ~ data_type)+
  annotate("text", x=-0.15, y=0.2, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene.plt

#png("Figures/Gene_METAG_NMDS2.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

#Pairwise PERMANOVA - Stations
Station_group = get_variable(genecat_LH.ps@sam_data, "station_km")
Gene.dist = phyloseq::distance(genecat_LH.ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, Station_group, nperm = 999, p.method = "bonferroni")
Depth_ado
#Patterns exist in the station differences - all estuary stations are similar to previous and subsequent stations

#Design plot
NMDS_Gene.plt = plot_ordination(genecat_LH.ps, 
                             Gene.ord, 
                             color = "Sample_type", 
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  stat_ellipse(aes(group = Sample_type, color = Sample_type), lwd = 1)+
  scale_color_manual("Particle Fraction", values = cbbPalette)+
  scale_shape_manual("Elbe Station", values = Shape_list)+
  geom_point(aes(size = 2, color = Sample_type), show.legend = F)+
  #facet_grid(. ~ data_type)+
  annotate("text", x=0.15, y=0.2, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene.plt

#png("Figures/Gene_METAG_NMDS3.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

#Pairwise PERMANOVA - fractions
fraction_group = get_variable(genecat_LH.ps@sam_data, "Sample_type")
Gene.dist = phyloseq::distance(genecat_LH.ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, fraction_group, nperm = 999, p.method = "bonferroni")
Depth_ado
#L and H are not significantly different



####Anosim, adonis, and permanova date tests####

#anosim
date_group = get_variable(genecat_LH.ps@sam_data, "Sample_date")
date_ano = anosim(phyloseq::distance(genecat_LH.ps, method = "bray"), date_group, distance = "bray")
date_ano$signif #0.001
date_ano$statistic #0.3667623
#Significant differences between group means - based on date

#Adonis
date_group = get_variable(genecat_LH.ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(genecat_LH.ps, method = "bray")
date_ado = adonis2(Gene.dist ~ date_group)
date_ado
#Significant differences between group means and distribution - based on date
#R2 = 0.30641  
#p = 0.001

#Pairwise PERMANOVA
date_group = get_variable(genecat_LH.ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(genecat_LH.ps, method = "bray")
date.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, date_group, nperm = 999, p.method = "bonferroni")
date.stat



####Anosim and adonis station_km tests####

#anosim
station_km_group = get_variable(genecat_LH.ps@sam_data, "station_km")
station_km_ano = anosim(phyloseq::distance(genecat_LH.ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.001
station_km_ano$statistic #0.2347371
#Significant differences between group means - based on station_km

#Adonis
station_km_group = get_variable(genecat_LH.ps@sam_data, "station_km")
Gene.dist = phyloseq::distance(genecat_LH.ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#Significant differences between group means and distribution - based on station_km
#R2 = 0.23653 
#p = 0.001

#Pairwise PERMANOVA
station_km_group = get_variable(genecat_LH.ps@sam_data, "station_km")
Gene.dist = phyloseq::distance(genecat_LH.ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat



####Anosim and adonis fraction tests####

#anosim
station_km_group = get_variable(genecat_LH.ps@sam_data, "Sample_type")
station_km_ano = anosim(phyloseq::distance(genecat_LH.ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.001
station_km_ano$statistic #-0.2889821
#Significant differences between group means

#Adonis
station_km_group = get_variable(genecat_LH.ps@sam_data, "Sample_type")
Gene.dist = phyloseq::distance(genecat_LH.ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#Significant differences between group means and distribution - based on fraction
#R2 = 0.20808  
#p = 0.001

#Pairwise PERMANOVA
station_km_group = get_variable(genecat_LH.ps@sam_data, "Sample_type")
Gene.dist = phyloseq::distance(genecat_LH.ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat
#No significant fraction difference


```
##Metatranscriptome
```{r}

####Metadata####
metadata <- read.csv("E:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT


metadata2 <- read.csv("E:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)

#Add relevant rownames for making the phyloseq object
rownames(metadata) = metadata$sampleid
#Change names for consistency
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
#Reorder station km 
metadata$Station = factor(metadata$Station,
                          levels = c("Medemgrund",
                                     "Brunsbuettel",
                                     "Schwarztonnensand",
                                     "Twielenfleth",
                                     "Muehlenberger Loch",
                                     "Kollmar"))
#Reorder Dates
metadata$Sample_date = factor(metadata$Sample_date,
                          levels = c("May 21",
                                     "Jul 21",
                                     "Feb 22",
                                     "May 22",
                                     "Jun 22",
                                     "Nov 22"))


####OTU table ####


#Import gene list
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)



amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  #mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  #mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  #group_by(KO) %>% 
  #mutate(occurrence = sum(abundance)/nsamples) %>% 
  #ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  #filter(occurrence > 0.2) %>%
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "amoAClean_CO2CH4.csv")

#amoAClean_CO2CH4_tbl_long = read.csv( "amoAClean_CO2CH4.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)




#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG.df = CO2CH4_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG.lng = gather(CO2CH4_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber)
dim(CO2CH4_TG.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, Associatednumber > 116)
dim(CO2CH4_TG.lng)
#Remove samples for which sequencing failed
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
dim(CO2CH4_TG.lng)

#Make sure data is set up properly
CO2CH4_TG.lng$counts = as.numeric(as.character(CO2CH4_TG.lng$counts))
CO2CH4_TG.lng$Associatednumber = as.character(CO2CH4_TG.lng$Associatednumber)


Complete_Metadata.df = read.csv("E:/Functional_R_analysis/SAMEAID_SampleID.csv", sep = ";", header = T)[,c(1,3)]
typeof(Complete_Metadata.df$Associatednumber)
typeof(CO2CH4_TG.lng$Associatednumber)

Complete_Metadata.df$Associatednumber = as.character(Complete_Metadata.df$Associatednumber)

typeof(Complete_Metadata.df$Associatednumber)
typeof(CO2CH4_TG.lng$Associatednumber)

amoAClean_CO2CH4_wide_MT_mod = CO2CH4_TG.lng %>%
  #select(-X) %>%
  left_join(Complete_Metadata.df, by = c("Associatednumber" = "Associatednumber")) %>%
  mutate_at(c('counts'), as.numeric) %>%
  distinct()
dim(amoAClean_CO2CH4_wide_MT_mod)
amoAClean_CO2CH4_wide_MT_mod$Associatednumber = NULL

amoAClean_CO2CH4_wide_MT_mod$AccessionNumber_TBDSven = paste0("GROS22.2_", amoAClean_CO2CH4_wide_MT_mod$AccessionNumber_TBDSven, "_METAT.genecount.profile")

#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MT_mod <- data.frame(spread(unique(amoAClean_CO2CH4_wide_MT_mod),
                       key = AccessionNumber_TBDSven, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MT_mod)
#View(amoAClean_CO2CH4_wide_MT_mod)




#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MT_mod) = amoAClean_CO2CH4_wide_MT_mod$KO
amoAClean_CO2CH4_wide_MT_mod$KO = NULL


####Combine and plot ####

#Ensure only relevant rows of metadata make it into the phyloseq object
metadata = subset(metadata, sampleid %in% colnames(amoAClean_CO2CH4_wide_MT_mod))

#Edit fraction for plot
metadata$Sample_type = gsub("Heavy_fraction", "SI", metadata$Sample_type)
metadata$Sample_type = gsub("Light_fraction", "SU", metadata$Sample_type)
metadata$Sample_type = gsub("Free_living", "FL", metadata$Sample_type)

metadata$station_km = factor(metadata$station_km,
                             levels = c(633,
                                        651, 
                                        665,
                                        692,
                                        713))


#Make phyloseq object
genecat_MT_ps <- phyloseq(otu_table(amoAClean_CO2CH4_wide_MT_mod, taxa_are_rows = T), gene_abund_ko_annots, sample_data(metadata))

#Clean up samples for the relevant ones
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="139")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="155")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="164")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="187")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="199")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="188")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="200")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="198")


#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(genecat_MT_ps, method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Decent stress plot - seems to have two distinct groups
Gene.ord #Good level of stress - 0.1346861 

#Design plot
NMDS_Gene.plt = plot_ordination(genecat_MT_ps, 
                             Gene.ord, 
                             color = "Sample_date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  stat_ellipse(aes(color = Sample_date, group = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  #facet_grid(. ~ data_type)+
  #geom_point(aes(size = 2, color = Sample_date), show.legend = F)+
  geom_point(aes(size = 2, color = Sample_date, group = "Sample_date"), show.legend = F)+
  geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  annotate("text", x=-0.4, y=0.48, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  ggtitle("Transcripts per Gene NMDS")+
  theme_bw()+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene.plt

#png("F:/Functional_R_analysis/Figures/Gene_METAT_NMDS.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

pdf("Figures/NMDS_METAT.pdf", width = 11, height = 8)
NMDS_Gene.plt
dev.off()

#Pairwise PERMANOVA - Sample_date
Sample_date_group = get_variable(genecat_MT_ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, Sample_date_group, nperm = 999, p.method = "bonferroni")
Depth_ado
#All are significantly different - however some marginally less so

####Other NMDS options ####
#Design plot
NMDS_Gene.plt = plot_ordination(genecat_MT_ps, 
                             Gene.ord, 
                             color = "Station", 
                             shape = "Sample_date"
                             ) + 
  theme(legend.position = "right")+
  stat_ellipse(aes(group = Station, color = Station), lwd = 1)+
  scale_shape_manual("Elbe Station", values = Shape_list)+
  scale_color_manual("Sample Date", values = cbbPalette)+
  geom_point(aes(size = 2, color = Station), show.legend = F)+
  #facet_grid(. ~ data_type)+
  annotate("text", x=0.2, y=0.2, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene.plt

#png("F:/Functional_R_analysis/Figures/Gene_METAT_NMDS2.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

#Pairwise PERMANOVA - Stations
Station_group = get_variable(genecat_MT_ps@sam_data, "station_km")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, Station_group, nperm = 999, p.method = "bonferroni")
Depth_ado
#Two groups of samples, seems to be salinity based, ML/TW/ST vs BB/MG

#Design plot
NMDS_Gene.plt = plot_ordination(genecat_MT_ps, 
                             Gene.ord, 
                             color = "Sample_type", 
                             shape = "Station"
                             ) + 
  theme(legend.position = "right")+
  stat_ellipse(aes(group = Sample_type, color = Sample_type), lwd = 1)+
  scale_color_manual("Particle Fraction", values = cbbPalette)+
  scale_shape_manual("Elbe Station", values = Shape_list)+
  geom_point(aes(size = 2, color = Sample_type), show.legend = F)+
  #facet_grid(. ~ data_type)+
  annotate("text", x=0.15, y=0.2, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene.plt

#png("F:/Functional_R_analysis/Figures/Gene_METAT_NMDS3.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

#Pairwise PERMANOVA - fractions
fraction_group = get_variable(genecat_MT_ps@sam_data, "Sample_type")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, fraction_group, nperm = 999, p.method = "bonferroni")
Depth_ado
#L and H are not significantly different - in fact they match nearly perfectly



####Anosim and adonis date tests####

#anosim
date_group = get_variable(genecat_MT_ps@sam_data, "Sample_date")
date_ano = anosim(phyloseq::distance(genecat_MT_ps, method = "bray"), date_group, distance = "bray")
date_ano$signif #0.041
date_ano$statistic #0.04957761
#Significant differences between group means - based on date

#Adonis
date_group = get_variable(genecat_MT_ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
date_ado = adonis2(Gene.dist ~ date_group)
date_ado
#Significant differences between group means and distribution - based on date
#R2 = 0.058
#p = 0.137

#Pairwise PERMANOVA
date_group = get_variable(genecat_MT_ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
date.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, date_group, nperm = 999, p.method = "bonferroni")
date.stat
#All are significantly distinct from each other (p<0.05; 0.006-0.039)


####Anosim and adonis station_km tests####

#anosim
station_km_group = get_variable(genecat_MT_ps@sam_data, "station_km")
station_km_ano = anosim(phyloseq::distance(genecat_MT_ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.001
station_km_ano$statistic #0.1362182
#Significant differences between group means - based on station_km

#Adonis
station_km_group = get_variable(genecat_MT_ps@sam_data, "station_km")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#Significant differences between group means and distribution - based on station_km
#R2 = 0.29944
#p = 0.001

#Pairwise PERMANOVA
station_km_group = get_variable(genecat_MT_ps@sam_data, "station_km")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat
#Most saline match each other (MG/ST/BB), while all samples match their preceding and following samples


####Anosim and adonis fraction tests####

#anosim
station_km_group = get_variable(genecat_MT_ps@sam_data, "Sample_type")
station_km_ano = anosim(phyloseq::distance(genecat_MT_ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.001
station_km_ano$statistic #-0.07805874
#No significant differences between group means

#Adonis
station_km_group = get_variable(genecat_MT_ps@sam_data, "Sample_type")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#No significant differences between group means and distribution - based on fraction
#R2 = 0.00581  
#p = 0.958

#Pairwise PERMANOVA
station_km_group = get_variable(genecat_MT_ps@sam_data, "Sample_type")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat
#No significant fraction difference


```


##mOTUs
```{r}
####Set up ####
motus_final_taxa_metadata <- readRDS(file="E:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS")
metadata = Physicochem.df

##Lets check out experimental scheme
motus_final_taxa_metadata %>% 
  dplyr::select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, date) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##So when we consider fraction and date we see that Nov 21 has few samples, we should consider removing it

motus_final_taxa_metadata %>% 
  dplyr::select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, station) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##By station we see that Kollmar, SeemanshÃÂ¶ft and BunthausSpitze also were sampled infrequently, lets also remove these. 

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date))


#so to do a ternary plot we actually need to create a physeq object really quick 
motus_table <- motus_final_taxa_metadata %>%
  filter(data_type == "METAG") %>%
  dplyr::select(mOTU, sampleid, counts) %>%
  group_by(sampleid) %>% 
  mutate(total=sum(counts)) %>% 
  filter(total > 2400) %>%  ##Here we just remove those with low counts
  dplyr::select(-total) %>% 
  ungroup() %>% 
  pivot_wider(names_from = sampleid, values_from = counts, values_fill = 0) %>% 
  column_to_rownames("mOTU") %>% 
  phyloseq::otu_table(taxa_are_rows = TRUE)
motus_taxa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  dplyr::select(mOTU, phylum, class, order, family, genus, species) %>% 
  unique() %>% 
  column_to_rownames("mOTU") %>% 
  as.matrix() %>%
  phyloseq::tax_table()
motus_sampledata <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  dplyr::select(-phylum, -class, -order, -family, -genus, -species, -counts, -mOTU, -domain) %>% 
  unique() %>%  
  column_to_rownames("sampleid") %>% 
  sample_data()

motus_sampledata$date = gsub("i", "y", motus_sampledata$date)

#Edit fraction for plot
motus_sampledata$sample_type = gsub("Heavy_fraction", "SI", motus_sampledata$sample_type)
motus_sampledata$sample_type = gsub("Light_fraction", "SU", motus_sampledata$sample_type)
motus_sampledata$sample_type = gsub("Free_living", "FL", motus_sampledata$sample_type)

#Reorder station km 
motus_sampledata$station_km = factor(motus_sampledata$station_km,
                          levels = c("633",
                                     "651",
                                     "665",
                                     "692",
                                     "713"))


#Reorder Dates
motus_sampledata$date = factor(motus_sampledata$date,
                          levels = c("May 21",
                                     "Jul 21",
                                     "Nov 21",
                                     "Feb 22",
                                     "May 22",
                                     "Jun 22",
                                     "Nov 22"))


#Create phyloseq object
bicest_motu_ps <- phyloseq(motus_table, motus_taxa, motus_sampledata)
bicest_motu_ps


#Clean up samples for the relevant ones
#genecat_LH_ps = subset_samples(genecat_pgene_abund_ko_annotsgenecat_ps, Sample_type!="Free_living")
#genecat_LH.ps = subset_samples(genecat_LH_ps, station_km > 613 & Sample_date!="Nov 21" )
bicest_motu_ps = subset_samples(bicest_motu_ps, station_km!="713" | date!="Jun 22")
bicest_motu_ps = subset_samples(bicest_motu_ps, date!="Nov 21")

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(bicest_motu_ps, method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.1846677

####Make plots ####

#Design plot
NMDS_mOTU.plt = plot_ordination(bicest_motu_ps, 
                             Gene.ord, 
                             color = "date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  stat_ellipse(aes(group = date, color = date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  #facet_grid(. ~ data_type)+
  geom_point(aes(size = 2, color = date), show.legend = F)+
  geom_text(aes(label = sample_type), size = 3, vjust = 1.8)+
  annotate("text", x=-1, y=1, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("mOTU NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_mOTU.plt

#png("Figures/DFG_Gene_METAG_NMDS.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

pdf("Figures/NMDS_mOTU.pdf", width = 11, height = 8)
NMDS_mOTU.plt
dev.off()

#saveRDS(NMDS_Gene.plt, "Figures/DFG_Gene_METAG_NMDS.RDS")

#Pairwise PERMANOVA - Sample_date
Sample_date_group = get_variable(bicest_motu_ps@sam_data, "date")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, Sample_date_group, nperm = 999, p.method = "bonferroni")
Depth_ado
# All are unique.

#Design plot
NMDS_Gene.plt = plot_ordination(bicest_motu_ps, 
                             Gene.ord, 
                             color = "station", 
                             shape = "date"
                             ) + 
  theme(legend.position = "right")+
  stat_ellipse(aes(group = station, color = station), lwd = 1)+
  geom_point(aes(size = 2, colour = station), show.legend = F)+
  scale_shape_manual("Sample Date", values = c(15,17, 16,18,25))+
  #scale_color_gradient2("Elbe km", 
   #                     low="green", 
    #                    mid="blue",
     #                   high="red", 
      #                  midpoint=680,
       #                 guide = "colourbar")+
  #facet_grid(. ~ data_type)+
  annotate("text", x=-0.15, y=0.2, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene.plt

#png("Figures/Gene_METAG_NMDS2.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

#Pairwise PERMANOVA - Stations
Station_group = get_variable(bicest_motu_ps@sam_data, "station")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, Station_group, nperm = 999, p.method = "bonferroni")
Depth_ado
#BB + MG, ML + TW, TW + ST = not significantly different, organised into two groups ML/TW/ST + BB/MG


#Design plot
NMDS_Gene.plt = plot_ordination(bicest_motu_ps, 
                             Gene.ord, 
                             color = "sample_type", 
                             shape = "station"
                             ) + 
  theme(legend.position = "right")+
  stat_ellipse(aes(group = sample_type, color = sample_type), lwd = 1)+
  scale_color_manual("Particle Fraction", values = cbbPalette)+
  scale_shape_manual("Elbe Station", values = Shape_list)+
  geom_point(aes(size = 2, color = sample_type), show.legend = F)+
  #facet_grid(. ~ data_type)+
  annotate("text", x=0.15, y=0.2, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene.plt

#png("Figures/Gene_METAG_NMDS3.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

#Pairwise PERMANOVA - fractions
fraction_group = get_variable(bicest_motu_ps@sam_data, "sample_type")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, fraction_group, nperm = 999, p.method = "bonferroni")
Depth_ado
#L and H are not significantly different



####Anosim, adonis, and permanova date tests####

#anosim
date_group = get_variable(bicest_motu_ps@sam_data, "date")
date_ano = anosim(phyloseq::distance(bicest_motu_ps, method = "bray"), date_group, distance = "bray")
date_ano$signif #0.001
date_ano$statistic #0.4927809
#Significant differences between group means - based on date

#Adonis
date_group = get_variable(bicest_motu_ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
date_ado = adonis2(Gene.dist ~ date_group)
date_ado
#Significant differences between group means and distribution - based on date
#R2 = 0.33742  
#p = 0.001

#Pairwise PERMANOVA
date_group = get_variable(bicest_motu_ps@sam_data, "date")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
date.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, date_group, nperm = 999, p.method = "bonferroni")
date.stat
#All are unique.


####Anosim and adonis station_km tests####

#anosim
station_km_group = get_variable(bicest_motu_ps@sam_data, "station")
station_km_ano = anosim(phyloseq::distance(bicest_motu_ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.001
station_km_ano$statistic #0.3334253
#Significant differences between group means - based on station_km

#Adonis
station_km_group = get_variable(bicest_motu_ps@sam_data, "station")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#Significant differences between group means and distribution - based on station_km
#R2 = 0.23603 
#p = 0.001

#Pairwise PERMANOVA
station_km_group = get_variable(bicest_motu_ps@sam_data, "station")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat
#Patterns exist in the station differences - all except last estuary stations are similar to previous and subsequent stations


####Anosim and adonis fraction tests####

#anosim
station_km_group = get_variable(bicest_motu_ps@sam_data, "sample_type")
station_km_ano = anosim(phyloseq::distance(bicest_motu_ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.001
station_km_ano$statistic #-0.1790517
#Significant differences between group means

#Adonis
station_km_group = get_variable(bicest_motu_ps@sam_data, "sample_type")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#Significant differences between group means and distribution - based on fraction
#R2 = 0.10712  
#p = 0.001

#Pairwise PERMANOVA
station_km_group = get_variable(bicest_motu_ps@sam_data, "sample_type")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat
#No significant particle fraction difference, FL is unique



```

#Transcripts per gene volcano plot 

```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "F:/Functional_R_analysis/moAClean_CO2CH4_OccurrenceFiltered_V2_TG.csv")

#amoAClean_CO2CH4_tbl_long = read.csv( "F:/Functional_R_analysis/moAClean_CO2CH4_OccurrenceFiltered_V2_TG.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)




####Run Statistical Fraction test####

#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG.df = CO2CH4_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "IncompleteMetagenome")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG.lng = gather(CO2CH4_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Extract list of genes
uniquegenes.ls = unique(CO2CH4_TG.lng$KO)
uniquegenes.ls

#Make results table for metagenome vs metatranscriptomes
Results_MT.df = data.frame(Gene = "DELETEME",
                        Sample_type.TranscriptsPerGenome = 9999,
                        Sample_type.r = tmp.m$statistic,
                        Sample_type.p = 9999)
#Make results table for LH
Results_LH.df = data.frame(Gene = "DELETEME",
                           Suspended.TranscriptsPerGenome = 9999,
                           Sinking.TranscriptsPerGenome = 9999,
                           Sample_type.r = tmp.m$statistic,
                           Sample_type.p = 9999)

i="K22213"
#Get significant differences between metagenomes and metatranscriptomes and then Suspended and Sinking particles
for (i in uniquegenes.ls) {
  print(paste0("Working on ", i, ". Number ", which(uniquegenes.ls == i), " out of ", length(uniquegenes.ls)))
  
  #Subset to only one KO entry
  tmp.sbst = subset(CO2CH4_TG.df, KO == i & Sample_date!="Nov 21")
  
  #Remove samples with missing metagenome information
  tmp.sbst$TranscriptsPerGenome = as.numeric(tmp.sbst$TranscriptsPerGenome)
  
  #Add more info - remove NA's and Infinite numbers
  tmp.sbst = tmp.sbst %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0))
  
  
  
  #Run significance test between metagenomes and metatranscriptome
  #Run mantel test
  test1 = vegdist(tmp.sbst$Metagenomes, method = "euclidean")
  test2 = vegdist(tmp.sbst$Transcriptomes, method = "euclidean")
  tmp.m = vegan::mantel(test1, test2)

  
  #Make temporary dataframe with results
  tmp.res = data.frame(Gene = paste0(i),
                       Sample_type.TranscriptsPerGenome = mean(tmp.sbst$TranscriptsPerGenome, na.rm = T),
                       Sample_type.r = tmp.m$statistic,
                       Sample_type.p = tmp.m$signif)
  
  
  Results_MT.df = rbind(Results_MT.df, tmp.res)
  
  
  
  
  
  #Run significance test between suspended and sinking particles
  
  #Separate into suspended and sinking particles
  tmp.l = subset(tmp.sbst, Sample_type == "Light_fraction")
  tmp.h = subset(tmp.sbst, Sample_type == "Heavy_fraction")
  #Subset for dataframes to match
  tmp.l = subset(tmp.l, BioSample!= "SAMEA110290340" & BioSample!= "SAMEA112714817")
  tmp.h = subset(tmp.h, BioSample!= "SAMEA112714807")
  
  #tmp.l[,c(1,7,11,14,25,29:32)]
  #tmp.h[,c(1,7,11,14,25,29:32)]
  print(paste0("Suspended particles have ", dim(tmp.l)[1], " samples, and sinking have ",  dim(tmp.h)[1]))
  
  #Run mantel test
  test1 = vegdist(tmp.l$TranscriptsPerGenome, method = "euclidean")
  test2 = vegdist(tmp.h$TranscriptsPerGenome, method = "euclidean")
  tmp.m = vegan::mantel(test1, test2)

  #print("Test")
  
  #Make temporary dataframe with results
  tmp.res = data.frame(Gene = paste0(i),
                       Suspended.TranscriptsPerGenome = mean(tmp.l$TranscriptsPerGenome, na.rm = T),
                       Sinking.TranscriptsPerGenome = mean(tmp.h$TranscriptsPerGenome, na.rm = T),
                       Sample_type.r = tmp.m$statistic,
                       Sample_type.p = tmp.m$signif)
  
  
  Results_LH.df = rbind(Results_LH.df, tmp.res)
  
}
#Check results and clean up dataframe
Results_MT.df = Results_MT.df[-1,]
Results_MT.df
Results_LH.df = Results_LH.df[-1,]
Results_LH.df

#Subset to only significant gene hits
Results_SignMT.df = subset(Results_MT.df, Sample_type.p < 0.05)
dim(Results_SignMT.df)
Results_SignLH.df = subset(Results_LH.df, Sample_type.p < 0.05)
dim(Results_SignLH.df)

#For record keeping
#write.csv(Results_SignMT.df, "F:/Functional_R_analysis/Significant_GTdiff_MT.csv")
Results_SignMT_MT.df = read.csv("E:/Functional_R_analysis/Significant_GTdiff_MT.csv", row.names = 1)
#write.csv(Results_SignLH.df, "F:/Functional_R_analysis/Significant_LHdiff_MT.csv")
Results_SignLH_MT.df = read.csv("E:/Functional_R_analysis/Significant_LHdiff_MT.csv", row.names = 1)



#### Make plot ####
Results_SignLH_MT.df = read.csv("F:/Functional_R_analysis/Significant_LHdiff_MT.csv", row.names = 1)

#Subset to top 25 and check it worked
Top25_Fraction.df = Results_SignLH_MT.df %>% filter(Sample_type.r > quantile(Sample_type.r, 0.81))
dim(Top25_Fraction.df)

Top25_Fraction.df

#Add calculation for better context
Top25_Fraction.df$Diff = Top25_Fraction.df$Suspended.TranscriptsPerGenome / Top25_Fraction.df$Sinking.TranscriptsPerGenome

test = Top25_Fraction.df %>%
  left_join(annot, by = c("Gene" = "KO"), relationship = "many-to-many") %>% # add gene information
  distinct() %>% #remove duplicate rows
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) #separate description


dim(test)
dim(Top25_Fraction.df)

# Plot preferences
Top25_Fraction_MT.plt = ggplot(test, aes(x=Diff, y=Sample_type.r, colour=Sample_type.p, label = SName)) + 
  geom_point(size = 3) +
  scale_colour_gradient2("p value", low= "green", mid = "black", high = "magenta", na.value = "red")+
  ggrepel::geom_label_repel(aes(fill = "KILLME")) +
  scale_fill_manual(values = "white")+
  ggtitle("CO2/CH4 particle transcripts per gene differences")+
  ylab("Mantel R value")+
  xlab("Suspended / Sinking Transcripts per Gene")+
  geom_vline(xintercept = 1)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+ 
  guides(fill="none")
# visualise
Top25_Fraction_MT.plt

#Save plots
pdf("F:/Functional_R_analysis/Figures/CO2CH4_MT_IndivGenes.pdf", width = 8, height = 7)
Top25_Fraction_MT.plt
dev.off()

png("F:/Functional_R_analysis/Figures/CO2CH4_MT_IndivGenes.png", width = 8, height = 7, units = "in", res = 120)
Top25_Fraction_MT.plt
dev.off()

saveRDS(Top25_Fraction_MT.plt, "F:/Functional_R_analysis/Figures/CO2CH4_MT_IndivGenes.RDS")


#### Make plot with only top 5 ####
Results_SignLH_MT.df = read.csv("F:/Functional_R_analysis/Significant_LHdiff_MT.csv", row.names = 1)

#Subset to top 25 and check it worked
Top5_Fraction.df = Results_SignLH_MT.df %>% filter(Sample_type.r > quantile(Sample_type.r, 0.81))
dim(Top25_Fraction.df)

Top5_Fraction.df

#Add calculation for better context
Top5_Fraction.df$Diff = Top5_Fraction.df$Suspended.TranscriptsPerGenome / Top5_Fraction.df$Sinking.TranscriptsPerGenome



test = Top5_Fraction.df %>%
  left_join(annot, by = c("Gene" = "KO"), relationship = "many-to-many") %>% # add gene information
  distinct() %>% #remove duplicate rows
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) #separate description

test = subset(test, Gene == "K01571" | Gene == "K10674"| Gene == "K00161"| Gene == "K20370"| Gene == "K19071"| Gene == "K10944" | Gene == "K01608")

dim(test)
dim(Top25_Fraction.df)

# Plot preferences
Top5_Fraction_MT.df = ggplot(test, aes(x=Diff, y=Sample_type.r, colour=Sample_type.p, label = SName)) + 
  geom_point(size = 3) +
  scale_colour_gradient2("p value", low= "green", mid = "black", high = "magenta", na.value = "red")+
  ggrepel::geom_label_repel(aes(fill = "KILLME")) +
  scale_fill_manual(values = "white")+
  ggtitle("CO2/CH4 LH particle transcripts per gene differences")+
  ylab("Mantel R value")+
  xlab("Suspended / Sinking Transcripts per Gene")+
  geom_vline(xintercept = 1)+
  My_Theme+
  #theme(axis.text.x = element_text(angle = 90, hjust = 0.5))+ 
  guides(fill="none")
# visualise
Top25_Fraction_MT.df 

png("F:/Functional_R_analysis/Figures/DFG_CO2CH4_MT_IndivGenes.png", width = 6, height = 5, units = "in", res = 120)
Top5_Fraction_MT.df
dev.off()

pdf("F:/Functional_R_analysis/Figures/DFG_CO2CH4_MT_IndivGenes.pdf", width = 6, height = 5)
Top5_Fraction_MT.df
dev.off()

saveRDS(Top25_Fraction_MT.df)
 
```

Sinking high abundance
poxB control of acetate production under aerobic conditions (Lorquet et al., 2004)  - upregulated in response to general stress (Weber et al., 2005)
ectD is required for the main ectoine hydroxylase activity in C. salexigens. â stress response to temperature and salt (GarcÃ­a-Estepa et al., 2006)
pdhA - cetyl-CoA and CO(2), and provides the primary link between glycolysis and the tricarboxylic acid (TCA) cycle, and is therefore essential to cell growth (Spalding & Prigge, 2010)
	strongly inhibited under anaerobic conditions (Lorquet et al., 2004)
	Upregulated under nutrient starvation conditions (Betts et al., 2002)
gcl is the enzyme for the rate-limiting step of synthesising glutathione, a compound vital for cell survival, as it acts as a cellular antioxidant (Sigler et al., 1999; H. Zhang et al., 2020)
fdhA produces methane from formate and other substrates and is therefore located in methanogens, but expression is controlled by H2 concentrations rather than formate (Wood et al., 2003)

Suspended high abundance
oorB is part of the central energy metabolism pathway (TCA/Glycolysis/gluconeogenesis) - downregulated under hyperosmotic stress (Cameron et al., 2012) - so things are good in this case 
oadA plays a crucial role in citrate utilisation and fermentation pathways - expression requires anaerobic conditions, and the presence of Na+ and citrate (Bott et al., 1995; Meyer et al., 1997)
pmoA is a large component of the methane metabolism pathway and represent a large methane sink in the ecosystem - regulated by CH4 abundance (RodrÃ­guez et al., 2019)
Pepck â glucose production (gluconeogenesis) and produces CO2 - decreased expression during DNA damage events (Kim et al., 2011)
Fdh â reversible formate <-> CO2, de novo nucleotide (purine) biosynthesis, produces methane from formate and other substrates and is therefore located in methanogens, but expression is controlled by H2 concentrations rather than formate (Wood et al., 2003)

#Metagenomes volcano plot


```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG' & Sample_type!="Free_living") %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)

dim(amoAClean_CO2CH4_tbl_long)


####Run Statistical Fraction test####


#Extract list of genes
uniquegenes.ls = unique(amoAClean_CO2CH4_tbl_long$KO)
uniquegenes.ls

#Make results table for metagenome L vs H
Results_LH.df = data.frame(Gene = "DELETEME",
                           Suspended.Metagenomes = 9999,
                           Sinking.Metagenomes = 9999,
                           Sample_type.r = tmp.m$statistic,
                           Sample_type.p = 9999)

i="K01576"
#Get significant differences between metagenomes and metatranscriptomes and then Suspended and Sinking particles
for (i in uniquegenes.ls) {
  print(paste0("Working on ", i, ". Number ", which(uniquegenes.ls == i), " out of ", length(uniquegenes.ls)))
  
  #Subset to only one KO entry
  tmp.sbst = subset(amoAClean_CO2CH4_tbl_long, KO == i & Sample_date!="Nov 21")
  
  #ENsure counts are numeric
  tmp.sbst$counts = as.numeric(tmp.sbst$counts)
  
  #Add more info - remove NA's and Infinite numbers
  tmp.sbst = tmp.sbst %>%
  mutate_at(c("counts"), ~replace(., is.na(.), 0))
  
  
  
  #Run significance test between suspended and sinking particles
  
  #Separate into suspended and sinking particles
  tmp.l = subset(tmp.sbst, Sample_type == "Light_fraction")
  tmp.h = subset(tmp.sbst, Sample_type == "Heavy_fraction")
  #Subset for dataframes to match
  tmp.l = subset(tmp.l, BioSample!= "SAMEA110290340" & BioSample!= "SAMEA112714817")
  tmp.h = subset(tmp.h, BioSample!= "SAMEA112714807")
  
  #tmp.l[,c(1,7,11,14,25,29:32)]
  #tmp.h[,c(1,7,11,14,25,29:32)]
  #print(paste0("Suspended particles have ", dim(tmp.l)[1], " samples, and sinking have ",  dim(tmp.h)[1]))
  
  #Run mantel test
  test1 = vegdist(tmp.l$counts, method = "euclidean")
  test2 = vegdist(tmp.h$counts, method = "euclidean")
  tmp.m = vegan::mantel(test1, test2)

  #print("Test")
  
  #Make temporary dataframe with results
  tmp.res = data.frame(Gene = paste0(i),
                       Suspended.Metagenomes = mean(tmp.l$counts, na.rm = T),
                       Sinking.Metagenomes = mean(tmp.h$counts, na.rm = T),
                       Sample_type.r = tmp.m$statistic,
                       Sample_type.p = tmp.m$signif)
  
  
  Results_LH.df = rbind(Results_LH.df, tmp.res)
  
}
#Check results and clean up dataframe
Results_LH.df = Results_LH.df[-1,]
Results_LH.df

#Subset to only significant gene hits
Results_SignLH.df = subset(Results_LH.df, Sample_type.p < 0.05)
dim(Results_SignLH.df)

#For record keeping
#write.csv(Results_SignLH.df, "F:/Functional_R_analysis/Significant_LHdiff_MG.csv")




####Make Gene plot ####

Results_SignLH_MG.df = read.csv("E:/Functional_R_analysis/Significant_LHdiff_MG.csv", row.names = 1)
dim(Results_SignLH_MG.df)

Top25_Fraction.df = Results_SignLH_MG.df %>% filter(Sample_type.r > quantile(Sample_type.r, 0.90))
dim(Top25_Fraction.df)

ggplot(Top25_Fraction.df, aes(y = -log10(Sample_type.p), x = log2(Sample_type.r)))+
  geom_point()

#Add calculation for better context
Top25_Fraction.df$Diff = Top25_Fraction.df$Suspended.Metagenomes / Top25_Fraction.df$Sinking.Metagenomes

test = Top25_Fraction.df %>%
  left_join(annot, by = c("Gene" = "KO"), relationship = "many-to-many") %>% # add gene information
  distinct() %>% #remove duplicate rows
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) #separate description

dim(test)
dim(Top25_Fraction.df)

# Plot preferences
Top25_Fraction_MG.df = ggplot(test, aes(x=Diff, y=Sample_type.r, colour=Sample_type.p, label = SName)) + 
  geom_point(size = 3) +
  scale_colour_gradient2("p value", low= "green", mid = "black", high = "magenta", na.value = "red")+
  ggrepel::geom_label_repel(aes(fill = "KILLME")) +
  scale_fill_manual(values = "white")+
  ggtitle("CO2/CH4 LH particle metagenome differences")+
  ylab("Mantel R value")+
  xlab("Suspended / Sinking Gene Abundance")+
  My_Theme+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+ 
  guides(fill="none")
# visualise
Top25_Fraction_MG.df 

#Save plots
pdf("E:/Functional_R_analysis/Figures/CO2CH4_MG_IndivGenes.pdf", width = 8, height = 7)
Top25_Fraction_MG.df
dev.off()

png("E:/Functional_R_analysis/Figures/CO2CH4_MG_IndivGenes.png", width = 8, height = 7, units = "in", res = 120)
Top25_Fraction_MG.df
dev.off()



 
```
sinking particles, 
rbcL (chloroplast gene, involved in photosynthesis and usually in chloroplast DNA (Klein et al., 1994; Nurhasanah et al., 2019)), 
pheC (phenylalanine biosynthesis and upregulated under cold tolerant conditions (Cheng et al., 2023; Zhao et al., 1992)), 
csiD (only expressed under carbon starvation conditions (Marschall et al., 1998)), 
oadA (upregulated in response to citrate and essential for its uptake (Blancato et al., 2008; Repizo et al., 2013)) - expression requires anaerobic conditions, and the presence of Na+ and citrate (Bott et al., 1995; Meyer et al., 1997)
DDC (converts tryptophan to tryptamine, linking primary and secondary metabolic pathways (Goddijn et al., 1994))  
Suspended particles 
ubiA (ubiquinone biosynthesis that expresses under stress conditions, specifically low oxygen and carbon (Suzuki et al., 1994)), 
alsD (internal cell pH buffering (Renna et al., 1993)), 
bioU (biotin production, and essential carboxylation, decarboxylation, and transcarboxylation cofactor (Sirithanakorn & Cronan, 2021)), 
menA (menaquinone biosynthesis, important for anaerobic electron transport systems (Suvarna et al., 1998)), and 
GGCX (the only known vitamin K post-translational modification, produces Î³-carboxyglutamate, a vital precursor to many proteins including those involved in cellular growth, survival, and signalling (Shearer & Newman, 2014; Shearer & Okano, 2018)). 

#Physicochemical heatmap and small plots
```{r Set up physicochemical plot}


#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("E:/Functional_R_analysis/PhysicochemicalParameters_mod2.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Make relevant columns numeric
#Physicochem.df = Physicochem.df %>% mutate_at(c('SPM_mgperL', 'POC_mgperL'), as.numeric)
Physicochem.df$SPM_mgperL = as.numeric(Physicochem.df$SPM_mgperL)
Physicochem.df$POC_mgperL = as.numeric(Physicochem.df$POC_mgperL)
Physicochem.df$PTC_mgperL = as.numeric(Physicochem.df$PTC_mgperL)
Physicochem.df$PTN_mgperL = as.numeric(Physicochem.df$PTN_mgperL)
Physicochem.df$PTH_mgperL = as.numeric(Physicochem.df$PTH_mgperL)
Physicochem.df$TEP_um2perL = as.numeric(Physicochem.df$TEP_um2perL)
Physicochem.df$CSP_um2perL = as.numeric(Physicochem.df$CSP_um2perL)
Physicochem.df$ParticleArea_um2perL = as.numeric(Physicochem.df$ParticleArea_um2perL)


#Add PA PP to Free-living rows 

#Extract sample numbers for FL - MG
FL_samples.df = Physicochem.df %>%
  filter(Sample_type == "Free_living")
PA_PP.ls = c("SPM_mgperL", "POC_mgperL", "PTC_mgperL", "PTN_mgperL", "PTH_mgperL", "TEP_um2perL", "CSP_um2perL", "ParticleArea_um2perL")
count = 1
i=92
x="TEP_um2perL"
for (i in 1:length(Physicochem.df$Associatednumber)) {
  if (grepl(Physicochem.df$Sample_type[i], "Free_living") == T ) {
    #Bug hunting
    #print(paste0("Match ",count, " found"))
    PA_sub.df = subset(Physicochem.df, Sample_type!="Free_living" & 
                         station_km == Physicochem.df$station_km[i] & 
                         Sample_date == Physicochem.df$Sample_date[i])
    for (x in PA_PP.ls) {
      
      print(x)
      #Bug hunting
      #print(paste0("Matching ", x))
      mean.tmp = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
      #Bug hunt
      print(paste0("Getting ", mean.tmp))
      Physicochem.df[i,x] = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
    }
    count = count + 1
  }
}

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DOC_uM.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

colnames(PP_totest.df)
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% 
  dplyr::select(all_of(PP_totest.ls))

#Make sure rownames have been preserved
rownames(PP_totest.df)
dim(PP_totest.df)


#Apply row numbers from sample IDs
rownames(PP_totest.df) = PP_totest.df$Associatednumber
PP_totest.df$Associatednumber = NULL


#Add density data - calculated from dry-weight and area
PP_totest.df$Density_mgperL_um2perL = (as.numeric(PP_totest.df$SPM_mgperL) / (as.numeric(PP_totest.df$ParticleArea_um2perL))) * 10^5

Physicochem.df = PP_totest.df

Physicochem.df = sapply(Physicochem.df, as.numeric)
```
##Temperature plot
```{r}

####Set up ####
#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("E:/Functional_R_analysis/PhysicochemicalParameters_mod.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM."]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("E:/Functional_R_analysis/PhysicochemicalParameters_mod.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM."]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

####Focus on temperature####
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% select(all_of(PP_totest.ls)) %>%
  select(Sample_date, station_km, Temperature_TBDHereon, Salinity_PSU) %>%
  distinct()
dim(PP_totest.df)

#Convert relevant columns to numeric
PP_totest.df[,c(2:4)] = as.data.frame(sapply(PP_totest.df[,c(2:4)], as.numeric))

PP_totest.df$Sample_date = factor(PP_totest.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))

Temperature.plt = ggplot(PP_totest.df, aes(x = station_km, y = Temperature_TBDHereon, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth(se = F) +
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab("Temperature (Â°C)")
Temperature.plt

cor.test(PP_totest.df$Temperature_TBDHereon, PP_totest.df$station_km, method = "s")
cor.test(PP_totest.df$Temperature_TBDHereon, PP_totest.df$Salinity_PSU, method = "s")

tmp.aov = aov(Temperature_TBDHereon ~ station_km, data = PP_totest.df)
summary(tmp.aov)
lsr::etaSquared(tmp.aov)
tmp.aov = aov(Temperature_TBDHereon ~ Sample_date, data = PP_totest.df)
summary(tmp.aov)
lsr::etaSquared(tmp.aov)

tmp.aov = aov(Temperature_TBDHereon ~ station_km * Sample_date, data = PP_totest.df)
  
summary(tmp.aov)
  
tmp.eta2 = lsr::etaSquared(tmp.aov)
tmp.eta2


png("E:/Functional_R_analysis/Figures/Temperature.png", units = "in", width = 8, height = 5, res = 120)
Temperature.plt
dev.off()

```
##Turbidity plot
```{r}

####Set up ####
#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("F:/Functional_R_analysis/PhysicochemicalParameters_mod.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM."]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

####Focus on Turbidity ####
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% select(all_of(PP_totest.ls)) %>%
  select(Sample_date, station_km, Turbidity_NTU, Salinity_PSU) %>%
  distinct()
dim(PP_totest.df)

#Convert relevant columns to numeric
PP_totest.df[,c(2:4)] = as.data.frame(sapply(PP_totest.df[,c(2:4)], as.numeric))

PP_totest.df$Sample_date = factor(PP_totest.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))

Turbidity.plt = ggplot(PP_totest.df, aes(x = station_km, y = Turbidity_NTU, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth(se = F) +
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab("Turbidity (NTU)")
Turbidity.plt


```
##o2 plot
```{r}

####Set up ####
#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("F:/Functional_R_analysis/PhysicochemicalParameters_mod.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM."]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

####Focus on temperature####
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% select(all_of(PP_totest.ls)) %>%
  select(Sample_date, station_km, O2_uM, Salinity_PSU) %>%
  distinct()
dim(PP_totest.df)

#Convert relevant columns to numeric
PP_totest.df[,c(2:4)] = as.data.frame(sapply(PP_totest.df[,c(2:4)], as.numeric))

PP_totest.df$Sample_date = factor(PP_totest.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))

O2_uM.plt = ggplot(PP_totest.df, aes(x = station_km, y = O2_uM, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth(se = F) +
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab(expression("Dissolved O"[2]~"(ÂµM)"))
O2_uM.plt


```
##Salinity plot
```{r}

####Set up ####
#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("E:/Functional_R_analysis/PhysicochemicalParameters_mod.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM."]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

####Focus on turbidity####
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% select(all_of(PP_totest.ls)) %>%
  select(Sample_date, station_km, Salinity_PSU) %>%
  distinct()
dim(PP_totest.df)

#Convert relevant columns to numeric
PP_totest.df[,c(2:3)] = as.data.frame(sapply(PP_totest.df[,c(2:3)], as.numeric))

PP_totest.df$Sample_date = factor(PP_totest.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))

Salinity.plt = ggplot(PP_totest.df, aes(x = station_km, y = Salinity_PSU, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth(se = F) +
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab("Salinity (PSU)")
Salinity.plt



tmp.aov = aov(Salinity_PSU ~ station_km, data = PP_totest.df)
summary(tmp.aov)
lsr::etaSquared(tmp.aov)
tmp.aov = aov(Salinity_PSU ~ Sample_date, data = PP_totest.df)
summary(tmp.aov)
lsr::etaSquared(tmp.aov)

```
##Combine small plots

```{r}

SalTurbO2Temp.plt = ggarrange(Salinity.plt,  Turbidity.plt,
          O2_uM.plt, Temperature.plt,
          common.legend = T,
          legend = "right")
SalTurbO2Temp.plt

png("F:/Functional_R_analysis/Figures/SalTurbO2Temp.png", units = "in", width = 8, height = 5, res = 120)
SalTurbO2Temp.plt
dev.off()

```


##Heatmap generation
```{r}
#Make results dataframe
Results_PPvsPP.df = data.frame(Var1 = as.character("DELETEME"),
                        Var2 = as.character("DELETEME"),
                        p.value = as.numeric(9999999),
                        rho.value = as.numeric(9999999))
Results_PPvsPP.df = subset(Results_PPvsPP.df, Var1!= "dCH4_uM")
#Run comparison tests
i=8
x=8
count = 1
for (i in 1:ncol(Physicochem.df)) {
  #print(paste0("The first PP variable is ", colnames(Physicochem.df)[i]))
  
  for (x in 1:ncol(Physicochem.df)) {
  #print(paste0("PP2 is ", colnames(Physicochem.df)[x]))
    
    if (grepl(colnames(Physicochem.df)[i], "Silicate_mg.L") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "Silicate_mg.L") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "dCH4_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "dCH4_nM") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "dCO2_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "dCO2_nM") == T |
        grepl(colnames(Physicochem.df)[i], "dCH4_uM") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "dCH4_nM") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "dCO2_uM") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "dCO2_nM") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T ) {
          
  print(paste0("Error with: i = ", colnames(Physicochem.df)[i] ," & x = ", colnames(Physicochem.df)[x]))
          
} else {
  
  
    #Convert to dataframe
    PP1.tmp <- as.data.frame(Physicochem.df[,i])
    PP2.tmp <- as.data.frame(Physicochem.df[,x])
    
    
    #Make PP dissimilarity matrix
    PP1.dist = dist(PP1.tmp)
    PP2.dist = dist(PP2.tmp)
    
    #Run mantel test
    test.tmp = vegan::mantel(PP1.dist, PP2.dist, method = "pearson", permutations = 999, na.rm = TRUE) # we are looking for linear relationships, so we use a pearson instead of a spearman test (which also includes more complex monotonic relationships)
  
    tmp.df = data.frame(Var1 = colnames(Physicochem.df)[i],
                        Var2 = colnames(Physicochem.df)[x],
                        p.value = as.numeric(test.tmp$signif),
                        rho.value = as.numeric(test.tmp$statistic))
    
    Results_PPvsPP.df = rbind(Results_PPvsPP.df, tmp.df)
  
}
    count = count + 1
    
  print(paste0("Completed ", count, " out of ", ncol(Physicochem.df)^2, " physicochemical parameters, which is ", round(count/(ncol(Physicochem.df)^2)*100, digits = 2), "%"))
  
  }  
  
}


#Remove initial row with DELETEME
Results_PPvsPP.df = Results_PPvsPP.df[-1,]

#Remove self comparisons
Results_PPvsPP.df = Results_PPvsPP.df %>% 
  as_tibble() %>% 
  mutate(duplicates = if_else(Var1 == Var2,
                              TRUE,
                              FALSE)) %>% 
  filter(duplicates == FALSE)

#Select only significant interactions
Results_PPvsPP_sign.df = subset(Results_PPvsPP.df, p.value < 0.05)

#Add Density to both Var1 and Var2, as nothing was significant
Results_PPvsPP_sign.df = 	rbind(Results_PPvsPP_sign.df, list('Density_mgperL_um2perL', 'Density_mgperL_um2perL', 0, 0, FALSE))


Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="dCH4_uM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="dCH4_uM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="dCO2_nM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="dCO2_nM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="PTH_mgperL")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="PTH_mgperL")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="Sat_O2_Perc")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="Sat_O2_Perc")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="Total_DIN_uM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="Total_DIN_uM")

#For adjusting code
#colnames(Results_PPvsPP_sign.df)
#colnames(Results_PPvsPP_sign.df) = c("Var1", "Var2", "p.value", "rho.value", "duplicates")

#Change variable names for nice plots
Results_PPvsPP_sign.df$Var1 = gsub("station_km", "Elbe km", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Salinity_PSU", "Salinity (PSU)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Temperature_TBDHereon", "Temperature (Â°C)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("dCO2_uM", "dCO2 (ÂµM)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("dCH4_nM", "dCH4 (nM)", Results_PPvsPP_sign.df$Var1)

Results_PPvsPP_sign.df$Var1 = gsub("O2_uM", "dO2 (ÂµM)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Turbidity_NTU", "Turbidity (NTU)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("PTC_mgperL", "PTC (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("SPM_mgperL", "Dry-weight (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("POC_mgperL", "POC (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("DOC_mg.L", "DOC (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("DIC_mg.L", "DIC (mg L-1)", Results_PPvsPP_sign.df$Var1)

Results_PPvsPP_sign.df$Var1 = gsub("PTN_mgperL", "PTN (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("TN_mg.L", "DTN (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Ammonium_mg.L", "NH4+ (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Nitrite_mg.L", "NO2- (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Nitrate_mg.L", "NO3- (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Silicate_mg.L", "Si (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("TotalDissolvedPhosphate_mg.L", "DP (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("SRP_mgperL", "SRP (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("TEP_um2perL", "TEP (Âµm2 L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("CSP_um2perL", "CSP (Âµm2 L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Density_mgperL_um2perL", "Density (mgL-1 Âµm2L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("ParticleArea_um2perL", "Particle area (um2 L-1)", Results_PPvsPP_sign.df$Var1)

#Change variable names for nice plots
Results_PPvsPP_sign.df$Var2 = gsub("station_km", "Elbe km", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Salinity_PSU", "Salinity (PSU)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Temperature_TBDHereon", "Temperature (Â°C)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("dCO2_uM", "dCO2 (ÂµM)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("dCH4_nM", "dCH4 (nM)", Results_PPvsPP_sign.df$Var2)

Results_PPvsPP_sign.df$Var2 = gsub("O2_uM", "dO2 (ÂµM)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Turbidity_NTU", "Turbidity (NTU)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("PTC_mgperL", "PTC (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("SPM_mgperL", "Dry-weight (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("POC_mgperL", "POC (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("DOC_mg.L", "DOC (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("DIC_mg.L", "DIC (mg L-1)", Results_PPvsPP_sign.df$Var2)

Results_PPvsPP_sign.df$Var2 = gsub("PTN_mgperL", "PTN (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("TN_mg.L", "DTN (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Ammonium_mg.L", "NH4+ (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Nitrite_mg.L", "NO2- (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Nitrate_mg.L", "NO3- (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Silicate_mg.L", "Si (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("TotalDissolvedPhosphate_mg.L", "DP (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("SRP_mgperL", "SRP (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("TEP_um2perL", "TEP (Âµm2 L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("CSP_um2perL", "CSP (Âµm2 L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Density_mgperL_um2perL", "Density (mgL-1 Âµm2L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("ParticleArea_um2perL", "Particle area (um2 L-1)", Results_PPvsPP_sign.df$Var2)


#Reorder for easy interpretation
levelsVar1 = c(
  "CSP (Âµm2 L-1)",
  "TEP (Âµm2 L-1)",
  "Si (mg L-1)","SRP (mg L-1)",
  "DP (mg L-1)",
  "pH",
  "NO3- (mg L-1)",
  "NO2- (mg L-1)",
  "NH4+ (mg L-1)",
  "DTN (mg L-1)",
  "PTN (mg L-1)",
  "dO2 (ÂµM)",
  "dCH4 (nM)",
  "dCO2 (ÂµM)",
  "DIC (mg L-1)",
  "DOC (mg L-1)",
  "POC (mg L-1)",
  "PTC (mg L-1)",
  "Density (mgL-1 Âµm2L-1)",
  "Particle area (um2 L-1)",
  "Dry-weight (mg L-1)",
  "Turbidity (NTU)",
  "Temperature (Â°C)",
  "Salinity (PSU)",
  "Elbe km"
  )

# Assuming filtered_cov is your data frame
# Convert Var1 and Var2 to factors with the same levels
#levels <- unique(c(Results_PPvsPP_sign.df$Var1, Results_PPvsPP_sign.df$Var2))
Results_PPvsPP_sign.df <- Results_PPvsPP_sign.df %>%
  mutate(Var1 = factor(Var1, levels = levelsVar1),
         Var2 = factor(Var2, levels = levelsVar1))

# Filter the data to keep only the lower triangle
filtered_cov_lower <- Results_PPvsPP_sign.df %>%
  filter(as.numeric(Var1) <= as.numeric(Var2))

#Make rho value heatmap
Physico_rhovalue.plt = ggplot(Results_PPvsPP_sign.df, aes(x = Var1, y = Var2, fill = rho.value))+
  geom_tile()+
  geom_text(aes(label = ifelse(p.value > 0.05, "", 
                               ifelse(p.value > 0.01, "*", 
                                      ifelse(p.value > 0.001, "**", 
                                             ifelse(p.value <= 0.001, "***", ""))))),
            size = 20 / .pt,
            colour = "black")+
  scale_fill_gradient2("Pearson Correlation", low = "navy", mid = "white", high = "red", midpoint = 0)+ 
  scale_x_discrete(
    expand = expansion(mult = c(0,0)), guide = guide_axis(angle = 90),
    position = "top",
    limits = rev
  )+
  scale_y_discrete(
    expand = expansion(mult = c(0,0)),
    position = "right"
  )+
  xlab("Physicochemical parameters") + 
  ylab("Physicochemical parameters")+
  My_Theme
Physico_rhovalue.plt


pdf("E:/Functional_R_analysis/Figures/Physicochem_heatmap_pearson_mod.pdf", width = 14, height = 10)
Physico_rhovalue.plt 
dev.off()

#Cut off for very strong relationships is >0.8 according to Chan YH. Biostatistics 104: correlational analysis. Singapore Med J. 2003 Dec;44(12):614-9. PMID: 14770254.
#Subset to this
#Results_sign_VS.df = subset(Results_sign.df[,-5], rho.value > 0.8 | rho.value < -0.8)

#Extract dataframe to identify representative physicochemical paremeters
#write.csv(Results_sign_VS.df, "Physicochem_Pearson.csv")
```


##Identify significantly correlated parameters for later species, functional potential, and transcript per gene correlation analyses
```{r}
#Extract the individual physicochemical parameters that have to be used - for later 
Networked.ls = paste0(Results_sign_VS.df$Var1)

Networked_unique.ls = unique(Networked.ls)

#Extract the individual physicochemical parameters that have to be used
NonNetworked.ls = unique(paste0(Results.df$Var1))

NonNetworked_unique.ls = unique(NonNetworked.ls)


```
##Plot dCO2, dCH4, and dO2
```{r}


#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("E:/Functional_R_analysis/PhysicochemicalParameters_mod.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM."]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

#Extract relevant columns
PP_totest.df = Physicochem.df  %>% 
  dplyr::select(all_of(PP_totest.ls)) %>%
  dplyr::select(Sample_date, station_km, O2_uM, dCO2_uM, dCH4_nM, Salinity_PSU) %>%
  distinct()
dim(PP_totest.df)

#Convert relevant columns to numeric
PP_totest.df[,c(2:6)] = as.data.frame(sapply(PP_totest.df[,c(2:6)], as.numeric))

PP_totest.df$Sample_date = factor(PP_totest.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))

CO2.plt = ggplot(PP_totest.df, aes(x = station_km, y = dCO2_uM, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth() +
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab(expression("Dissolved CO"[2]~"(ÂµM)"))

cor.test(PP_totest.df$dCO2_uM, PP_totest.df$station_km, method = "s")
cor.test(PP_totest.df$dCO2_uM, PP_totest.df$Salinity_PSU, method = "s")


CH4.plt = ggplot(PP_totest.df, aes(x = station_km, y = dCH4_nM, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth() +
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab(expression("Dissolved CH"[4]~"(nM)"))

cor.test(PP_totest.df$dCH4_nM, PP_totest.df$station_km, method = "s")
cor.test(PP_totest.df$dCH4_nM, PP_totest.df$Salinity_PSU, method = "s")


O2.plt = ggplot(PP_totest.df, aes(x = station_km, y = O2_uM, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth() +
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab(expression("Dissolved O"[2]~"(ÂµM)"))
O2.plt

cor.test(PP_totest.df$O2_uM, PP_totest.df$station_km, method = "s")
cor.test(PP_totest.df$O2_uM, PP_totest.df$Salinity_PSU, method = "s")

O2dC02dCH4.plt = ggpubr::ggarrange(O2.plt, CO2.plt, CH4.plt,
          common.legend = T,
          legend = "right")
O2dC02dCH4.plt

pdf("E:/Functional_R_analysis/Figures/O2dCO2dCH4.pdf", width = 8, height = 6)
O2dC02dCH4.plt
dev.off()


cor.test(PP_totest.df$O2_uM, PP_totest.df$Salinity_PSU, method = "s")
cor.test(PP_totest.df$dCO2_uM, PP_totest.df$station_km, method = "s")


####For funsies####


PP_totest.df$O2plusCO2 = PP_totest.df$dCO2_uM - PP_totest.df$O2_uM 

O2plusCO2.plt = ggplot(PP_totest.df, aes(x = station_km, y = O2plusCO2, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth() +
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab(expression("Dissolved O"[2]~"(ÂµM)"))
O2plusCO2.plt


```
#Physicochemical to KO
##Set up physicochemical characteristics
```{r}

#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("F:/Functional_R_analysis/PhysicochemicalParameters_mod.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DOC_uM.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

colnames(PP_totest.df)
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% select(all_of(PP_totest.ls))

#Make sure rownames have been preserved
rownames(PP_totest.df)
dim(PP_totest.df)

#Extract water specific parameters
PP_water.df = PP_totest.df %>%
  subset(Sample_type == "Free_living") %>%
  select(-SPM_mgperL, -TEP_um2perL, -CSP_um2perL, -PTC_mgperL , -POC_mgperL, -PTN_mgperL, -Sample_type) %>%
  distinct()
#Extract particle specific parameters
PP_particle.df = PP_totest.df %>%
  subset(Sample_type!="Free_living") %>%
  select(Associatednumber, PTC_mgperL, POC_mgperL, PTN_mgperL, SPM_mgperL, TEP_um2perL, CSP_um2perL, -Sample_type) %>%
  distinct()

#remove NAs and convert columns to numeric
#PP_water.df = na.omit(PP_water.df)
PP_water.df = as.data.frame(sapply(PP_water.df, as.numeric))

#Apply row numbers from sample IDs
rownames(PP_water.df) = PP_water.df$Associatednumber
PP_water.df$Associatednumber = NULL
rownames(PP_particle.df) = PP_particle.df$Associatednumber
PP_particle.df$Associatednumber = NULL

#Flip so columns are samples for dissimilarity assessment
PP_water.df = t(PP_water.df)
PP_particle.df = t(PP_particle.df)

#Get sample names for microbiome comparison
Samples_water.ls = colnames(PP_water.df)
Samples_particle.ls = colnames(PP_particle.df)


```
##Prepare metabolic dataframes
###Metagenomes
```{r}

#Import gene list
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")
dim(distinct(CarbonGenelist.df))
#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

#Correct abundance
amoAClean_geneabund_KO[c(2:264)] = amoAClean_geneabund_KO[c(2:264)] / 1000


amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")

#amoAClean_CO2CH4_tbl_long = read.csv( "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)

#Subset to split metagenomes and metatranscriptomes and remove superflous columns
amoAClean_CO2CH4_tbl_long_MG = subset(amoAClean_CO2CH4_tbl_long, data_type == "Metagenomes") %>%
  select(counts, KO, Associatednumber)

dim(amoAClean_CO2CH4_tbl_long_MG)
amoAClean_CO2CH4_tbl_long_MG = unique(amoAClean_CO2CH4_tbl_long_MG)
dim(amoAClean_CO2CH4_tbl_long_MG)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MG <- data.frame(spread(amoAClean_CO2CH4_tbl_long_MG,
                       key = Associatednumber, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MG)
#View(amoAClean_CO2CH4_wide_MG)

#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MG) = amoAClean_CO2CH4_wide_MG$KO
amoAClean_CO2CH4_wide_MG$KO = NULL

#Remove x from column names
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))

#So I don't need to waste time rerunning this every time
write.csv(amoAClean_CO2CH4_wide_MG, "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv")
#amoAClean_CO2CH4_wide_MG = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)
```
###Metatranscriptomes
```{r}

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

#Correct abundance
amoAClean_geneabund_KO[c(2:264)] = amoAClean_geneabund_KO[c(2:264)] / 1000


amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)



#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)




#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG.df = CO2CH4_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG.lng = gather(CO2CH4_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber)
dim(CO2CH4_TG.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG.lng$counts = as.numeric(as.character(CO2CH4_TG.lng$counts))
CO2CH4_TG.lng$Associatednumber = as.character(CO2CH4_TG.lng$Associatednumber)

#Long to wide
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MT <- data.frame(spread(unique(CO2CH4_TG.lng),
                       key = Associatednumber, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MT)
#View(amoAClean_CO2CH4_wide_MT)

#Bug check
max(amoAClean_CO2CH4_wide_MT$X117) # should be ~673.5397

#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MT) = amoAClean_CO2CH4_wide_MT$KO
amoAClean_CO2CH4_wide_MT$KO = NULL


#So I don't need to waste time rerunning this every time
write.csv(amoAClean_CO2CH4_wide_MT, "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv")
#amoAClean_CO2CH4_wide_MT = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove x from column names
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))
```

##Match physicochemical and microbial samples and remove extras
```{r}
####Set up dataframes and dissimilarities####

#Extract genes from samples matching conditions
MG_water.df = amoAClean_CO2CH4_wide_MG[names(amoAClean_CO2CH4_wide_MG) %in% Samples_water.ls]
MG_particles.df = amoAClean_CO2CH4_wide_MG[names(amoAClean_CO2CH4_wide_MG) %in% Samples_particle.ls]
MT_water.df = amoAClean_CO2CH4_wide_MT[names(amoAClean_CO2CH4_wide_MT) %in% Samples_water.ls]
MT_particles.df = amoAClean_CO2CH4_wide_MT[names(amoAClean_CO2CH4_wide_MT) %in% Samples_particle.ls]
#Check to make sure it worked
dim(MG_water.df)
dim(MG_particles.df)
dim(MT_water.df)
dim(MT_particles.df)


#Extract only microbial matched samples of Physicochemicals for dissimilarity otherwise mantel doesn't work
PP_water_MG.df = subset(PP_water.df, select = colnames(MG_water.df))
PP_particles_MG.df = subset(PP_particle.df, select = colnames(MG_particles.df))
PP_water_MT.df = subset(PP_water.df, select = colnames(MT_water.df))
PP_particles_MT.df = subset(PP_particle.df, select = colnames(MT_particles.df))

dim(PP_water_MG.df)
dim(PP_particles_MG.df)
dim(PP_water_MT.df)
dim(PP_particles_MT.df)

#Set seed for reproduceability
set.seed(2)

#Run dissimilarity comparison between samples
##Microbial
MG_water.diss = vegan::vegdist(t(MG_water.df), method = "bray")
MG_particles.diss = vegan::vegdist(t(MG_particles.df), method = "bray")
MT_water.diss = vegan::vegdist(t(MT_water.df), method = "bray")
MT_particles.diss = vegan::vegdist(t(MT_particles.df), method = "bray")
#Pysicochemical
PP_water_MG.diss = vegan::vegdist(t(PP_water_MG.df), method = "bray", na.rm = T)
PP_particles_MG.diss = vegan::vegdist(t(PP_particles_MG.df), method = "bray", na.rm = T)
PP_water_MT.diss = vegan::vegdist(t(PP_water_MT.df), method = "bray", na.rm = T)
PP_particles_MT.diss = vegan::vegdist(t(PP_particles_MT.df), method = "bray", na.rm = T)




####Mantel tests general ####

#Whole microbial vs whole physicochemical
mantel(MG_water.diss, PP_water_MG.diss) #p = 0.004, R=0.2411
mantel(MG_particles.diss, PP_particles_MG.diss) #p = 0.001, R=0.1607
mantel(MT_water.diss, PP_water_MT.diss) #p = 0.061, R=0.1937
mantel(MT_particles.diss, PP_particles_MT.diss) #p = 0.018, R=0.1945



#Run loop for individual genes vs individual physicochemical parameters
#####MG water ####
Results_MG_water.df = data.frame("Gene_KO" = "DELETEME",
                     "PhysicochemicalParameter" = "DELETEME",
                     "pvalue" = 99999,
                     "Mantel_Rvalue" = 99999)
i=1
x=7
for (i in 1:length(rownames(MG_water.df))) {
  for (x in 1:length(rownames(PP_water_MG.df))) {
    
    #Extracting names
    M.name = rownames(MG_water.df[i,])
    PP.name = rownames(as.data.frame(PP_water_MG.df)[x,])
    
    #Make dissimilarity matrices
    M.tmp = vegdist(t(MG_water.df[i,]), method = "euclidean")
    PP.tmp = vegdist(PP_water_MG.df[x,], method = "euclidean", na.rm = T)
    
    #Run mantel test
    test.tmp = mantel(M.tmp, PP.tmp, na.rm = T)
    
    #Make df for results
    Results.tmp = data.frame("Gene_KO" = M.name,
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_water.df = rbind(Results_MG_water.df, Results.tmp)
    
    
  }
  
  print(paste0("Completed ", i, " out of ", length(rownames(MG_water.df)), " genes, which is ", round((i/length(rownames(MG_water.df)))*100, digits = 2), "%"))
  
}

#Check results and clean up dataframe
Results_MG_water.df = Results_MG_water.df[-1,]
Results_MG_water.df

#Check if each PP was included
unique(Results_MG_water.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_water.df = subset(Results_MG_water.df, pvalue < 0.05)
dim(Results_MG_water.df)

#Check if each PP was included
unique(Results_MG_water.df$PhysicochemicalParameter)

Top25_Fraction_MG_water.df = Results_MG_water.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.75))
dim(Top25_Fraction_MG_water.df)

length(unique(Top25_Fraction_MG_water.df$Gene_KO))
unique(Top25_Fraction_MG_water.df$PhysicochemicalParameter)


#####MG particles ####
Results_MG_particles.df = data.frame("Gene_KO" = "DELETEME",
                     "PhysicochemicalParameter" = "DELETEME",
                     "pvalue" = 99999,
                     "Mantel_Rvalue" = 99999)
i=1
x=1
for (i in 1:length(rownames(MG_particles.df))) {
  for (x in 1:length(rownames(PP_particles_MG.df))) {
    
    #Extracting names
    M.name = rownames(MG_particles.df[i,])
    PP.name = rownames(as.data.frame(PP_particles_MG.df)[x,])
    
    #Make dissimilarity matrices
    M.tmp = vegdist(t(MG_particles.df[i,]), method = "euclidean")
    PP.tmp = vegdist(PP_particles_MG.df[x,], method = "euclidean", na.rm = T)
    
    #Run mantel test
    test.tmp = mantel(M.tmp, PP.tmp, na.rm = T)
    
    #Make df for results
    Results.tmp = data.frame("Gene_KO" = M.name,
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_particles.df = rbind(Results_MG_particles.df, Results.tmp)
    
    
  }
  
  print(paste0("Completed ", i, " out of ", length(rownames(MG_particles.df)), " genes, which is ", round((i/length(rownames(MG_particles.df)))*100, digits = 2), "%"))
  
}

#Check results and clean up dataframe
Results_MG_particles.df = Results_MG_particles.df[-1,]
Results_MG_particles.df

#Check if each PP was included
unique(Results_MG_particles.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_particles.df = subset(Results_MG_particles.df, pvalue < 0.05)
dim(Results_MG_particles.df)

Top25_Fraction_MG_particles.df = Results_MG_particles.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.75))
dim(Top25_Fraction_MG_particles.df)

length(unique(Top25_Fraction_MG_particles.df$Gene_KO))
unique(Top25_Fraction_MG_particles.df$PhysicochemicalParameter)



#####MT water ####
Results_MT_water.df = data.frame("Gene_KO" = "DELETEME",
                     "PhysicochemicalParameter" = "DELETEME",
                     "pvalue" = 99999,
                     "Mantel_Rvalue" = 99999)
i=1
x=7
for (i in 1:length(rownames(MT_water.df))) {
  for (x in 1:length(rownames(PP_water_MT.df))) {
    
    #Extracting names
    M.name = rownames(MT_water.df[i,])
    PP.name = rownames(as.data.frame(PP_water_MT.df)[x,])
    
    #Make dissimilarity matrices
    M.tmp = vegdist(t(MT_water.df[i,]), method = "euclidean")
    PP.tmp = vegdist(PP_water_MT.df[x,], method = "euclidean", na.rm = T)
    
    #Run mantel test
    test.tmp = mantel(M.tmp, PP.tmp, na.rm = T)
    
    #Make df for results
    Results.tmp = data.frame("Gene_KO" = M.name,
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_water.df = rbind(Results_MT_water.df, Results.tmp)
    
    
  }
  
  print(paste0("Completed ", i, " out of ", length(rownames(MT_water.df)), " genes, which is ", round((i/length(rownames(MT_water.df)))*100, digits = 2), "%"))
  
}

#Check results and clean up dataframe
Results_MT_water.df = Results_MT_water.df[-1,]
Results_MT_water.df

#Check if each PP was included
unique(Results_MT_water.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_water.df = subset(Results_MT_water.df, pvalue < 0.05)
dim(Results_MT_water.df)

Top25_Fraction_MT_water.df = Results_MT_water.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.75))
dim(Top25_Fraction_MT_water.df)

length(unique(Top25_Fraction_MT_water.df$Gene_KO))
unique(Top25_Fraction_MT_water.df$PhysicochemicalParameter)


#####MT particles ####
Results_MT_particles.df = data.frame("Gene_KO" = "DELETEME",
                     "PhysicochemicalParameter" = "DELETEME",
                     "pvalue" = 99999,
                     "Mantel_Rvalue" = 99999)
i=1
x=1
for (i in 1:length(rownames(MT_particles.df))) {
  for (x in 1:length(rownames(PP_particles_MT.df))) {
    
    #Extracting names
    M.name = rownames(MT_particles.df[i,])
    PP.name = rownames(as.data.frame(PP_particles_MT.df)[x,])
    
    #Make dissimilarity matrices
    M.tmp = vegdist(t(MT_particles.df[i,]), method = "euclidean")
    PP.tmp = vegdist(PP_particles_MT.df[x,], method = "euclidean", na.rm = T)
    
    #Run mantel test
    test.tmp = mantel(M.tmp, PP.tmp, na.rm = T)
    
    #Make df for results
    Results.tmp = data.frame("Gene_KO" = M.name,
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_particles.df = rbind(Results_MT_particles.df, Results.tmp)
    
    
  }
  
  print(paste0("Completed ", i, " out of ", length(rownames(MT_particles.df)), " genes, which is ", round((i/length(rownames(MT_particles.df)))*100, digits = 2), "%"))
  
}

#Check results and clean up dataframe
Results_MT_particles.df = Results_MT_particles.df[-1,]
Results_MT_particles.df

#Check if each PP was included
unique(Results_MT_particles.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_particles.df = subset(Results_MT_particles.df, pvalue < 0.05)
dim(Results_MT_particles.df)

Top25_Fraction_MT_particles.df = Results_MT_particles.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.75))
dim(Top25_Fraction_MT_particles.df)

length(unique(Top25_Fraction_MT_particles.df$Gene_KO))
unique(Top25_Fraction_MT_particles.df$PhysicochemicalParameter)


#### Combine all results ####

Results_MG_water.df$data_type = "Metagenomes"
Results_MG_particles.df$data_type = "Metagenomes"
Results_MT_water.df$data_type = "Metatranscriptomes"
Results_MT_particles.df$data_type = "Metatranscriptomes"

Results_MG_water.df$environment = "Water"
Results_MG_particles.df$environment = "Particles"
Results_MT_water.df$environment = "Water"
Results_MT_particles.df$environment = "Particles"



Results.df = rbind(Results_MG_water.df, Results_MG_particles.df,
                   Results_MT_water.df, Results_MT_particles.df)

write.csv(Results.df, "F:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv")


####Analyse ####

Results.df = read.csv("E:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

Results.df = subset(Results.df, PhysicochemicalParameter!="station_km")
dim(Results.df)

Results_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water")
dim(Results_MG_water.df)
Results_MG_particles.df = subset(Results.df, data_type == "Metagenomes" & environment == "Particles")
dim(Results_MG_particles.df)
Results_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water")
dim(Results_MT_water.df)
Results_MT_particles.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Particles")
dim(Results_MT_particles.df)

ggplot(Results_MG_water.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-1)
dim(Results_MG_water.df)
 
MeanPP.df = Results_MG_water.df %>%
  group_by(PhysicochemicalParameter) %>%
  dplyr::summarise(mean_val = mean(Mantel_Rvalue), sd_val = sd(Mantel_Rvalue))%>% 
  arrange(mean_val, decreasing = T)
 MeanPP.df = data.table::setorder(MeanPP.df, cols = mean_val)
MeanPP.df

ggplot(Results_MG_particles.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-1)

MeanPP.df = Results_MG_particles.df %>%
  group_by(PhysicochemicalParameter) %>%
  dplyr::summarise(mean_val = mean(Mantel_Rvalue), sd_val = sd(Mantel_Rvalue))%>% 
  arrange(mean_val, decreasing = T)
MeanPP.df = data.table::setorder(MeanPP.df, cols = mean_val)
MeanPP.df

ggplot(Results_MT_water.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-1)

MeanPP.df = Results_MT_water.df %>%
  group_by(PhysicochemicalParameter) %>%
  dplyr::summarise(mean_val = mean(Mantel_Rvalue), sd_val = sd(Mantel_Rvalue))%>% 
  arrange(mean_val, decreasing = T)
MeanPP.df = data.table::setorder(MeanPP.df, cols = mean_val)
MeanPP.df

ggplot(Results_MT_particles.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-1)

MeanPP.df = Results_MT_particles.df %>%
  group_by(PhysicochemicalParameter) %>%
  dplyr::summarise(mean_val = mean(Mantel_Rvalue), sd_val = sd(Mantel_Rvalue))%>% 
  arrange(mean_val, decreasing = T)
MeanPP.df = data.table::setorder(MeanPP.df, cols = mean_val)
MeanPP.df



#Water PP
Results_water.df = subset(Results.df, environment == "Water")

ggplot(Results_water.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=..count..), vjust=-1)

#Particle PP
Results_particle.df = subset(Results.df, environment == "Particles")
dim(Results_particle.df)
ggplot(Results_particle.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=..count..), vjust=-1)


##### Individual KOs####
#Extract top 5 taxa in each environment
Top5_MG_water.df = Results_MG_water.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.99))
Top5_MG_water.df # Need Salinity
Top5_MG_particles.df = Results_MG_particles.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.983))
Top5_MG_particles.df # Need SPM and PTC
Top5_MT_water.df = Results_MT_water.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.998))
Top5_MT_water.df
Top5_MT_particles.df = Results_MT_particles.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.975))
Top5_MT_particles.df

dim(Results_MG_water.df)
dim(Results_MG_particles.df)
dim(Results_MT_water.df)
dim(Results_MT_particles.df)

#Make a list for extraction from phyloseq object and downstream plots
Top5_water.ls = Top5_Fraction_mOTUs_water.df$Gene_KO
Top5_particles.ls = Top5_Fraction_mOTUs_particles.df$Gene_KO

#Extract only top 5 taxa
Top5_water.df = subset(taxa.df, taxapath %in% Top5_water.ls)
Top5_particles.df = subset(taxa.df, taxapath %in% Top5_particles.ls)


#Remove non-environment samples for water and particles
Top5_water.df = subset(Top5_water.df, Associatednumber %in% colnames(Microbiome_water.df))
Top5_particles.df = subset(Top5_particles.df, Associatednumber %in% colnames(Microbiome_particles.df))
                                    

# Make water plots
salinity.plt = ggplot(Top5_water.df, 
                      aes(x = salinity, 
                          y = Abundance*100, 
                          colour = taxapath))+
  geom_point()+
  geom_smooth()+
  My_Theme
salinity.plt

#Make particle plots
CSP.plt = ggplot(subset(Top5_particles.df, taxapath!= "PseudomonadotaGammaproteobacteriaXanthomonadalesSZUA-36JABDPF01__"), 
                 aes(x = as.numeric(CSP_um2perL), 
                     y = Abundance*100, 
                     colour = taxapath))+
  geom_point()+
  geom_smooth()+
  My_Theme
CSP.plt
SPM.plt = ggplot(subset(Top5_particles.df, taxapath == "PseudomonadotaGammaproteobacteriaXanthomonadalesSZUA-36JABDPF01__"), 
                 aes(x = as.numeric(spm_mg_l), 
                     y = Abundance*100, 
                     colour = taxapath))+
  geom_point()+
  geom_smooth()+
  My_Theme
SPM.plt

ggpubr::ggarrange(salinity.plt,
          CSP.plt, SPM.plt)

pdf("Figures/PP_mOTUs.pdf", width = 36, height = 12)
ggpubr::ggarrange(salinity.plt,
          CSP.plt, SPM.plt)
dev.off()
 

####Shared KOs for dCO2 and dCH4 between MG and MT####


Results.df = read.csv("E:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

Results.df = subset(Results.df, PhysicochemicalParameter!="station_km")
dim(Results.df)

#dCO2
dCO2_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water" & PhysicochemicalParameter == "dCO2_uM")
dCO2_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water" & PhysicochemicalParameter == "dCO2_uM")
#dCH4
dCH4_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water" & PhysicochemicalParameter == "dCH4_nM")
dCH4_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water" & PhysicochemicalParameter == "dCH4_nM")
                          

MG_MT_dCO2.df = subset(dCO2_MG_water.df, Gene_KO %in% dCO2_MT_water.df$Gene_KO)
MG_MT_dCH4.df = subset(dCH4_MG_water.df, Gene_KO %in% dCH4_MT_water.df$Gene_KO)




```
```{r Salinity and O2 KOs compared}
#Water PP
Results_water.df = subset(Results.df, environment == "Water")

KOs_Sal.ls = subset(Results_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_O2.ls = subset(Results_water.df, PhysicochemicalParameter == "O2_uM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_O2.ls = sort(unique(KOs_O2.ls$Gene_KO))

match(KOs_Sal.ls, KOs_O2.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_O2.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)


```
```{r Salinity and dCO2 KOs compared}

Results.df = read.csv("E:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

Results_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water")
Results_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water")

####Combined ####
#Water PP
Results_water.df = subset(Results.df, environment == "Water")

KOs_Sal.ls = subset(Results_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCO2.ls = subset(Results_water.df, PhysicochemicalParameter == "dCO2_uM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCO2.ls = sort(unique(KOs_dCO2.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCO2.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCO2.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)#

test = subset(Results.df, Gene_KO %in% common_elements & PhysicochemicalParameter == "Salinity_PSU" | Gene_KO %in% common_elements & PhysicochemicalParameter == "dCO2_uM")

test2 = spread(test[,-3], key = PhysicochemicalParameter, value = Mantel_Rvalue)

test2$CombinedMantelR = test2$dCO2_uM + test2$Salinity_PSU

#### Functional ####
#Water PP

KOs_Sal.ls = subset(Results_MG_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCO2.ls = subset(Results_MG_water.df, PhysicochemicalParameter == "dCO2_uM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCO2.ls = sort(unique(KOs_dCO2.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCO2.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCO2.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

#### Transcripts ####
#Water PP

KOs_Sal.ls = subset(Results_MT_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCO2.ls = subset(Results_MT_water.df, PhysicochemicalParameter == "dCO2_uM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCO2.ls = sort(unique(KOs_dCO2.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCO2.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCO2.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

```
```{r Salinity and dCH4 KOs compared}
Results.df = read.csv("E:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

Results_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water")
Results_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water")

####Combined####

#Water PP
Results_water.df = subset(Results.df, environment == "Water")

KOs_Sal.ls = subset(Results_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCH4.ls = subset(Results_water.df, PhysicochemicalParameter == "dCH4_nM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCH4.ls = sort(unique(KOs_dCH4.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCH4.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCH4.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

test = subset(Results.df, Gene_KO %in% common_elements & PhysicochemicalParameter == "Salinity_PSU" | Gene_KO %in% common_elements & PhysicochemicalParameter == "dCH4_nM")

test2 = spread(test[,-3], key = PhysicochemicalParameter, value = Mantel_Rvalue)

test2$CombinedMantelR = test2$dCO2_uM + test2$Salinity_PSU

####Functional####

#Water PP

KOs_Sal.ls = subset(Results_MG_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCH4.ls = subset(Results_MG_water.df, PhysicochemicalParameter == "dCH4_nM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCH4.ls = sort(unique(KOs_dCH4.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCH4.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCH4.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

####Transcripts####

#Water PP

KOs_Sal.ls = subset(Results_MT_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCH4.ls = subset(Results_MT_water.df, PhysicochemicalParameter == "dCH4_nM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCH4.ls = sort(unique(KOs_dCH4.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCH4.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCH4.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

```
##Match to MAGs of origin


```{r CSP MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
CSP_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter == "CSP_um2perL")[,1])
#CSP_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_CSP = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CSP_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_CSP)
#View(amoAClean_geneabund_KO_CSP)

amoAClean_CO2CH4_tbl_long_CSP <- amoAClean_geneabund_KO_CSP %>%
  filter(KO %in% CSP_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_CSP$counts = amoAClean_CO2CH4_tbl_long_CSP$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_CSP$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_CSP$domain)
amoAClean_CO2CH4_tbl_long_CSP$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_CSP$phylum)
amoAClean_CO2CH4_tbl_long_CSP$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_CSP$class)
amoAClean_CO2CH4_tbl_long_CSP$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_CSP$order)
amoAClean_CO2CH4_tbl_long_CSP$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_CSP$family)
amoAClean_CO2CH4_tbl_long_CSP$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_CSP$genus)
amoAClean_CO2CH4_tbl_long_CSP$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_CSP$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_CSP$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_CSP$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$class, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$order, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$family, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_CSP$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_CSP$genome)

CSP_taxa_MG.df = amoAClean_CO2CH4_tbl_long_CSP %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(CSP_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CSP_MG.csv")

#CSP_taxa_MG.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CSP_MG.csv")

#Clean up for plot
CSP_taxa_MG.df$station_km = as.numeric(as.character(CSP_taxa_MG.df$station_km))


CSP_taxa_MG.df$Sample_date = factor(CSP_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

CSP_taxa_MG.sum = Rmisc::summarySE(CSP_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/CSP_MAGCorr_MG.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(CSP_taxa_MG.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
#  scale_color_manual(values = expanded_cbbPalette)+
 # scale_y_log10()+
  #My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(CSP_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = sort(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")))

test[order(-test$N), ]

unique(CSP_taxa_MG.df$fulltaxa)





#### Metatranscriptomes ####



#Extract relevant genes
CSP_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter == "CSP_um2perL")[,1])
#CSP_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_CSP = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CSP_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_CSP)
#View(amoAClean_geneabund_KO_CSP)

amoAClean_CO2CH4_tbl_long_CSP <- amoAClean_geneabund_KO_CSP %>%
  filter(KO %in% CSP_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_CSP$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_CSP$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_CSP$data_type)
amoAClean_CO2CH4_tbl_long_CSP$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_CSP$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_CSP.df <- spread(amoAClean_CO2CH4_tbl_long_CSP[ , ! names(amoAClean_CO2CH4_tbl_long_CSP) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_CSP)
dim(CO2CH4_TG_CSP.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_CSP.df$TranscriptsPerGenome = CO2CH4_TG_CSP.df$Transcriptomes / CO2CH4_TG_CSP.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_CSP.df = CO2CH4_TG_CSP.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_CSP.lng = gather(CO2CH4_TG_CSP.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_CSP.lng = subset(CO2CH4_TG_CSP.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_CSP.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_CSP.lng = subset(CO2CH4_TG_CSP.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_CSP.lng = subset(CO2CH4_TG_CSP.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_CSP.lng$counts = as.numeric(as.character(CO2CH4_TG_CSP.lng$counts))
CO2CH4_TG_CSP.lng$Associatednumber = as.character(CO2CH4_TG_CSP.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_CSP.lng$counts = CO2CH4_TG_CSP.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_CSP.lng$domain = gsub("d__", "", CO2CH4_TG_CSP.lng$domain)
CO2CH4_TG_CSP.lng$phylum = gsub("p__", "", CO2CH4_TG_CSP.lng$phylum)
CO2CH4_TG_CSP.lng$class = gsub("c__", "", CO2CH4_TG_CSP.lng$class)
CO2CH4_TG_CSP.lng$order = gsub("o__", "", CO2CH4_TG_CSP.lng$order)
CO2CH4_TG_CSP.lng$family = gsub("f__", "", CO2CH4_TG_CSP.lng$family)
CO2CH4_TG_CSP.lng$genus = gsub("g__", "", CO2CH4_TG_CSP.lng$genus)
CO2CH4_TG_CSP.lng$species = gsub("s__", "", CO2CH4_TG_CSP.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_CSP.lng$fulltaxa = paste0(CO2CH4_TG_CSP.lng$domain, "__",
                                                CO2CH4_TG_CSP.lng$phylum, "__",
                                                CO2CH4_TG_CSP.lng$class, "__",
                                                CO2CH4_TG_CSP.lng$order, "__",
                                                CO2CH4_TG_CSP.lng$family, "__",
                                                CO2CH4_TG_CSP.lng$genus, "__",
                                                CO2CH4_TG_CSP.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_CSP.lng$fulltaxa)
unique(CO2CH4_TG_CSP.lng$genome)

CSP_taxa_MT.df = CO2CH4_TG_CSP.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(CSP_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CSP_TG.csv")

#CSP_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CSP_TG.csv")

#Clean up for plot
CSP_taxa_MT.df$station_km = as.numeric(as.character(CSP_taxa_MT.df$station_km))


CSP_taxa_MT.df$Sample_date = factor(CSP_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

CSP_taxa_MT.sum = Rmisc::summarySE(CSP_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/CSP_MAGCorr_MT.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(CSP_taxa_MT.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  scale_y_log10()+
 # My_Theme 

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(CSP_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]


unique(CSP_taxa_MT.sum$fulltaxa)


```
```{r PTN MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
PTN_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter == "PTN_mgperL")[,1])
#PTN_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_PTN = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% PTN_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_PTN)
#View(amoAClean_geneabund_KO_PTN)

amoAClean_CO2CH4_tbl_long_PTN <- amoAClean_geneabund_KO_PTN %>%
  filter(KO %in% PTN_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_PTN$counts = amoAClean_CO2CH4_tbl_long_PTN$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_PTN$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_PTN$domain)
amoAClean_CO2CH4_tbl_long_PTN$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_PTN$phylum)
amoAClean_CO2CH4_tbl_long_PTN$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_PTN$class)
amoAClean_CO2CH4_tbl_long_PTN$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_PTN$order)
amoAClean_CO2CH4_tbl_long_PTN$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_PTN$family)
amoAClean_CO2CH4_tbl_long_PTN$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_PTN$genus)
amoAClean_CO2CH4_tbl_long_PTN$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_PTN$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_PTN$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_PTN$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$class, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$order, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$family, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_PTN$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_PTN$genome)

PTN_taxa_MG.df = amoAClean_CO2CH4_tbl_long_PTN %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(PTN_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_PTN_MG.csv")

#PTN_taxa_MG.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_PTN_MG.csv")

#Clean up for plot
PTN_taxa_MG.df$station_km = as.numeric(as.character(PTN_taxa_MG.df$station_km))


PTN_taxa_MG.df$Sample_date = factor(PTN_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

PTN_taxa_MG.sum = Rmisc::summarySE(PTN_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/PTN_MAGCorr_MG.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(PTN_taxa_MG.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
#  scale_color_manual(values = expanded_cbbPalette)+
 # scale_y_log10()+
  #My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(PTN_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = sort(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")))

test[order(-test$N), ]

unique(PTN_taxa_MG.df$fulltaxa)





#### Metatranscriptomes ####



#Extract relevant genes
PTN_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter == "PTN_mgperL")[,1])
#PTN_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_PTN = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% PTN_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_PTN)
#View(amoAClean_geneabund_KO_PTN)

amoAClean_CO2CH4_tbl_long_PTN <- amoAClean_geneabund_KO_PTN %>%
  filter(KO %in% PTN_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_PTN$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_PTN$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_PTN$data_type)
amoAClean_CO2CH4_tbl_long_PTN$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_PTN$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_PTN.df <- spread(amoAClean_CO2CH4_tbl_long_PTN[ , ! names(amoAClean_CO2CH4_tbl_long_PTN) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_PTN)
dim(CO2CH4_TG_PTN.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_PTN.df$TranscriptsPerGenome = CO2CH4_TG_PTN.df$Transcriptomes / CO2CH4_TG_PTN.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_PTN.df = CO2CH4_TG_PTN.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_PTN.lng = gather(CO2CH4_TG_PTN.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_PTN.lng = subset(CO2CH4_TG_PTN.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_PTN.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_PTN.lng = subset(CO2CH4_TG_PTN.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_PTN.lng = subset(CO2CH4_TG_PTN.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_PTN.lng$counts = as.numeric(as.character(CO2CH4_TG_PTN.lng$counts))
CO2CH4_TG_PTN.lng$Associatednumber = as.character(CO2CH4_TG_PTN.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_PTN.lng$counts = CO2CH4_TG_PTN.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_PTN.lng$domain = gsub("d__", "", CO2CH4_TG_PTN.lng$domain)
CO2CH4_TG_PTN.lng$phylum = gsub("p__", "", CO2CH4_TG_PTN.lng$phylum)
CO2CH4_TG_PTN.lng$class = gsub("c__", "", CO2CH4_TG_PTN.lng$class)
CO2CH4_TG_PTN.lng$order = gsub("o__", "", CO2CH4_TG_PTN.lng$order)
CO2CH4_TG_PTN.lng$family = gsub("f__", "", CO2CH4_TG_PTN.lng$family)
CO2CH4_TG_PTN.lng$genus = gsub("g__", "", CO2CH4_TG_PTN.lng$genus)
CO2CH4_TG_PTN.lng$species = gsub("s__", "", CO2CH4_TG_PTN.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_PTN.lng$fulltaxa = paste0(CO2CH4_TG_PTN.lng$domain, "__",
                                                CO2CH4_TG_PTN.lng$phylum, "__",
                                                CO2CH4_TG_PTN.lng$class, "__",
                                                CO2CH4_TG_PTN.lng$order, "__",
                                                CO2CH4_TG_PTN.lng$family, "__",
                                                CO2CH4_TG_PTN.lng$genus, "__",
                                                CO2CH4_TG_PTN.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_PTN.lng$fulltaxa)
unique(CO2CH4_TG_PTN.lng$genome)

PTN_taxa_MT.df = CO2CH4_TG_PTN.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(PTN_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_PTN_TG.csv")

#PTN_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_PTN_TG.csv")

#Clean up for plot
PTN_taxa_MT.df$station_km = as.numeric(as.character(PTN_taxa_MT.df$station_km))


PTN_taxa_MT.df$Sample_date = factor(PTN_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

PTN_taxa_MT.sum = Rmisc::summarySE(PTN_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/PTN_MAGCorr_MT.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(PTN_taxa_MT.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  scale_y_log10()+
 # My_Theme 

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(PTN_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]


#test = subset(PTN_taxa_MT.sum, KO == "K00281")

unique(PTN_taxa_MT.sum$fulltaxa)


```
```{r POC MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
POC_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter == "POC_mgperL")[,1])
#POC_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_POC = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% POC_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_POC)
#View(amoAClean_geneabund_KO_POC)

amoAClean_CO2CH4_tbl_long_POC <- amoAClean_geneabund_KO_POC %>%
  filter(KO %in% POC_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_POC$counts = amoAClean_CO2CH4_tbl_long_POC$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_POC$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_POC$domain)
amoAClean_CO2CH4_tbl_long_POC$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_POC$phylum)
amoAClean_CO2CH4_tbl_long_POC$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_POC$class)
amoAClean_CO2CH4_tbl_long_POC$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_POC$order)
amoAClean_CO2CH4_tbl_long_POC$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_POC$family)
amoAClean_CO2CH4_tbl_long_POC$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_POC$genus)
amoAClean_CO2CH4_tbl_long_POC$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_POC$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_POC$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_POC$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$class, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$order, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$family, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_POC$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_POC$genome)

POC_taxa_MG.df = amoAClean_CO2CH4_tbl_long_POC %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(POC_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_POC_MG.csv")

#POC_taxa_MG.df = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_POC_MG.csv")

#Clean up for plot
POC_taxa_MG.df$station_km = as.numeric(as.character(POC_taxa_MG.df$station_km))


POC_taxa_MG.df$Sample_date = factor(POC_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

POC_taxa_MG.sum = Rmisc::summarySE(POC_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/POC_MAGCorr_MG.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(POC_taxa_MG.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
#  scale_color_manual(values = expanded_cbbPalette)+
 # scale_y_log10()+
  #My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(POC_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = sort(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")))

test[order(-test$N), ]

unique(POC_taxa_MG.df$fulltaxa)





#### Metatranscriptomes ####


#Extract relevant genes
POC_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter == "POC_mgperL")[,1])
#POC_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_POC = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% POC_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_POC)
#View(amoAClean_geneabund_KO_POC)

amoAClean_CO2CH4_tbl_long_POC <- amoAClean_geneabund_KO_POC %>%
  filter(KO %in% POC_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_POC$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_POC$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_POC$data_type)
amoAClean_CO2CH4_tbl_long_POC$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_POC$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_POC.df <- spread(amoAClean_CO2CH4_tbl_long_POC[ , ! names(amoAClean_CO2CH4_tbl_long_POC) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_POC)
dim(CO2CH4_TG_POC.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_POC.df$TranscriptsPerGenome = CO2CH4_TG_POC.df$Transcriptomes / CO2CH4_TG_POC.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_POC.df = CO2CH4_TG_POC.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_POC.lng = gather(CO2CH4_TG_POC.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_POC.lng = subset(CO2CH4_TG_POC.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_POC.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_POC.lng = subset(CO2CH4_TG_POC.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_POC.lng = subset(CO2CH4_TG_POC.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_POC.lng$counts = as.numeric(as.character(CO2CH4_TG_POC.lng$counts))
CO2CH4_TG_POC.lng$Associatednumber = as.character(CO2CH4_TG_POC.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_POC.lng$counts = CO2CH4_TG_POC.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_POC.lng$domain = gsub("d__", "", CO2CH4_TG_POC.lng$domain)
CO2CH4_TG_POC.lng$phylum = gsub("p__", "", CO2CH4_TG_POC.lng$phylum)
CO2CH4_TG_POC.lng$class = gsub("c__", "", CO2CH4_TG_POC.lng$class)
CO2CH4_TG_POC.lng$order = gsub("o__", "", CO2CH4_TG_POC.lng$order)
CO2CH4_TG_POC.lng$family = gsub("f__", "", CO2CH4_TG_POC.lng$family)
CO2CH4_TG_POC.lng$genus = gsub("g__", "", CO2CH4_TG_POC.lng$genus)
CO2CH4_TG_POC.lng$species = gsub("s__", "", CO2CH4_TG_POC.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_POC.lng$fulltaxa = paste0(CO2CH4_TG_POC.lng$domain, "__",
                                                CO2CH4_TG_POC.lng$phylum, "__",
                                                CO2CH4_TG_POC.lng$class, "__",
                                                CO2CH4_TG_POC.lng$order, "__",
                                                CO2CH4_TG_POC.lng$family, "__",
                                                CO2CH4_TG_POC.lng$genus, "__",
                                                CO2CH4_TG_POC.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_POC.lng$fulltaxa)
unique(CO2CH4_TG_POC.lng$genome)

POC_taxa_MT.df = CO2CH4_TG_POC.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(POC_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_POC_TG.csv")

#POC_taxa_MT.df = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_POC_TG.csv")

#Clean up for plot
POC_taxa_MT.df$station_km = as.numeric(as.character(POC_taxa_MT.df$station_km))


POC_taxa_MT.df$Sample_date = factor(POC_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

POC_taxa_MT.sum = Rmisc::summarySE(POC_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/POC_MAGCorr_MT.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(POC_taxa_MT.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  scale_y_log10()+
 # My_Theme 

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(POC_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]

sort(unique(POC_taxa_MT.sum$fulltaxa))


```
```{r SPM MAG matching - MG + MT }

taxa = taxa %>%
  distinct()
 
#### Metagenomes ####

#Extract relevant genes
SPM_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter == "SPM_mgperL")[,1])
#SPM_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_SPM = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% SPM_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_SPM)
#View(amoAClean_geneabund_KO_SPM)

amoAClean_CO2CH4_tbl_long_SPM <- amoAClean_geneabund_KO_SPM %>%
  filter(KO %in% SPM_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 50, 0, 1)) %>% # 0.05% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for above than 0.1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")
dim(amoAClean_CO2CH4_tbl_long_SPM)

#Correct abundance
amoAClean_CO2CH4_tbl_long_SPM$counts = amoAClean_CO2CH4_tbl_long_SPM$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_SPM$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_SPM$domain)
amoAClean_CO2CH4_tbl_long_SPM$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_SPM$phylum)
amoAClean_CO2CH4_tbl_long_SPM$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_SPM$class)
amoAClean_CO2CH4_tbl_long_SPM$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_SPM$order)
amoAClean_CO2CH4_tbl_long_SPM$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_SPM$family)
amoAClean_CO2CH4_tbl_long_SPM$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_SPM$genus)
amoAClean_CO2CH4_tbl_long_SPM$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_SPM$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_SPM$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_SPM$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$class, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$order, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$family, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_SPM$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_SPM$genome)

SPM_taxa_MG.df = amoAClean_CO2CH4_tbl_long_SPM %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(SPM_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_SPM.csv")

#SPM_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_SPM.csv")

#Clean up for plot
SPM_taxa_MG.df$station_km = as.numeric(as.character(SPM_taxa_MG.df$station_km))


SPM_taxa_MG.df$Sample_date = factor(SPM_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

SPM_taxa_MG.sum = Rmisc::summarySE(SPM_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/SPM_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(SPM_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(SPM_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(SPM_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
SPM_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter == "SPM_mgperL")[,1])
#SPM_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_SPM = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% SPM_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_SPM)
#View(amoAClean_geneabund_KO_SPM)

amoAClean_CO2CH4_tbl_long_SPM <- amoAClean_geneabund_KO_SPM %>%
  filter(KO %in% SPM_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

amoAClean_CO2CH4_tbl_long_SPM$counts = amoAClean_CO2CH4_tbl_long_SPM$counts / 1000
unique(amoAClean_CO2CH4_tbl_long_SPM$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_SPM$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_SPM$data_type)
amoAClean_CO2CH4_tbl_long_SPM$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_SPM$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_SPM.df <- spread(amoAClean_CO2CH4_tbl_long_SPM[ , ! names(amoAClean_CO2CH4_tbl_long_SPM) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_SPM)
dim(CO2CH4_TG_SPM.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_SPM.df$TranscriptsPerGenome = CO2CH4_TG_SPM.df$Transcriptomes / CO2CH4_TG_SPM.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_SPM.df = CO2CH4_TG_SPM.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuSPMly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_SPM.lng = gather(CO2CH4_TG_SPM.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_SPM.lng = subset(CO2CH4_TG_SPM.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_SPM.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_SPM.lng = subset(CO2CH4_TG_SPM.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_SPM.lng = subset(CO2CH4_TG_SPM.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_SPM.lng$counts = as.numeric(as.character(CO2CH4_TG_SPM.lng$counts))
CO2CH4_TG_SPM.lng$Associatednumber = as.character(CO2CH4_TG_SPM.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_SPM.lng$counts = CO2CH4_TG_SPM.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_SPM.lng$domain = gsub("d__", "", CO2CH4_TG_SPM.lng$domain)
CO2CH4_TG_SPM.lng$phylum = gsub("p__", "", CO2CH4_TG_SPM.lng$phylum)
CO2CH4_TG_SPM.lng$class = gsub("c__", "", CO2CH4_TG_SPM.lng$class)
CO2CH4_TG_SPM.lng$order = gsub("o__", "", CO2CH4_TG_SPM.lng$order)
CO2CH4_TG_SPM.lng$family = gsub("f__", "", CO2CH4_TG_SPM.lng$family)
CO2CH4_TG_SPM.lng$genus = gsub("g__", "", CO2CH4_TG_SPM.lng$genus)
CO2CH4_TG_SPM.lng$species = gsub("s__", "", CO2CH4_TG_SPM.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_SPM.lng$fulltaxa = paste0(CO2CH4_TG_SPM.lng$domain, "__",
                                                CO2CH4_TG_SPM.lng$phylum, "__",
                                                CO2CH4_TG_SPM.lng$class, "__",
                                                CO2CH4_TG_SPM.lng$order, "__",
                                                CO2CH4_TG_SPM.lng$family, "__",
                                                CO2CH4_TG_SPM.lng$genus, "__",
                                                CO2CH4_TG_SPM.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_SPM.lng$fulltaxa)
unique(CO2CH4_TG_SPM.lng$genome)

SPM_taxa_MT.df = CO2CH4_TG_SPM.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(SPM_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_SPM_TG.csv")

#SPM_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_SPM_TG.csv")

#Clean up for plot
SPM_taxa_MT.df$station_km = as.numeric(as.character(SPM_taxa_MT.df$station_km))


SPM_taxa_MT.df$Sample_date = factor(SPM_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

SPM_taxa_MT.sum = Rmisc::summarySE(SPM_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/SPM_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(SPM_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(SPM_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(SPM_taxa_MT.sum$fulltaxa)

```
```{r Salinity MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
Salinity_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Salinity_PSU")[,1])
#Salinity_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_sal = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Salinity_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_sal)
#View(amoAClean_geneabund_KO_sal)

amoAClean_CO2CH4_tbl_long_sal <- amoAClean_geneabund_KO_sal %>%
  filter(KO %in% Salinity_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_sal$counts = amoAClean_CO2CH4_tbl_long_sal$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_sal$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_sal$domain)
amoAClean_CO2CH4_tbl_long_sal$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_sal$phylum)
amoAClean_CO2CH4_tbl_long_sal$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_sal$class)
amoAClean_CO2CH4_tbl_long_sal$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_sal$order)
amoAClean_CO2CH4_tbl_long_sal$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_sal$family)
amoAClean_CO2CH4_tbl_long_sal$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_sal$genus)
amoAClean_CO2CH4_tbl_long_sal$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_sal$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_sal$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_sal$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$class, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$order, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$family, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_sal$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_sal$genome)

Sal_taxa.df = amoAClean_CO2CH4_tbl_long_sal %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Sal_taxa.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_sal.csv")

#Sal_taxa.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_sal.csv")

#Clean up for plot
Sal_taxa.df$station_km = as.numeric(as.character(Sal_taxa.df$station_km))


Sal_taxa.df$Sample_date = factor(Sal_taxa.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Sal_taxa.sum = Rmisc::summarySE(Sal_taxa.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Sal_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Sal_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Sal_taxa.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Sal_taxa.df$fulltaxa)



#### Metatranscriptomes ####



#Extract relevant genes
Salinity_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Salinity_PSU")[,1])
#Salinity_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_sal = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Salinity_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_sal)
#View(amoAClean_geneabund_KO_sal)

amoAClean_CO2CH4_tbl_long_sal <- amoAClean_geneabund_KO_sal %>%
  filter(KO %in% Salinity_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_sal$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_sal$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_sal$data_type)
amoAClean_CO2CH4_tbl_long_sal$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_sal$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_sal.df <- spread(amoAClean_CO2CH4_tbl_long_sal[ , ! names(amoAClean_CO2CH4_tbl_long_sal) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_sal)
dim(CO2CH4_TG_sal.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_sal.df$TranscriptsPerGenome = CO2CH4_TG_sal.df$Transcriptomes / CO2CH4_TG_sal.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_sal.df = CO2CH4_TG_sal.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_sal.lng = gather(CO2CH4_TG_sal.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_sal.lng = subset(CO2CH4_TG_sal.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_sal.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_sal.lng = subset(CO2CH4_TG_sal.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_sal.lng = subset(CO2CH4_TG_sal.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_sal.lng$counts = as.numeric(as.character(CO2CH4_TG_sal.lng$counts))
CO2CH4_TG_sal.lng$Associatednumber = as.character(CO2CH4_TG_sal.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_sal.lng$counts = CO2CH4_TG_sal.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_sal.lng$domain = gsub("d__", "", CO2CH4_TG_sal.lng$domain)
CO2CH4_TG_sal.lng$phylum = gsub("p__", "", CO2CH4_TG_sal.lng$phylum)
CO2CH4_TG_sal.lng$class = gsub("c__", "", CO2CH4_TG_sal.lng$class)
CO2CH4_TG_sal.lng$order = gsub("o__", "", CO2CH4_TG_sal.lng$order)
CO2CH4_TG_sal.lng$family = gsub("f__", "", CO2CH4_TG_sal.lng$family)
CO2CH4_TG_sal.lng$genus = gsub("g__", "", CO2CH4_TG_sal.lng$genus)
CO2CH4_TG_sal.lng$species = gsub("s__", "", CO2CH4_TG_sal.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_sal.lng$fulltaxa = paste0(CO2CH4_TG_sal.lng$domain, "__",
                                                CO2CH4_TG_sal.lng$phylum, "__",
                                                CO2CH4_TG_sal.lng$class, "__",
                                                CO2CH4_TG_sal.lng$order, "__",
                                                CO2CH4_TG_sal.lng$family, "__",
                                                CO2CH4_TG_sal.lng$genus, "__",
                                                CO2CH4_TG_sal.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_sal.lng$fulltaxa)
unique(CO2CH4_TG_sal.lng$genome)

Sal_taxa_MT.df = CO2CH4_TG_sal.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Sal_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_sal_TG.csv")

Sal_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_sal_TG.csv")

#Clean up for plot
Sal_taxa_MT.df$station_km = as.numeric(as.character(Sal_taxa_MT.df$station_km))


Sal_taxa_MT.df$Sample_date = factor(Sal_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Sal_taxa_MT.sum = Rmisc::summarySE(Sal_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Sal_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Sal_taxa_MT.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Sal_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]



unique(Sal_taxa_MT.sum$fulltaxa)



```
```{r Turbidity MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
Turbidity_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Turbidity_NTU")[,1])
#Turbidity_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Turb = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Turbidity_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Turb)
#View(amoAClean_geneabund_KO_Turb)

amoAClean_CO2CH4_tbl_long_Turb <- amoAClean_geneabund_KO_Turb %>%
  filter(KO %in% Turbidity_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_Turb$counts = amoAClean_CO2CH4_tbl_long_Turb$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_Turb$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_Turb$domain)
amoAClean_CO2CH4_tbl_long_Turb$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_Turb$phylum)
amoAClean_CO2CH4_tbl_long_Turb$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_Turb$class)
amoAClean_CO2CH4_tbl_long_Turb$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_Turb$order)
amoAClean_CO2CH4_tbl_long_Turb$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_Turb$family)
amoAClean_CO2CH4_tbl_long_Turb$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_Turb$genus)
amoAClean_CO2CH4_tbl_long_Turb$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_Turb$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_Turb$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_Turb$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$class, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$order, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$family, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Turb$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Turb$genome)

Turb_taxa.df = amoAClean_CO2CH4_tbl_long_Turb %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Turb_taxa.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Turb.csv")

Turb_taxa.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Turb.csv")

#Clean up for plot
Turb_taxa.df$station_km = as.numeric(as.character(Turb_taxa.df$station_km))


Turb_taxa.df$Sample_date = factor(Turb_taxa.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Turb_taxa_MG.sum = Rmisc::summarySE(Turb_taxa.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Turb_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Turb_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Turb_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Turb_taxa_MG.sum$fulltaxa)



#### Metatranscriptomes ####



#Extract relevant genes
Turbidity_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Turbidity_NTU")[,1])
#Turbidity_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Turb = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Turbidity_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Turb)
#View(amoAClean_geneabund_KO_Turb)

amoAClean_CO2CH4_tbl_long_Turb <- amoAClean_geneabund_KO_Turb %>%
  filter(KO %in% Turbidity_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_Turb$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Turb$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Turb$data_type)
amoAClean_CO2CH4_tbl_long_Turb$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Turb$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Turb.df <- spread(amoAClean_CO2CH4_tbl_long_Turb[ , ! names(amoAClean_CO2CH4_tbl_long_Turb) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Turb)
dim(CO2CH4_TG_Turb.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Turb.df$TranscriptsPerGenome = CO2CH4_TG_Turb.df$Transcriptomes / CO2CH4_TG_Turb.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Turb.df = CO2CH4_TG_Turb.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuTurbly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Turb.lng = gather(CO2CH4_TG_Turb.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_Turb.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Turb.lng$counts = as.numeric(as.character(CO2CH4_TG_Turb.lng$counts))
CO2CH4_TG_Turb.lng$Associatednumber = as.character(CO2CH4_TG_Turb.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_Turb.lng$counts = CO2CH4_TG_Turb.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_Turb.lng$domain = gsub("d__", "", CO2CH4_TG_Turb.lng$domain)
CO2CH4_TG_Turb.lng$phylum = gsub("p__", "", CO2CH4_TG_Turb.lng$phylum)
CO2CH4_TG_Turb.lng$class = gsub("c__", "", CO2CH4_TG_Turb.lng$class)
CO2CH4_TG_Turb.lng$order = gsub("o__", "", CO2CH4_TG_Turb.lng$order)
CO2CH4_TG_Turb.lng$family = gsub("f__", "", CO2CH4_TG_Turb.lng$family)
CO2CH4_TG_Turb.lng$genus = gsub("g__", "", CO2CH4_TG_Turb.lng$genus)
CO2CH4_TG_Turb.lng$species = gsub("s__", "", CO2CH4_TG_Turb.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_Turb.lng$fulltaxa = paste0(CO2CH4_TG_Turb.lng$domain, "__",
                                                CO2CH4_TG_Turb.lng$phylum, "__",
                                                CO2CH4_TG_Turb.lng$class, "__",
                                                CO2CH4_TG_Turb.lng$order, "__",
                                                CO2CH4_TG_Turb.lng$family, "__",
                                                CO2CH4_TG_Turb.lng$genus, "__",
                                                CO2CH4_TG_Turb.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_Turb.lng$fulltaxa)
unique(CO2CH4_TG_Turb.lng$genome)

Turb_taxa_MT.df = CO2CH4_TG_Turb.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Turb_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Turb_TG.csv")

#Turb_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Turb_TG.csv")

#Clean up for plot
Turb_taxa_MT.df$station_km = as.numeric(as.character(Turb_taxa_MT.df$station_km))


Turb_taxa_MT.df$Sample_date = factor(Turb_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Turb_taxa_MT.sum = Rmisc::summarySE(Turb_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Turb_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Turb_taxa_MT.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Turb_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]

unique(Turb_taxa_MT.sum$fulltaxa)


```
```{r O2 MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
O2_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "O2_uM")[,1])
#O2_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_O2 = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% O2_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_O2)
#View(amoAClean_geneabund_KO_O2)

amoAClean_CO2CH4_tbl_long_O2 <- amoAClean_geneabund_KO_O2 %>%
  filter(KO %in% O2_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_O2$counts = amoAClean_CO2CH4_tbl_long_O2$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_O2$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_O2$domain)
amoAClean_CO2CH4_tbl_long_O2$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_O2$phylum)
amoAClean_CO2CH4_tbl_long_O2$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_O2$class)
amoAClean_CO2CH4_tbl_long_O2$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_O2$order)
amoAClean_CO2CH4_tbl_long_O2$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_O2$family)
amoAClean_CO2CH4_tbl_long_O2$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_O2$genus)
amoAClean_CO2CH4_tbl_long_O2$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_O2$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_O2$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_O2$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$class, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$order, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$family, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_O2$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_O2$genome)

O2_taxa_MG.df = amoAClean_CO2CH4_tbl_long_O2 %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(O2_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_O2.csv")

#O2_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_O2.csv")

#Clean up for plot
O2_taxa_MG.df$station_km = as.numeric(as.character(O2_taxa_MG.df$station_km))


O2_taxa_MG.df$Sample_date = factor(O2_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

O2_taxa_MG.sum = Rmisc::summarySE(O2_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/O2_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(O2_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(O2_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = sort(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")))

test[order(-test$N), ]

unique(O2_taxa_MG.df$fulltaxa)



#### Metatranscriptomes ####



#Extract relevant genes
O2_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "O2_uM")[,1])
#O2_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_O2 = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% O2_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_O2)
#View(amoAClean_geneabund_KO_O2)

amoAClean_CO2CH4_tbl_long_O2 <- amoAClean_geneabund_KO_O2 %>%
  filter(KO %in% O2_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_O2$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_O2$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_O2$data_type)
amoAClean_CO2CH4_tbl_long_O2$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_O2$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_O2.df <- spread(amoAClean_CO2CH4_tbl_long_O2[ , ! names(amoAClean_CO2CH4_tbl_long_O2) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_O2)
dim(CO2CH4_TG_O2.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_O2.df$TranscriptsPerGenome = CO2CH4_TG_O2.df$Transcriptomes / CO2CH4_TG_O2.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_O2.df = CO2CH4_TG_O2.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuO2ly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_O2.lng = gather(CO2CH4_TG_O2.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_O2.lng = subset(CO2CH4_TG_O2.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_O2.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_O2.lng = subset(CO2CH4_TG_O2.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_O2.lng = subset(CO2CH4_TG_O2.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_O2.lng$counts = as.numeric(as.character(CO2CH4_TG_O2.lng$counts))
CO2CH4_TG_O2.lng$Associatednumber = as.character(CO2CH4_TG_O2.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_O2.lng$counts = CO2CH4_TG_O2.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_O2.lng$domain = gsub("d__", "", CO2CH4_TG_O2.lng$domain)
CO2CH4_TG_O2.lng$phylum = gsub("p__", "", CO2CH4_TG_O2.lng$phylum)
CO2CH4_TG_O2.lng$class = gsub("c__", "", CO2CH4_TG_O2.lng$class)
CO2CH4_TG_O2.lng$order = gsub("o__", "", CO2CH4_TG_O2.lng$order)
CO2CH4_TG_O2.lng$family = gsub("f__", "", CO2CH4_TG_O2.lng$family)
CO2CH4_TG_O2.lng$genus = gsub("g__", "", CO2CH4_TG_O2.lng$genus)
CO2CH4_TG_O2.lng$species = gsub("s__", "", CO2CH4_TG_O2.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_O2.lng$fulltaxa = paste0(CO2CH4_TG_O2.lng$domain, "__",
                                                CO2CH4_TG_O2.lng$phylum, "__",
                                                CO2CH4_TG_O2.lng$class, "__",
                                                CO2CH4_TG_O2.lng$order, "__",
                                                CO2CH4_TG_O2.lng$family, "__",
                                                CO2CH4_TG_O2.lng$genus, "__",
                                                CO2CH4_TG_O2.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_O2.lng$fulltaxa)
unique(CO2CH4_TG_O2.lng$genome)

O2_taxa_MT.df = CO2CH4_TG_O2.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(O2_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_O2_TG.csv")

#O2_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_O2_TG.csv")

#Clean up for plot
O2_taxa_MT.df$station_km = as.numeric(as.character(O2_taxa_MT.df$station_km))


O2_taxa_MT.df$Sample_date = factor(O2_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

O2_taxa_MT.sum = Rmisc::summarySE(O2_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/O2_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(O2_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(O2_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]

unique(O2_taxa_MT.sum$fulltaxa)


```
```{r dCO2 MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
dCO2_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "dCO2_uM")[,1])
#dCO2_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_dCO2 = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% dCO2_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_dCO2)
#View(amoAClean_geneabund_KO_dCO2)

amoAClean_CO2CH4_tbl_long_dCO2 <- amoAClean_geneabund_KO_dCO2 %>%
  filter(KO %in% dCO2_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_dCO2$counts = amoAClean_CO2CH4_tbl_long_dCO2$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_dCO2$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_dCO2$domain)
amoAClean_CO2CH4_tbl_long_dCO2$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_dCO2$phylum)
amoAClean_CO2CH4_tbl_long_dCO2$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_dCO2$class)
amoAClean_CO2CH4_tbl_long_dCO2$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_dCO2$order)
amoAClean_CO2CH4_tbl_long_dCO2$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_dCO2$family)
amoAClean_CO2CH4_tbl_long_dCO2$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_dCO2$genus)
amoAClean_CO2CH4_tbl_long_dCO2$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_dCO2$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_dCO2$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_dCO2$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$class, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$order, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$family, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_dCO2$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_dCO2$genome)

dCO2_taxa_MG.df = amoAClean_CO2CH4_tbl_long_dCO2 %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(dCO2_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_dCO2.csv")

#dCO2_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_dCO2.csv")

#Clean up for plot
dCO2_taxa_MG.df$station_km = as.numeric(as.character(dCO2_taxa_MG.df$station_km))


dCO2_taxa_MG.df$Sample_date = factor(dCO2_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

dCO2_taxa_MG.sum = Rmisc::summarySE(dCO2_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/dCO2_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(dCO2_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(dCO2_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(dCO2_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
dCO2_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "dCO2_uM")[,1])
#dCO2_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_dCO2 = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% dCO2_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_dCO2)
#View(amoAClean_geneabund_KO_dCO2)

amoAClean_CO2CH4_tbl_long_dCO2 <- amoAClean_geneabund_KO_dCO2 %>%
  filter(KO %in% dCO2_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_dCO2$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_dCO2$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_dCO2$data_type)
amoAClean_CO2CH4_tbl_long_dCO2$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_dCO2$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_dCO2.df <- spread(amoAClean_CO2CH4_tbl_long_dCO2[ , ! names(amoAClean_CO2CH4_tbl_long_dCO2) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_dCO2)
dim(CO2CH4_TG_dCO2.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_dCO2.df$TranscriptsPerGenome = CO2CH4_TG_dCO2.df$Transcriptomes / CO2CH4_TG_dCO2.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_dCO2.df = CO2CH4_TG_dCO2.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usudCO2ly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_dCO2.lng = gather(CO2CH4_TG_dCO2.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_dCO2.lng = subset(CO2CH4_TG_dCO2.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_dCO2.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_dCO2.lng = subset(CO2CH4_TG_dCO2.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_dCO2.lng = subset(CO2CH4_TG_dCO2.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_dCO2.lng$counts = as.numeric(as.character(CO2CH4_TG_dCO2.lng$counts))
CO2CH4_TG_dCO2.lng$Associatednumber = as.character(CO2CH4_TG_dCO2.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_dCO2.lng$counts = CO2CH4_TG_dCO2.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_dCO2.lng$domain = gsub("d__", "", CO2CH4_TG_dCO2.lng$domain)
CO2CH4_TG_dCO2.lng$phylum = gsub("p__", "", CO2CH4_TG_dCO2.lng$phylum)
CO2CH4_TG_dCO2.lng$class = gsub("c__", "", CO2CH4_TG_dCO2.lng$class)
CO2CH4_TG_dCO2.lng$order = gsub("o__", "", CO2CH4_TG_dCO2.lng$order)
CO2CH4_TG_dCO2.lng$family = gsub("f__", "", CO2CH4_TG_dCO2.lng$family)
CO2CH4_TG_dCO2.lng$genus = gsub("g__", "", CO2CH4_TG_dCO2.lng$genus)
CO2CH4_TG_dCO2.lng$species = gsub("s__", "", CO2CH4_TG_dCO2.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_dCO2.lng$fulltaxa = paste0(CO2CH4_TG_dCO2.lng$domain, "__",
                                                CO2CH4_TG_dCO2.lng$phylum, "__",
                                                CO2CH4_TG_dCO2.lng$class, "__",
                                                CO2CH4_TG_dCO2.lng$order, "__",
                                                CO2CH4_TG_dCO2.lng$family, "__",
                                                CO2CH4_TG_dCO2.lng$genus, "__",
                                                CO2CH4_TG_dCO2.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_dCO2.lng$fulltaxa)
unique(CO2CH4_TG_dCO2.lng$genome)

dCO2_taxa_MT.df = CO2CH4_TG_dCO2.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(dCO2_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_dCO2_TG.csv")

dCO2_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_dCO2_TG.csv")

#Clean up for plot
dCO2_taxa_MT.df$station_km = as.numeric(as.character(dCO2_taxa_MT.df$station_km))


dCO2_taxa_MT.df$Sample_date = factor(dCO2_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

dCO2_taxa_MT.sum = Rmisc::summarySE(dCO2_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/dCO2_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(dCO2_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(dCO2_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(dCO2_taxa_MT.sum$fulltaxa)

```
```{r Temperature MAG matching - MG + MT }

taxa = taxa %>%
  distinct()
 
#### Metagenomes ####

#Extract relevant genes
Temp_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Temperature_TBDHereon")[,1])
#Temp_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Temp = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Temp_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Temp)
#View(amoAClean_geneabund_KO_Temp)

amoAClean_CO2CH4_tbl_long_Temp <- amoAClean_geneabund_KO_Temp %>%
  filter(KO %in% Temp_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_Temp$counts = amoAClean_CO2CH4_tbl_long_Temp$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_Temp$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_Temp$domain)
amoAClean_CO2CH4_tbl_long_Temp$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_Temp$phylum)
amoAClean_CO2CH4_tbl_long_Temp$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_Temp$class)
amoAClean_CO2CH4_tbl_long_Temp$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_Temp$order)
amoAClean_CO2CH4_tbl_long_Temp$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_Temp$family)
amoAClean_CO2CH4_tbl_long_Temp$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_Temp$genus)
amoAClean_CO2CH4_tbl_long_Temp$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_Temp$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_Temp$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_Temp$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$class, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$order, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$family, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Temp$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Temp$genome)

Temp_taxa_MG.df = amoAClean_CO2CH4_tbl_long_Temp %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Temp_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Temp.csv")

#Temp_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Temp.csv")

#Clean up for plot
Temp_taxa_MG.df$station_km = as.numeric(as.character(Temp_taxa_MG.df$station_km))


Temp_taxa_MG.df$Sample_date = factor(Temp_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Temp_taxa_MG.sum = Rmisc::summarySE(Temp_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Temp_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Temp_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Temp_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Temp_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
Temp_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Temperature_TBDHereon")[,1])
#Temp_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Temp = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Temp_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Temp)
#View(amoAClean_geneabund_KO_Temp)

amoAClean_CO2CH4_tbl_long_Temp <- amoAClean_geneabund_KO_Temp %>%
  filter(KO %in% Temp_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_Temp$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Temp$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Temp$data_type)
amoAClean_CO2CH4_tbl_long_Temp$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Temp$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Temp.df <- spread(amoAClean_CO2CH4_tbl_long_Temp[ , ! names(amoAClean_CO2CH4_tbl_long_Temp) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Temp)
dim(CO2CH4_TG_Temp.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Temp.df$TranscriptsPerGenome = CO2CH4_TG_Temp.df$Transcriptomes / CO2CH4_TG_Temp.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Temp.df = CO2CH4_TG_Temp.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuTemply the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Temp.lng = gather(CO2CH4_TG_Temp.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_Temp.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Temp.lng$counts = as.numeric(as.character(CO2CH4_TG_Temp.lng$counts))
CO2CH4_TG_Temp.lng$Associatednumber = as.character(CO2CH4_TG_Temp.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_Temp.lng$counts = CO2CH4_TG_Temp.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_Temp.lng$domain = gsub("d__", "", CO2CH4_TG_Temp.lng$domain)
CO2CH4_TG_Temp.lng$phylum = gsub("p__", "", CO2CH4_TG_Temp.lng$phylum)
CO2CH4_TG_Temp.lng$class = gsub("c__", "", CO2CH4_TG_Temp.lng$class)
CO2CH4_TG_Temp.lng$order = gsub("o__", "", CO2CH4_TG_Temp.lng$order)
CO2CH4_TG_Temp.lng$family = gsub("f__", "", CO2CH4_TG_Temp.lng$family)
CO2CH4_TG_Temp.lng$genus = gsub("g__", "", CO2CH4_TG_Temp.lng$genus)
CO2CH4_TG_Temp.lng$species = gsub("s__", "", CO2CH4_TG_Temp.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_Temp.lng$fulltaxa = paste0(CO2CH4_TG_Temp.lng$domain, "__",
                                                CO2CH4_TG_Temp.lng$phylum, "__",
                                                CO2CH4_TG_Temp.lng$class, "__",
                                                CO2CH4_TG_Temp.lng$order, "__",
                                                CO2CH4_TG_Temp.lng$family, "__",
                                                CO2CH4_TG_Temp.lng$genus, "__",
                                                CO2CH4_TG_Temp.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_Temp.lng$fulltaxa)
unique(CO2CH4_TG_Temp.lng$genome)

Temp_taxa_MT.df = CO2CH4_TG_Temp.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Temp_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Temp_TG.csv")

#Temp_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Temp_TG.csv")

#Clean up for plot
Temp_taxa_MT.df$station_km = as.numeric(as.character(Temp_taxa_MT.df$station_km))


Temp_taxa_MT.df$Sample_date = factor(Temp_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Temp_taxa_MT.sum = Rmisc::summarySE(Temp_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Temp_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Temp_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Temp_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(Temp_taxa_MT.sum$fulltaxa)

```
```{r Nitrate MAG matching - MG + MT }

taxa = taxa %>%
  distinct()
 
#### Metagenomes ####

#Extract relevant genes
Nitrate_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Nitrate_mg.L")[,1])
#Nitrate_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Nitrate = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Nitrate_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Nitrate)
#View(amoAClean_geneabund_KO_Nitrate)

amoAClean_CO2CH4_tbl_long_Nitrate <- amoAClean_geneabund_KO_Nitrate %>%
  filter(KO %in% Nitrate_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_Nitrate$counts = amoAClean_CO2CH4_tbl_long_Nitrate$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_Nitrate$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_Nitrate$domain)
amoAClean_CO2CH4_tbl_long_Nitrate$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_Nitrate$phylum)
amoAClean_CO2CH4_tbl_long_Nitrate$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_Nitrate$class)
amoAClean_CO2CH4_tbl_long_Nitrate$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_Nitrate$order)
amoAClean_CO2CH4_tbl_long_Nitrate$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_Nitrate$family)
amoAClean_CO2CH4_tbl_long_Nitrate$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_Nitrate$genus)
amoAClean_CO2CH4_tbl_long_Nitrate$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_Nitrate$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_Nitrate$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_Nitrate$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$class, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$order, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$family, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Nitrate$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Nitrate$genome)

Nitrate_taxa_MG.df = amoAClean_CO2CH4_tbl_long_Nitrate %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Nitrate_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Nitrate.csv")

#Nitrate_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Nitrate.csv")

#Clean up for plot
Nitrate_taxa_MG.df$station_km = as.numeric(as.character(Nitrate_taxa_MG.df$station_km))


Nitrate_taxa_MG.df$Sample_date = factor(Nitrate_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Nitrate_taxa_MG.sum = Rmisc::summarySE(Nitrate_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Nitrate_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Nitrate_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Nitrate_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Nitrate_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
Nitrate_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Nitrate_mg.L")[,1])
#Nitrate_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Nitrate = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Nitrate_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Nitrate)
#View(amoAClean_geneabund_KO_Nitrate)

amoAClean_CO2CH4_tbl_long_Nitrate <- amoAClean_geneabund_KO_Nitrate %>%
  filter(KO %in% Nitrate_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_Nitrate$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Nitrate$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Nitrate$data_type)
amoAClean_CO2CH4_tbl_long_Nitrate$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Nitrate$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Nitrate.df <- spread(amoAClean_CO2CH4_tbl_long_Nitrate[ , ! names(amoAClean_CO2CH4_tbl_long_Nitrate) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Nitrate)
dim(CO2CH4_TG_Nitrate.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Nitrate.df$TranscriptsPerGenome = CO2CH4_TG_Nitrate.df$Transcriptomes / CO2CH4_TG_Nitrate.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Nitrate.df = CO2CH4_TG_Nitrate.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuNitrately the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Nitrate.lng = gather(CO2CH4_TG_Nitrate.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Nitrate.lng = subset(CO2CH4_TG_Nitrate.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_Nitrate.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Nitrate.lng = subset(CO2CH4_TG_Nitrate.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Nitrate.lng = subset(CO2CH4_TG_Nitrate.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Nitrate.lng$counts = as.numeric(as.character(CO2CH4_TG_Nitrate.lng$counts))
CO2CH4_TG_Nitrate.lng$Associatednumber = as.character(CO2CH4_TG_Nitrate.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_Nitrate.lng$counts = CO2CH4_TG_Nitrate.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_Nitrate.lng$domain = gsub("d__", "", CO2CH4_TG_Nitrate.lng$domain)
CO2CH4_TG_Nitrate.lng$phylum = gsub("p__", "", CO2CH4_TG_Nitrate.lng$phylum)
CO2CH4_TG_Nitrate.lng$class = gsub("c__", "", CO2CH4_TG_Nitrate.lng$class)
CO2CH4_TG_Nitrate.lng$order = gsub("o__", "", CO2CH4_TG_Nitrate.lng$order)
CO2CH4_TG_Nitrate.lng$family = gsub("f__", "", CO2CH4_TG_Nitrate.lng$family)
CO2CH4_TG_Nitrate.lng$genus = gsub("g__", "", CO2CH4_TG_Nitrate.lng$genus)
CO2CH4_TG_Nitrate.lng$species = gsub("s__", "", CO2CH4_TG_Nitrate.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_Nitrate.lng$fulltaxa = paste0(CO2CH4_TG_Nitrate.lng$domain, "__",
                                                CO2CH4_TG_Nitrate.lng$phylum, "__",
                                                CO2CH4_TG_Nitrate.lng$class, "__",
                                                CO2CH4_TG_Nitrate.lng$order, "__",
                                                CO2CH4_TG_Nitrate.lng$family, "__",
                                                CO2CH4_TG_Nitrate.lng$genus, "__",
                                                CO2CH4_TG_Nitrate.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_Nitrate.lng$fulltaxa)
unique(CO2CH4_TG_Nitrate.lng$genome)

Nitrate_taxa_MT.df = CO2CH4_TG_Nitrate.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Nitrate_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Nitrate_TG.csv")

#Nitrate_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Nitrate_TG.csv")

#Clean up for plot
Nitrate_taxa_MT.df$station_km = as.numeric(as.character(Nitrate_taxa_MT.df$station_km))


Nitrate_taxa_MT.df$Sample_date = factor(Nitrate_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Nitrate_taxa_MT.sum = Rmisc::summarySE(Nitrate_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Nitrate_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Nitrate_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Nitrate_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(Nitrate_taxa_MT.sum$fulltaxa)

```
```{r Turbidity MAG matching - MG + MT }

taxa = taxa %>%
  distinct()
 
#### Metagenomes ####

#Extract relevant genes
Turb_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Turbidity_NTU")[,1])
#Turb_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Turb = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Turb_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Turb)
#View(amoAClean_geneabund_KO_Turb)

amoAClean_CO2CH4_tbl_long_Turb <- amoAClean_geneabund_KO_Turb %>%
  filter(KO %in% Turb_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_Turb$counts = amoAClean_CO2CH4_tbl_long_Turb$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_Turb$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_Turb$domain)
amoAClean_CO2CH4_tbl_long_Turb$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_Turb$phylum)
amoAClean_CO2CH4_tbl_long_Turb$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_Turb$class)
amoAClean_CO2CH4_tbl_long_Turb$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_Turb$order)
amoAClean_CO2CH4_tbl_long_Turb$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_Turb$family)
amoAClean_CO2CH4_tbl_long_Turb$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_Turb$genus)
amoAClean_CO2CH4_tbl_long_Turb$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_Turb$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_Turb$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_Turb$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$class, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$order, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$family, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Turb$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Turb$genome)

Turb_taxa_MG.df = amoAClean_CO2CH4_tbl_long_Turb %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Turb_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Turb.csv")

#Turb_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Turb.csv")

#Clean up for plot
Turb_taxa_MG.df$station_km = as.numeric(as.character(Turb_taxa_MG.df$station_km))


Turb_taxa_MG.df$Sample_date = factor(Turb_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Turb_taxa_MG.sum = Rmisc::summarySE(Turb_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Turb_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Turb_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Turb_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Turb_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
Turb_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Turbidity_NTU")[,1])
#Turb_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Turb = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Turb_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Turb)
#View(amoAClean_geneabund_KO_Turb)

amoAClean_CO2CH4_tbl_long_Turb <- amoAClean_geneabund_KO_Turb %>%
  filter(KO %in% Turb_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_Turb$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Turb$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Turb$data_type)
amoAClean_CO2CH4_tbl_long_Turb$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Turb$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Turb.df <- spread(amoAClean_CO2CH4_tbl_long_Turb[ , ! names(amoAClean_CO2CH4_tbl_long_Turb) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Turb)
dim(CO2CH4_TG_Turb.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Turb.df$TranscriptsPerGenome = CO2CH4_TG_Turb.df$Transcriptomes / CO2CH4_TG_Turb.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Turb.df = CO2CH4_TG_Turb.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuTurbly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Turb.lng = gather(CO2CH4_TG_Turb.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_Turb.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Turb.lng$counts = as.numeric(as.character(CO2CH4_TG_Turb.lng$counts))
CO2CH4_TG_Turb.lng$Associatednumber = as.character(CO2CH4_TG_Turb.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_Turb.lng$counts = CO2CH4_TG_Turb.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_Turb.lng$domain = gsub("d__", "", CO2CH4_TG_Turb.lng$domain)
CO2CH4_TG_Turb.lng$phylum = gsub("p__", "", CO2CH4_TG_Turb.lng$phylum)
CO2CH4_TG_Turb.lng$class = gsub("c__", "", CO2CH4_TG_Turb.lng$class)
CO2CH4_TG_Turb.lng$order = gsub("o__", "", CO2CH4_TG_Turb.lng$order)
CO2CH4_TG_Turb.lng$family = gsub("f__", "", CO2CH4_TG_Turb.lng$family)
CO2CH4_TG_Turb.lng$genus = gsub("g__", "", CO2CH4_TG_Turb.lng$genus)
CO2CH4_TG_Turb.lng$species = gsub("s__", "", CO2CH4_TG_Turb.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_Turb.lng$fulltaxa = paste0(CO2CH4_TG_Turb.lng$domain, "__",
                                                CO2CH4_TG_Turb.lng$phylum, "__",
                                                CO2CH4_TG_Turb.lng$class, "__",
                                                CO2CH4_TG_Turb.lng$order, "__",
                                                CO2CH4_TG_Turb.lng$family, "__",
                                                CO2CH4_TG_Turb.lng$genus, "__",
                                                CO2CH4_TG_Turb.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_Turb.lng$fulltaxa)
unique(CO2CH4_TG_Turb.lng$genome)

Turb_taxa_MT.df = CO2CH4_TG_Turb.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Turb_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Turb_TG.csv")

#Turb_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Turb_TG.csv")

#Clean up for plot
Turb_taxa_MT.df$station_km = as.numeric(as.character(Turb_taxa_MT.df$station_km))


Turb_taxa_MT.df$Sample_date = factor(Turb_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Turb_taxa_MT.sum = Rmisc::summarySE(Turb_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Turb_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Turb_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Turb_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(Turb_taxa_MT.sum$fulltaxa)

```

```{r All_Water water MAG matching - MG + MT}
Results.df = read.csv("F:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

#### Metagenomes ####

#Extract relevant genes
All_Water_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter!= "All_Water_uM")[,1])


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_All_Water = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% All_Water_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_All_Water)
#View(amoAClean_geneabund_KO_All_Water)

amoAClean_CO2CH4_tbl_long_All_Water <- amoAClean_geneabund_KO_All_Water %>%
  filter(KO %in% All_Water_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_All_Water$counts = amoAClean_CO2CH4_tbl_long_All_Water$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_All_Water$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_All_Water$domain)
amoAClean_CO2CH4_tbl_long_All_Water$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_All_Water$phylum)
amoAClean_CO2CH4_tbl_long_All_Water$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_All_Water$class)
amoAClean_CO2CH4_tbl_long_All_Water$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_All_Water$order)
amoAClean_CO2CH4_tbl_long_All_Water$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_All_Water$family)
amoAClean_CO2CH4_tbl_long_All_Water$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_All_Water$genus)
amoAClean_CO2CH4_tbl_long_All_Water$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_All_Water$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_All_Water$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_All_Water$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$class, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$order, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$family, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_All_Water$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_All_Water$genome)

All_Water_taxa_MG.df = amoAClean_CO2CH4_tbl_long_All_Water %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(All_Water_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_All_Water.csv")

#All_Water_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_All_Water.csv")

#Clean up for plot
All_Water_taxa_MG.df$station_km = as.numeric(as.character(All_Water_taxa_MG.df$station_km))


All_Water_taxa_MG.df$Sample_date = factor(All_Water_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

All_Water_taxa_MG.sum = Rmisc::summarySE(All_Water_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/All_Water_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(All_Water_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(All_Water_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(All_Water_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
All_Water_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter!= "All_Water_uM")[,1])
#All_Water_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_All_Water = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% All_Water_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_All_Water)
#View(amoAClean_geneabund_KO_All_Water)

amoAClean_CO2CH4_tbl_long_All_Water <- amoAClean_geneabund_KO_All_Water %>%
  filter(KO %in% All_Water_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_All_Water$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_All_Water$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_All_Water$data_type)
amoAClean_CO2CH4_tbl_long_All_Water$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_All_Water$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_All_Water.df <- spread(amoAClean_CO2CH4_tbl_long_All_Water[ , ! names(amoAClean_CO2CH4_tbl_long_All_Water) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_All_Water)
dim(CO2CH4_TG_All_Water.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_All_Water.df$TranscriptsPerGenome = CO2CH4_TG_All_Water.df$Transcriptomes / CO2CH4_TG_All_Water.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_All_Water.df = CO2CH4_TG_All_Water.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuAll_Waterly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_All_Water.lng = gather(CO2CH4_TG_All_Water.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_All_Water.lng = subset(CO2CH4_TG_All_Water.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_All_Water.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_All_Water.lng = subset(CO2CH4_TG_All_Water.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_All_Water.lng = subset(CO2CH4_TG_All_Water.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_All_Water.lng$counts = as.numeric(as.character(CO2CH4_TG_All_Water.lng$counts))
CO2CH4_TG_All_Water.lng$Associatednumber = as.character(CO2CH4_TG_All_Water.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_All_Water.lng$counts = CO2CH4_TG_All_Water.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_All_Water.lng$domain = gsub("d__", "", CO2CH4_TG_All_Water.lng$domain)
CO2CH4_TG_All_Water.lng$phylum = gsub("p__", "", CO2CH4_TG_All_Water.lng$phylum)
CO2CH4_TG_All_Water.lng$class = gsub("c__", "", CO2CH4_TG_All_Water.lng$class)
CO2CH4_TG_All_Water.lng$order = gsub("o__", "", CO2CH4_TG_All_Water.lng$order)
CO2CH4_TG_All_Water.lng$family = gsub("f__", "", CO2CH4_TG_All_Water.lng$family)
CO2CH4_TG_All_Water.lng$genus = gsub("g__", "", CO2CH4_TG_All_Water.lng$genus)
CO2CH4_TG_All_Water.lng$species = gsub("s__", "", CO2CH4_TG_All_Water.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_All_Water.lng$fulltaxa = paste0(CO2CH4_TG_All_Water.lng$domain, "__",
                                                CO2CH4_TG_All_Water.lng$phylum, "__",
                                                CO2CH4_TG_All_Water.lng$class, "__",
                                                CO2CH4_TG_All_Water.lng$order, "__",
                                                CO2CH4_TG_All_Water.lng$family, "__",
                                                CO2CH4_TG_All_Water.lng$genus, "__",
                                                CO2CH4_TG_All_Water.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_All_Water.lng$fulltaxa)
unique(CO2CH4_TG_All_Water.lng$genome)

All_Water_taxa_MT.df = CO2CH4_TG_All_Water.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(All_Water_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_All_Water_TG.csv")

All_Water_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_All_Water_TG.csv")

#Clean up for plot
All_Water_taxa_MT.df$station_km = as.numeric(as.character(All_Water_taxa_MT.df$station_km))


All_Water_taxa_MT.df$Sample_date = factor(All_Water_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

All_Water_taxa_MT.sum = Rmisc::summarySE(All_Water_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/All_Water_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(All_Water_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(All_Water_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(All_Water_taxa_MT.sum$fulltaxa)

```
```{r All_particles water MAG matching - MG + MT}

Results.df = read.csv("F:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

#### Metagenomes ####

#Extract relevant genes
All_particles_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter!= "All_particles_uM")[,1])


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_All_particles = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% All_particles_genes_MG.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_All_particles)
#View(amoAClean_geneabund_KO_All_particles)

amoAClean_CO2CH4_tbl_long_All_particles <- amoAClean_geneabund_KO_All_particles %>%
  filter(KO %in% All_particles_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_All_particles$counts = amoAClean_CO2CH4_tbl_long_All_particles$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_All_particles$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_All_particles$domain)
amoAClean_CO2CH4_tbl_long_All_particles$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_All_particles$phylum)
amoAClean_CO2CH4_tbl_long_All_particles$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_All_particles$class)
amoAClean_CO2CH4_tbl_long_All_particles$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_All_particles$order)
amoAClean_CO2CH4_tbl_long_All_particles$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_All_particles$family)
amoAClean_CO2CH4_tbl_long_All_particles$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_All_particles$genus)
amoAClean_CO2CH4_tbl_long_All_particles$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_All_particles$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_All_particles$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_All_particles$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$class, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$order, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$family, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_All_particles$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_All_particles$genome)

All_particles_taxa_MG.df = amoAClean_CO2CH4_tbl_long_All_particles %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(All_particles_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_All_particles.csv")

#All_particles_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_All_particles.csv")

#Clean up for plot
All_particles_taxa_MG.df$station_km = as.numeric(as.character(All_particles_taxa_MG.df$station_km))


All_particles_taxa_MG.df$Sample_date = factor(All_particles_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

All_particles_taxa_MG.sum = Rmisc::summarySE(All_particles_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/All_particles_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(All_particles_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(All_particles_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(All_particles_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
All_particles_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter!= "All_particles_uM")[,1])
#All_particles_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_All_particles = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% All_particles_genes_MT.ls) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_All_particles)
#View(amoAClean_geneabund_KO_All_particles)

amoAClean_CO2CH4_tbl_long_All_particles <- amoAClean_geneabund_KO_All_particles %>%
  filter(KO %in% All_particles_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_All_particles$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_All_particles$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_All_particles$data_type)
amoAClean_CO2CH4_tbl_long_All_particles$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_All_particles$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_All_particles.df <- spread(amoAClean_CO2CH4_tbl_long_All_particles[ , ! names(amoAClean_CO2CH4_tbl_long_All_particles) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_All_particles)
dim(CO2CH4_TG_All_particles.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_All_particles.df$TranscriptsPerGenome = CO2CH4_TG_All_particles.df$Transcriptomes / CO2CH4_TG_All_particles.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_All_particles.df = CO2CH4_TG_All_particles.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuAll_particlesly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_All_particles.lng = gather(CO2CH4_TG_All_particles.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_All_particles.lng = subset(CO2CH4_TG_All_particles.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_All_particles.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_All_particles.lng = subset(CO2CH4_TG_All_particles.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_All_particles.lng = subset(CO2CH4_TG_All_particles.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_All_particles.lng$counts = as.numeric(as.character(CO2CH4_TG_All_particles.lng$counts))
CO2CH4_TG_All_particles.lng$Associatednumber = as.character(CO2CH4_TG_All_particles.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_All_particles.lng$counts = CO2CH4_TG_All_particles.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_All_particles.lng$domain = gsub("d__", "", CO2CH4_TG_All_particles.lng$domain)
CO2CH4_TG_All_particles.lng$phylum = gsub("p__", "", CO2CH4_TG_All_particles.lng$phylum)
CO2CH4_TG_All_particles.lng$class = gsub("c__", "", CO2CH4_TG_All_particles.lng$class)
CO2CH4_TG_All_particles.lng$order = gsub("o__", "", CO2CH4_TG_All_particles.lng$order)
CO2CH4_TG_All_particles.lng$family = gsub("f__", "", CO2CH4_TG_All_particles.lng$family)
CO2CH4_TG_All_particles.lng$genus = gsub("g__", "", CO2CH4_TG_All_particles.lng$genus)
CO2CH4_TG_All_particles.lng$species = gsub("s__", "", CO2CH4_TG_All_particles.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_All_particles.lng$fulltaxa = paste0(CO2CH4_TG_All_particles.lng$domain, "__",
                                                CO2CH4_TG_All_particles.lng$phylum, "__",
                                                CO2CH4_TG_All_particles.lng$class, "__",
                                                CO2CH4_TG_All_particles.lng$order, "__",
                                                CO2CH4_TG_All_particles.lng$family, "__",
                                                CO2CH4_TG_All_particles.lng$genus, "__",
                                                CO2CH4_TG_All_particles.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_All_particles.lng$fulltaxa)
unique(CO2CH4_TG_All_particles.lng$genome)

All_particles_taxa_MT.df = CO2CH4_TG_All_particles.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(All_particles_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_All_particles_TG.csv")

All_particles_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_All_particles_TG.csv")

#Clean up for plot
All_particles_taxa_MT.df$station_km = as.numeric(as.character(All_particles_taxa_MT.df$station_km))


All_particles_taxa_MT.df$Sample_date = factor(All_particles_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

All_particles_taxa_MT.sum = Rmisc::summarySE(All_particles_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/All_particles_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(All_particles_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(All_particles_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(All_particles_taxa_MT.sum$fulltaxa)

```

##Extract KO correlated MAG taxa names for mOTU matching
```{r}

dim(Results_MG_water.df)
dim(Results_MG_particles.df)
dim(Results_MT_water.df)
dim(Results_MT_particles.df)

#### CSP ####

dim(CSP_taxa_MG.sum)
dim(CSP_taxa_MT.sum)

MG_MT_taxa.df = subset(CSP_taxa_MT.sum, fulltaxa %in% CSP_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_CSP.csv")


#### PTN ####

dim(PTN_taxa_MG.sum)
dim(PTN_taxa_MT.sum)

MG_MT_taxa.df = subset(PTN_taxa_MT.sum, fulltaxa %in% PTN_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_PTN.csv")


#### POC ####

dim(POC_taxa_MG.sum)
dim(POC_taxa_MT.sum)

MG_MT_taxa.df = subset(POC_taxa_MT.sum, fulltaxa %in% POC_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_POC.csv")


#### SPM ####

dim(SPM_taxa_MG.sum)
dim(SPM_taxa_MT.sum)

MG_MT_taxa.df = subset(SPM_taxa_MT.sum, fulltaxa %in% SPM_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_SPM.csv")


#### Salinity ####

dim(Sal_taxa.sum)
dim(Sal_taxa_MT.sum)

MG_MT_taxa.df = subset(Sal_taxa_MT.sum, fulltaxa %in% Sal_taxa.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_Sal.csv")


#### O2 ####

dim(O2_taxa_MG.sum)
dim(O2_taxa_MT.sum)

MG_MT_taxa.df = subset(O2_taxa_MT.sum, fulltaxa %in% O2_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_O2.csv")



#### dCO2 ####

dim(dCO2_taxa_MG.sum)
dim(dCO2_taxa_MT.sum)

MG_MT_taxa.df = subset(dCO2_taxa_MT.sum, fulltaxa %in% dCO2_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_dCO2.csv")

 
#### Temperature ####

dim(Temp_taxa_MG.sum)
dim(Temp_taxa_MT.sum)

MG_MT_taxa.df = subset(Temp_taxa_MT.sum, fulltaxa %in% Temp_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_Temp.csv")


#### Turbidity ####

dim(Turb_taxa_MG.sum)
dim(Turb_taxa_MT.sum)

MG_MT_taxa.df = subset(Turb_taxa_MT.sum, fulltaxa %in% Turb_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_Turb.csv")


#### Nitrate ####

dim(Nitrate_taxa_MG.sum)
dim(Nitrate_taxa_MT.sum)

MG_MT_taxa.df = subset(Nitrate_taxa_MT.sum, fulltaxa %in% Nitrate_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_Nitrate.csv")


```


#WGCNA
##Prep metadata
```{r}


#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("E:/Functional_R_analysis/PhysicochemicalParameters_mod2.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Add PA PP to Free-living rows 

#Extract sample numbers for FL - MG
FL_samples.df = Physicochem.df %>%
  filter(Sample_type == "Free_living")
PA_PP.ls = c("SPM_mgperL", "POC_mgperL", "PTC_mgperL", "PTN_mgperL", "PTH_mgperL", "TEP_um2perL", "CSP_um2perL")
count = 1
i=6
x="SPM_mgperL"
for (i in 1:length(Physicochem.df$Associatednumber)) {
  if (grepl(Physicochem.df$Sample_type[i], "Free_living") == T ) {
    #Bug hunting
    #print(paste0("Match ",count, " found"))
    PA_sub.df = subset(Physicochem.df, Sample_type!="Free_living" & 
                         station_km == Physicochem.df$station_km[i] & 
                         Sample_date == Physicochem.df$Sample_date[i])
    for (x in PA_PP.ls) {
      #Bug hunting
      #print(paste0("Matching ", x))
      mean.tmp = mean(unlist(PA_sub.df[x]))
      #Bug hunt
      #print(paste0("Getting ", mean.tmp))
      Physicochem.df[i,x] = mean(unlist(PA_sub.df[x]))
    }
    count = count + 1
  }
}

Physicochem.df$Associatednumber = as.character(Physicochem.df$Associatednumber)

metadata_WGCNA = Physicochem.df %>%
  dplyr::select(Associatednumber, station_km, Sample_type, Sample_date, 
         SPM_mgperL, DOC_mg.L, TN_mg.L, DIC_mg.L, POC_mgperL, PTC_mgperL, PTN_mgperL,
         Sat_O2_Perc, Temperature_TBDHereon, Salinity_PSU, Turbidity_NTU, pH, O2_uM, Silicate_mg.L, Ammonium_mg.L,
         Nitrite_mg.L, Nitrate_mg.L, Total_DIN_uM, SRP_mgperL, TotalDissolvedPhosphate_mg.L,
         TEP_um2perL, CSP_um2perL, dCH4_nM, dCO2_uM) %>%
  distinct()

metadata_WGCNA$Sample_date = gsub(" ","_", metadata_WGCNA$Sample_date)

```

##Set up physicochemical characteristics
```{r}

#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("E:/Functional_R_analysis/PhysicochemicalParameters_mod2.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Add PA PP to Free-living rows 

#Extract sample numbers for FL - MG
FL_samples.df = Physicochem.df %>%
  filter(Sample_type == "Free_living")
PA_PP.ls = c("SPM_mgperL", "POC_mgperL", "PTC_mgperL", "PTN_mgperL", "PTH_mgperL", "TEP_um2perL", "CSP_um2perL")
count = 1
i=6
x="SPM_mgperL"
for (i in 1:length(Physicochem.df$Associatednumber)) {
  if (grepl(Physicochem.df$Sample_type[i], "Free_living") == T ) {
    #Bug hunting
    #print(paste0("Match ",count, " found"))
    PA_sub.df = subset(Physicochem.df, Sample_type!="Free_living" & 
                         station_km == Physicochem.df$station_km[i] & 
                         Sample_date == Physicochem.df$Sample_date[i])
    for (x in PA_PP.ls) {
      #Bug hunting
      #print(paste0("Matching ", x))
      mean.tmp = mean(unlist(PA_sub.df[x]))
      #Bug hunt
      #print(paste0("Getting ", mean.tmp))
      Physicochem.df[i,x] = mean(unlist(PA_sub.df[x]))
    }
    count = count + 1
  }
}

#Add lifestyle information
tmp = data.frame(model.matrix(~ Physicochem.df$Sample_type-1, data=Physicochem.df))
colnames(tmp) = gsub("Physicochem.df.Sample_type", "", colnames(tmp))
Physicochem.df = cbind(Physicochem.df, tmp)

#Add lifestyle information
tmp = data.frame(model.matrix(~ Physicochem.df$Sample_date-1, data=Physicochem.df))
colnames(tmp) = gsub("Physicochem.df.Sample_date", "", colnames(tmp))
Physicochem.df = cbind(Physicochem.df, tmp)

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DOC_uM.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

#Extract relevant columns
PP_totest.df = Physicochem.df  %>% dplyr::select(all_of(PP_totest.ls))

#Make sure rownames have been preserved
rownames(PP_totest.df)
dim(PP_totest.df)

#Apply row numbers from sample IDs
rownames(PP_totest.df) = PP_totest.df$Associatednumber
PP_totest.df$Associatednumber = NULL

#Flip so columns are samples for dissimilarity assessment
PP_totest.df = t(PP_totest.df)

#Get sample names for microbiome comparison
PP_totest.ls = rownames(PP_totest.df)

PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)


```
##Metagenomes
```{r Prep metagenome data}

#Import gene list
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  dplyr::select(gene_cluster, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long_MG <- amoAClean_geneabund_KO %>%
  pivot_longer(!DESCRIPTION, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information fpr amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()
  
amoAClean_CO2CH4_tbl_long_MG$counts = amoAClean_CO2CH4_tbl_long_MG$counts / 1000

#View(amoAClean_CO2CH4_tbl_long_MG)
dim(amoAClean_CO2CH4_tbl_long_MG)

#Reorder factors
amoAClean_CO2CH4_tbl_long_MG$Station = factor(amoAClean_CO2CH4_tbl_long_MG$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long_MG$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long_MG$Sample_date)

amoAClean_CO2CH4_tbl_long_MG$Sample_date = factor(amoAClean_CO2CH4_tbl_long_MG$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_MG$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_MG$data_type)

dim(amoAClean_CO2CH4_tbl_long_MG)

#Remove outliers and make dataframe wide from a long format
amoAClean_CO2CH4_tbl_wide_MG = amoAClean_CO2CH4_tbl_long_MG %>%
  dplyr::select(Associatednumber, counts, KO) %>%
  pivot_wider(names_from = KO, values_from = counts, values_fn = mean) %>%
  as.data.frame() %>%
  filter(Associatednumber!="164") %>%
  column_to_rownames("Associatednumber")


#We need to have treatment (samples) as rows, and gene probes (genes) as columns in a wide format.
WGCNA_MG_raw.df = t(amoAClean_CO2CH4_tbl_wide_MG)


```
### Actual WGCNA for MG
```{r}

set.seed(2)


data = WGCNA_MG_raw.df %>%
  as.data.frame() %>%
  rownames_to_column(var = "GeneId")



data[1:5,1:10]        # Look at first 5 rows and 10 columns
dim(data)

names(data)[1] = "GeneId"
names(data)           # Look at the column names


col_sel = names(data)[-1]     # Get all but first column name
mdata <- data %>%
  tidyr::pivot_longer(
    .,                        # The dot is the the input data, magrittr tutorial
    col = all_of(col_sel),
    values_transform = as.numeric
    ) %>%
  left_join(metadata_WGCNA, by = c("name" = "Associatednumber")) %>%
  dplyr::select(GeneId, name, value, Sample_type) %>%
  dplyr::rename(group = Sample_type)

mdata$name = as.character(mdata$name)


# ==== Plot groups (Sample Groups vs RNA Seq Counts) to identify outliers

 p <- mdata %>%
    ggplot(., aes(x = name, y = value)) +             # x = treatment, y = RNA Seq count
    geom_violin() +                                   # violin plot, show distribution
    geom_point(alpha = 0.2) +                         # scatter plot
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)          # Rotate treatment text
    ) +
    labs(x = "Treatment Groups / Samples", y = "Gene Hit Counts") +
    facet_grid(cols = vars(group), drop = TRUE, scales = "free_x")      # Facet by hour
p

pdf("E:/Functional_R_analysis/Network/WGCNA_OutlierHunting_MG.pdf", width = 48, height = 10)
p
dev.off()
#No outliers were detected

#Remove outliers
#mdata = mdata %>%
 # filter(value < 4000000)
#Rerun above code to make sure outliers have been removed

#Normalise data with DESeq2
library(DESeq2)
de_input = as.data.frame(data[,-1])
row.names(de_input) = data$GeneId
de_input[1:5,1:10]


meta_df <- data.frame(Sample = names(data[-1])) %>%
  left_join(metadata_WGCNA, by = c("Sample" = "Associatednumber")) %>%
  dplyr::select(Sample, Sample_type) %>%
  rename(Sample_type = "Type")

dds <- DESeq2::DESeqDataSetFromMatrix(round(de_input),
                              meta_df,
                              design = ~Type)
#> converting counts to integer mode
#> Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#> design formula are characters, converting to factors

dds <- DESeq(dds)
#> estimating size factors
#> estimating dispersions
#> gene-wise dispersion estimates
#> mean-dispersion relationship
#> final dispersion estimates
#> fitting model and testing
vsd <- varianceStabilizingTransformation(dds)
#>
#> Attaching package: 'genefilter'
#> The following objects are masked from 'package:matrixStats':
#>
#>     rowSds, rowVars
#> The following object is masked from 'package:readr':
#>
#>     spec
wpn_vsd <- getVarianceStabilizedData(dds)
rv_wpn <- rowVars(wpn_vsd)
summary(rv_wpn)
#>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
#>  0.00000  0.00000  0.00000  0.08044  0.03322 11.14529

q75_wpn <- quantile( rowVars(wpn_vsd), .75)  # <= original
q95_wpn <- quantile( rowVars(wpn_vsd), .95)  # <= changed to 95 quantile to reduce dataset
expr_normalized <- wpn_vsd[ rv_wpn > q95_wpn, ]

expr_normalized[1:5,1:10]
#>                       B-3      B-4      B-5      L-3      L-4      L-5      S-3
#> AC149818.2_FG001 7.600901 7.077399 7.803434 7.220840 7.410408 8.028223 7.160846
#> AC149829.2_FG003 8.782014 8.179876 7.900062 8.299778 7.529891 8.631731 8.055118
#> AC182617.3_FG001 8.047244 7.120668 6.885533 7.501391 7.279413 7.809565 7.184253
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816 6.633722 7.798843
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427 7.904850 7.484542
#>                       S-4      S-5   B_L1.1
#> AC149818.2_FG001 7.401382 7.345322 6.524435
#> AC149829.2_FG003 8.744502 8.142909 8.240407
#> AC182617.3_FG001 8.140134 6.972400 7.777347
#> AC186512.3_FG001 6.949501 6.952659 6.059033
#> AC186512.3_FG007 8.375664 7.762799 6.335663
dim(expr_normalized)
# This would only give us 14 genes - so we use all genes for downstream analysis
expr_normalized_df <- data.frame(expr_normalized) %>%
  mutate(
    Gene_id = row.names(expr_normalized)
  ) %>%
  pivot_longer(-Gene_id)

wpn_vsd.df <- data.frame(wpn_vsd) %>%
  mutate(
    Gene_id = row.names(wpn_vsd)
  ) %>%
  pivot_longer(-Gene_id)

expr_normalized_df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized and 95 quantile Expression",
    x = "treatment",
    y = "normalized expression"
  )

wpn_vsd.df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized Expression",
    x = "treatment",
    y = "normalized expression"
  )

# === Carry out WGCNA

# Use "expr_normalized" for a smaller dataset, but as we have relative few genes, we'll use the full carbon processing dataset 

input_mat = t(wpn_vsd)

input_mat[1:5,1:10]    
#>     AC149818.2_FG001 AC149829.2_FG003 AC182617.3_FG001 AC186512.3_FG001
#> B-3         7.600901         8.782014         8.047244         6.901539
#> B-4         7.077399         8.179876         7.120668         7.389644
#> B-5         7.803434         7.900062         6.885533         6.975945
#> L-3         7.220840         8.299778         7.501391         6.859593
#> L-4         7.410408         7.529891         7.279413         7.370816
#>     AC186512.3_FG007 AC189795.3_FG001 AC190609.3_FG002 AC190623.3_FG001
#> B-3         7.919688         8.149041         12.64301         6.575155
#> B-4         7.754506         8.077571         11.99816         7.170788
#> B-5         7.670946         7.524430         12.12500         7.438024
#> L-3         7.417760         8.420552         12.36979         8.223261
#> L-4         7.988427         7.105196         11.64515         8.008850
#>     AC192451.3_FG001 AC195340.3_FG001
#> B-3         6.700385         9.104258
#> B-4         7.325447         9.135480
#> B-5         7.819142         9.023856
#> L-3         8.052019         8.908933
#> L-4         8.528875         8.583982

#Treatment/samples should be rows, and genes columns

#library(WGCNA)
allowWGCNAThreads()          # allow multi-threading (optional)
#> Allowing multi-threading with up to 4 threads.

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  input_mat,             # <= Input data
  #blockSize = 30,
  powerVector = powers,
  verbose = 5
  )
#> pickSoftThreshold: will use block size 5486.
#>  pickSoftThreshold: calculating connectivity for given powers...
#>    ..working on genes 1 through 5486 of 5486
#>    Power SFT.R.sq  slope truncated.R.sq mean.k. median.k. max.k.
#> 1      1   0.5350  2.500          0.960  1940.0    1950.0   2840
#> 2      2   0.0642  0.331          0.897   964.0     927.0   1860
#> 3      3   0.1680 -0.444          0.859   560.0     505.0   1340
#> 4      4   0.5050 -0.822          0.906   358.0     300.0   1030
#> 5      5   0.6800 -1.070          0.935   243.0     189.0    819
#> 6      6   0.7770 -1.230          0.954   173.0     125.0    673
#> 7      7   0.8330 -1.310          0.972   127.0      85.3    564
#> 8      8   0.8660 -1.390          0.980    96.4      60.2    484
#> 9      9   0.8810 -1.450          0.981    74.8      43.2    422
#> 10    10   0.8940 -1.490          0.984    59.1      31.7    371
#> 11    12   0.9070 -1.540          0.988    38.7      17.6    295
#> 12    14   0.9150 -1.580          0.988    26.7      10.3    240
#> 13    16   0.9220 -1.570          0.985    19.1       6.3    200
#> 14    18   0.9200 -1.570          0.979    14.1       4.0    169
#> 15    20   0.9240 -1.570          0.982    10.7       2.6    145

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")




picked_power = 9
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(input_mat,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "signed",
                          randomSeed = 2,
                          corType = "pearson",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,
                          maxBlockSize = 4000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = T,
                          saveTOMFileBase = "./Network/WGCNA_MG",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
#Calculating module eigengenes block-wise from all genes
#   Flagging genes and samples with too many missing values...
#    ..step 1
#  ..Excluding 11 genes from the calculation due to too many missing samples or zero variance.
#    ..step 2
# ..Working on block 1 .
#    TOM calculation: adjacency..
#    ..will not use multithreading.
#     Fraction of slow calculations: 0.000000
#    ..connectivity..
#    ..matrix multiplication (system BLAS)..
#    ..normalization..
#    ..done.
#   ..saving TOM for block 1 into file ./Network/WGCNA_MG-block.1.RData
# ....clustering..
# ....detecting modules..
# ....calculating module eigengenes..
# ....checking kME in modules..
#     ...removing 4 genes from module 1 because their KME is too low.
#     ..removing 4 genes from module 2 because their KME is too low.
#     ..removing 2 genes from module 3 because their KME is too low.
#     ..removing 3 genes from module 4 because their KME is too low
# ..merging modules that are too close..
#     mergeCloseModules: Merging modules whose distance is less than 0.25
#       Calculating new MEs...

#cor <- stats::cor     # Return cor function to original namespace

#Take a look at the modules
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )


pdf("E:/Functional_R_analysis/Network/WGCNA_tree_MG.pdf", width = 16, height = 8)
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()

#Extract module assignments 
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]
#>            gene_id    colors
#> 1 K23094   grey
#> 2  K03392   blue
#> 3  K05359   grey
#> 4  K00476   grey
#> 5  K00471   grey

write_delim(module_df,
            file = "Network/WGCNA_gene_modules_MG.txt",
            delim = "\t")

#How many modules are there
length(unique(module_df$colors))

# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

WGCNA_sample_MG = mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
WGCNA_sample_MG

pdf("E:/Functional_R_analysis/Network/WGCNA_sample_MG.pdf", width = 20, height = 8)
WGCNA_sample_MG
dev.off()






# pick out a few modules of interest here
modules_of_interest = c("green", "turquoise", "tan")

# Pull out list of genes in that module
submod = module_df 

row.names(module_df) = module_df$gene_id

# Get normalized expression for those genes
wpn_vsd[1:5,1:10]

#Subset gene list - expression profiles
subexpr = wpn_vsd[submod$gene_id,]

#Make into a dataframe
submod_df = data.frame(subexpr) %>%
  mutate(
    gene_id = row.names(.)
  ) %>%
  pivot_longer(-gene_id) %>%
  mutate(
    module = module_df[gene_id,]$colors
  )

submod_df %>% ggplot(., aes(x=name, y=value, group=gene_id)) +
  geom_line(aes(color = module),
            alpha = 0.2) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90)
  ) +
  scale_colour_manual(values = c("black", "blue", "brown", "green", "greenyellow", "grey", "magenta", "pink", "purple", "red", "salmon", "forestgreen", "turquoise", "yellow"))+
  facet_grid(rows = vars(module)) +
  labs(x = "sample",
       y = "normalized expression")



genes_of_interest = module_df %>%
  subset(colors %in% modules_of_interest)

expr_of_interest = wpn_vsd[genes_of_interest$gene_id,]
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

# Only recalculate TOM for modules of interest (faster, altho there's some online discussion if this will be slightly off)
TOM = TOMsimilarityFromExpr(t(expr_of_interest),
                            power = picked_power)
#> TOM calculation: adjacency..
#> ..will use 4 parallel threads.
#>  Fraction of slow calculations: 0.000000
#> ..connectivity..
#> ..matrix multiplication (system BLAS)..
#> ..normalization..
#> ..done.

# Add gene names to row and columns
row.names(TOM) = row.names(expr_of_interest)
colnames(TOM) = row.names(expr_of_interest)


edge_list = data.frame(TOM) %>%
  mutate(
    gene1 = row.names(.)
  ) %>%
  pivot_longer(-gene1) %>%
  dplyr::rename(gene2 = name, correlation = value) %>%
  unique() %>%
  subset(!(gene1==gene2)) %>%
  mutate(
    module1 = module_df[gene1,]$colors,
    module2 = module_df[gene2,]$colors
  )

head(edge_list)
#> # A tibble: 6 x 5
#>   gene1            gene2            correlation module1   module2  
#>   <chr>            <chr>                  <dbl> <chr>     <chr>    
#> 1 AC186512.3_FG001 AC186512.3_FG007      0.0238 turquoise turquoise
#> 2 AC186512.3_FG001 AC190623.3_FG001      0.0719 turquoise turquoise
#> 3 AC186512.3_FG001 AC196475.3_FG004      0.143  turquoise turquoise
#> 4 AC186512.3_FG001 AC196475.3_FG005      0.0117 turquoise turquoise
#> 5 AC186512.3_FG001 AC196489.3_FG002      0.0181 turquoise turquoise
#> 6 AC186512.3_FG001 AC198481.3_FG004      0.0240 turquoise turquoise


adj = TOM[, colnames(TOM) != "samplesums"]
adj = adj[rownames(TOM) != "samplesums", ]
adj[adj > 0.1] = 1
adj[adj != 1] = 0
network <- igraph::graph_from_adjacency_matrix(adj)
network <- igraph::simplify(network)  # removes self-loops
#results <- netwk
V(network)$color <- netwk$colors #Assign colours to genes for their respective modules

#Plot for sanity checking
par(mar=c(0,0,0,0))
# remove unconnected nodes
network <- delete_vertices(network, degree(network)==0)
multtest::plot(network, layout=layout.fruchterman.reingold(network), edge.arrow.size = 0.2)

#Add extra information to network plot
#E(network$label) <- ifelse(E(network)$weight > 0, '+', '-')
#E(network)$weight_abs <- abs(E(network)$weight)

#Make module tab for Gephi object
V(network)$module =  V(network)$color

#Add extra information to network plot
V(network)$Function <- tax[V(network)$name, "Name"]
V(network)$Direction <- tax[V(network)$name, "Direction"]
V(network)$Compound <- tax[V(network)$name, "Compound"]
V(network)$Class <- tax[V(network)$name, "Class"]
V(network)$label = V(network)$name



# Export Network file to be read into Gephi, Cytoscape, VisANT, etc
write_graph(network, "./Network/WGCNA_NC_MG.graphml", format = "graphml")

#Export edge file for back up
write_delim(edge_list,
            file = "Network/edgelist_MG.tsv",
            delim = "\t")


```
###Correlate to environmental data

The Pearson correlation test answers something like the question

When X goes up, does Y also go up? 
When X goes down, does Y also go down?

while the Mantel test answers something like the question

When any two X observations are similar, are the corresponding Y observations also similar? 
When any two X observations are dissimilar, are the corresponding Y observations also dissimilar?
 
```{r}

MEs0

#Run loop for motus vs individual physicochemical parameters
Results_WGCNA_MG.df = data.frame("Data_type" = "Metagenomes",
                                 "Module_name" = "DELETEME",
                                 "PhysicochemicalParameter" = "DELETEME",
                                 "Pearson_corr_value" = 9999,
                                 "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric) 

i=1
x=1
for (i in 1:(which(colnames(MEs0) == "treatment")-1)) {
  
  print(paste0("Working on module ", i, " out of ", (which(colnames(MEs0) == "treatment")-1)))
  
  for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    module.name = colnames(MEs0)[i]
    
    #Remove all samples that have NAs for that PP
    PP.tmp <- PP_loop.df[x,] %>%
      as.data.frame() %>%
      dplyr::select_if(~ !any(is.na(.))) %>%
      t()
      #t(as.data.frame(PP_loop.df[x,][,is.na(PP_loop.df[x,])]))
    
    
    #Normalise PP metrics and extract module eigenvalues
    PP.tmp <- PP.tmp %>%
      as.data.frame() %>%
      mutate_at(c(PP.name), ~(scale(.) %>% as.vector))
    module.tmp = MEs0 %>%
      as.data.frame() %>%
      dplyr::select(all_of(module.name))
    
    #Make sure to only include samples/treatments that are present in both PP and microbiome dissimialrity matrices
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(rownames(PP.tmp))))
    module_samples = data.frame(module_sample = sort(as.numeric(rownames(module.tmp))))


    #Compare and put into dataframe
    PP_samples$module_match = match(PP_samples$PP_sample, module_samples$module_sample)
    module_samples$PP_match = match(module_samples$module_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_module_matches = subset(PP_samples, module_match!="NA")


    #Subset distance matrices by matching samples
    module_sub.tmp = module.tmp %>% # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = PP.tmp %>%  # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    #For bug hunting
    #dim(module.tmp)
    #dim(module_sub.tmp)
    #dim(PP.tmp)
    #dim(PP_sub.tmp)
    
    #Run correlation test
    test.tmp = cor.test(PP_sub.tmp[,1], module_sub.tmp[,1], method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Module_name" = module.name,
                             "PhysicochemicalParameter" = PP.name,
                             "Pearson_corr_value" = test.tmp$estimate,
                             "pvalue" = test.tmp$p.value
                             )
    
    #Combine results with previous dataframe
    Results_WGCNA_MG.df = rbind(Results_WGCNA_MG.df, Results.tmp)
    
   # print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  
    } 
  }


#Check results and clean up dataframe
Results_WGCNA_MG.df = Results_WGCNA_MG.df[-1,]
Results_WGCNA_MG.df

#Check if each PP was included
unique(Results_WGCNA_MG.df$PhysicochemicalParameter)



```

##Metatranscriptomes
```{r Prep MT data}

####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")%>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  dplyr::select(gene_cluster, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long_MT <- amoAClean_geneabund_KO %>%
  pivot_longer(!DESCRIPTION, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information fpr amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  dplyr::select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Associatednumber > 115) %>% # remove samples that have no metagenome samples
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long_MT$counts = amoAClean_CO2CH4_tbl_long_MT$counts / 1000


#View(amoAClean_CO2CH4_tbl_long_MT)
dim(amoAClean_CO2CH4_tbl_long_MT)

#write.csv(amoAClean_CO2CH4_tbl_long_MT, "E:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CN_TG.csv")

#amoAClean_CO2CH4_tbl_long_MT = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CN_TG.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long_MT$Station = factor(amoAClean_CO2CH4_tbl_long_MT$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long_MT$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long_MT$Sample_date)

amoAClean_CO2CH4_tbl_long_MT$Sample_date = factor(amoAClean_CO2CH4_tbl_long_MT$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_MT$data_type)
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_MT$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long_MT[ , ! names(amoAClean_CO2CH4_tbl_long_MT) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_MT)
dim(CO2CH4_TG.df)


#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG.df = CO2CH4_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "IncompleteMetagenome")) #Replace Infin with #/0, as Metagenome likely incomplete



amoAClean_CO2CH4_tbl_wide_MT = CO2CH4_TG.df  %>%
  dplyr::select(Associatednumber, TranscriptsPerGenome, KO) %>%
  filter(TranscriptsPerGenome!="IncompleteMetagenome") %>%
  mutate(TranscriptsPerGenome = as.numeric(TranscriptsPerGenome)) %>%
  pivot_wider(names_from = KO, values_from = TranscriptsPerGenome, values_fn = mean) %>%
  as.data.frame() %>%
  filter(Associatednumber!="155" & Associatednumber!="198" & Associatednumber!="120" & Associatednumber!="139") %>%
  column_to_rownames("Associatednumber")

#Create a new column to calculate what samples have no transcripts per gene counts
amoAClean_CO2CH4_tbl_wide_MT$samplesums = amoAClean_CO2CH4_tbl_wide_MT %>%
  rowSums()
#Exclude samples with no metatranscriptome samples
amoAClean_CO2CH4_tbl_wide_MT = subset(amoAClean_CO2CH4_tbl_wide_MT, samplesums > 1)

#We need to have treatment (samples) as rows, and gene probes (genes) as columns in a wide format.
WGCNA_MT_raw.df = t(amoAClean_CO2CH4_tbl_wide_MT)


```
### Actual WGCNA for MT
```{r}

set.seed(2)

data = WGCNA_MT_raw.df %>%
  as.data.frame() %>%
  rownames_to_column(var = "GeneId")



# Uncomment and modify the following to install any missing packages
# install.packages(c("tidyverse", "magrittr", "WGCNA))
library(tidyverse)     # tidyverse will pull in ggplot2, readr, other useful libraries
library(magrittr)      # provides the %>% operator
library(WGCNA)
library(genefilter)

# ==== Load and clean data
#data <- readr::read_delim("GSE61333_ligule_count.txt",     # <= path to the data file
 #                         delim = "\t")
#>
#> ââ Column specification ââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
#> cols(
#>   .default = col_double(),
#>   Count = col_character()
#> )
#> â¹ Use `spec()` for the full column specifications.

data[1:5,1:10]        # Look at first 5 rows and 10 columns
dim(data)

names(data)[1] = "GeneId"
names(data)           # Look at the column names


col_sel = names(data)[-1]     # Get all but first column name
mdata <- data %>%
  tidyr::pivot_longer(
    .,                        # The dot is the the input data, magrittr tutorial
    col = all_of(col_sel),
    values_transform = as.numeric
    ) %>%
  left_join(metadata_WGCNA, by = c("name" = "Associatednumber")) %>%
  dplyr::select(GeneId, name, value, Sample_type) %>%
  dplyr::rename(group = Sample_type)

mdata$name = as.character(mdata$name)


# ==== Plot groups (Sample Groups vs RNA Seq Counts) to identify outliers

 p <- mdata %>%
    ggplot(., aes(x = name, y = value)) +             # x = treatment, y = RNA Seq count
    geom_violin() +                                   # violin plot, show distribution
    geom_point(alpha = 0.2) +                         # scatter plot
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)          # Rotate treatment text
    ) +
    labs(x = "Treatment Groups / Samples", y = "Gene Hit Counts") +
    facet_grid(cols = vars(group), drop = TRUE, scales = "free_x")      # Facet by hour
p

pdf("E:/Functional_R_analysis/Network/WGCNA_OutlierHunting_MT.pdf", width = 48, height = 10)
p
dev.off()
#No outliers were detected

#Remove outliers
#mdata = mdata %>%
 # filter(value < 4000000)
#Rerun above code to make sure outliers have been removed

#Normalise data with DESeq2
library(DESeq2)
de_input = as.data.frame(data[,-1])
row.names(de_input) = data$GeneId
de_input[1:5,1:10]


meta_df <- data.frame(Sample = names(data[-1])) %>%
  left_join(metadata_WGCNA, by = c("Sample" = "Associatednumber")) %>%
  dplyr::select(Sample, Sample_type) %>%
  rename(Sample_type = "Type")

dds <- DESeq2::DESeqDataSetFromMatrix(round(de_input),
                              meta_df,
                              design = ~Type)
#> converting counts to integer mode
#> Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#> design formula are characters, converting to factors

dds <- DESeq(dds)
#> estimating size factors
#> estimating dispersions
#> gene-wise dispersion estimates
#> mean-dispersion relationship
#> final dispersion estimates
#> fitting model and testing
vsd <- varianceStabilizingTransformation(dds)
#>
#> Attaching package: 'genefilter'
#> The following objects are masked from 'package:matrixStats':
#>
#>     rowSds, rowVars
#> The following object is masked from 'package:readr':
#>
#>     spec
wpn_vsd <- getVarianceStabilizedData(dds)
rv_wpn <- rowVars(wpn_vsd)
summary(rv_wpn)
#>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
#>  0.00000  0.00000  0.00000  0.08044  0.03322 11.14529

q75_wpn <- quantile( rowVars(wpn_vsd), .75)  # <= original
q95_wpn <- quantile( rowVars(wpn_vsd), .95)  # <= changed to 95 quantile to reduce dataset
expr_normalized <- wpn_vsd[ rv_wpn > q95_wpn, ]

expr_normalized[1:5,1:10]
#>                       B-3      B-4      B-5      L-3      L-4      L-5      S-3
#> AC149818.2_FG001 7.600901 7.077399 7.803434 7.220840 7.410408 8.028223 7.160846
#> AC149829.2_FG003 8.782014 8.179876 7.900062 8.299778 7.529891 8.631731 8.055118
#> AC182617.3_FG001 8.047244 7.120668 6.885533 7.501391 7.279413 7.809565 7.184253
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816 6.633722 7.798843
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427 7.904850 7.484542
#>                       S-4      S-5   B_L1.1
#> AC149818.2_FG001 7.401382 7.345322 6.524435
#> AC149829.2_FG003 8.744502 8.142909 8.240407
#> AC182617.3_FG001 8.140134 6.972400 7.777347
#> AC186512.3_FG001 6.949501 6.952659 6.059033
#> AC186512.3_FG007 8.375664 7.762799 6.335663
dim(expr_normalized)
# This would only give us 14 genes - so we use all genes for downstream analysis
expr_normalized_df <- data.frame(expr_normalized) %>%
  mutate(
    Gene_id = row.names(expr_normalized)
  ) %>%
  pivot_longer(-Gene_id)

wpn_vsd.df <- data.frame(wpn_vsd) %>%
  mutate(
    Gene_id = row.names(wpn_vsd)
  ) %>%
  pivot_longer(-Gene_id)

expr_normalized_df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized and 95 quantile Expression",
    x = "treatment",
    y = "normalized expression"
  )

wpn_vsd.df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized Expression",
    x = "treatment",
    y = "normalized expression"
  )

# === Carry out WGCNA

# Use "expr_normalized" for a smaller dataset, but as we have relative few genes, we'll use the full carbon processing dataset 

input_mat = t(wpn_vsd)

input_mat[1:5,1:10]    
#>     AC149818.2_FG001 AC149829.2_FG003 AC182617.3_FG001 AC186512.3_FG001
#> B-3         7.600901         8.782014         8.047244         6.901539
#> B-4         7.077399         8.179876         7.120668         7.389644
#> B-5         7.803434         7.900062         6.885533         6.975945
#> L-3         7.220840         8.299778         7.501391         6.859593
#> L-4         7.410408         7.529891         7.279413         7.370816
#>     AC186512.3_FG007 AC189795.3_FG001 AC190609.3_FG002 AC190623.3_FG001
#> B-3         7.919688         8.149041         12.64301         6.575155
#> B-4         7.754506         8.077571         11.99816         7.170788
#> B-5         7.670946         7.524430         12.12500         7.438024
#> L-3         7.417760         8.420552         12.36979         8.223261
#> L-4         7.988427         7.105196         11.64515         8.008850
#>     AC192451.3_FG001 AC195340.3_FG001
#> B-3         6.700385         9.104258
#> B-4         7.325447         9.135480
#> B-5         7.819142         9.023856
#> L-3         8.052019         8.908933
#> L-4         8.528875         8.583982

#Treatment/samples should be rows, and genes columns

#library(WGCNA)
allowWGCNAThreads()          # allow multi-threading (optional)
#> Allowing multi-threading with up to 4 threads.

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  input_mat,             # <= Input data
  #blockSize = 30,
  powerVector = powers,
  verbose = 5
  )
#> pickSoftThreshold: will use block size 5486.
#>  pickSoftThreshold: calculating connectivity for given powers...
#>    ..working on genes 1 through 5486 of 5486
#>    Power SFT.R.sq  slope truncated.R.sq mean.k. median.k. max.k.
#> 1      1   0.5350  2.500          0.960  1940.0    1950.0   2840
#> 2      2   0.0642  0.331          0.897   964.0     927.0   1860
#> 3      3   0.1680 -0.444          0.859   560.0     505.0   1340
#> 4      4   0.5050 -0.822          0.906   358.0     300.0   1030
#> 5      5   0.6800 -1.070          0.935   243.0     189.0    819
#> 6      6   0.7770 -1.230          0.954   173.0     125.0    673
#> 7      7   0.8330 -1.310          0.972   127.0      85.3    564
#> 8      8   0.8660 -1.390          0.980    96.4      60.2    484
#> 9      9   0.8810 -1.450          0.981    74.8      43.2    422
#> 10    10   0.8940 -1.490          0.984    59.1      31.7    371
#> 11    12   0.9070 -1.540          0.988    38.7      17.6    295
#> 12    14   0.9150 -1.580          0.988    26.7      10.3    240
#> 13    16   0.9220 -1.570          0.985    19.1       6.3    200
#> 14    18   0.9200 -1.570          0.979    14.1       4.0    169
#> 15    20   0.9240 -1.570          0.982    10.7       2.6    145

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")




picked_power = 6
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(input_mat,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "signed",
                          randomSeed = 2,
                          corType = "pearson",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,
                          maxBlockSize = 4000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = T,
                          saveTOMFileBase = "./Network/WGCNA_MT",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
#Calculating module eigengenes block-wise from all genes
#   Flagging genes and samples with too many missing values...
#    ..step 1
#  ..Excluding 11 genes from the calculation due to too many missing samples or zero variance.
#    ..step 2
# ..Working on block 1 .
#    TOM calculation: adjacency..
#    ..will not use multithreading.
#     Fraction of slow calculations: 0.000000
#    ..connectivity..
#    ..matrix multiplication (system BLAS)..
#    ..normalization..
#    ..done.
#   ..saving TOM for block 1 into file ./Network/WGCNA_MT-block.1.RData
# ....clustering..
# ....detecting modules..
# ....calculating module eigengenes..
# ....checking kME in modules..
#     ...removing 38 genes from module 1 because their KME is too low.
#     ..removing 35 genes from module 2 because their KME is too low.
#     ..removing 7 genes from module 3 because their KME is too low.
#     ..removing 4 genes from module 4 because their KME is too low.
#     ..removing 3 genes from module 5 because their KME is too low.
#     ..removing 1 genes from module 6 because their KME is too low.
# ..merging modules that are too close..
#     mergeCloseModules: Merging modules whose distance is less than 0.25
#       Calculating new MEs...

#cor <- stats::cor     # Return cor function to original namespace

#Take a look at the modules
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )


pdf("E:/Functional_R_analysis/Network/WGCNA_tree_MT.pdf", width = 16, height = 8)
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()

#Extract module assignments 
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]
#>            gene_id    colors
#> 1 K23094   grey
#> 2  K03392   blue
#> 3  K05359   grey
#> 4  K00476   grey
#> 5  K00471   grey

write_delim(module_df,
            file = "Network/WGCNA_gene_modules_MT.txt",
            delim = "\t")

#How many modules are there
length(unique(module_df$colors))

# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

WGCNA_sample_MT = mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
WGCNA_sample_MT

pdf("E:/Functional_R_analysis/Network/WGCNA_sample_MT.pdf", width = 20, height = 8)
WGCNA_sample_MT
dev.off()






# pick out a few modules of interest here
modules_of_interest = c("green", "turquoise", "tan")

# Pull out list of genes in that module
submod = module_df 

row.names(module_df) = module_df$gene_id

# Get normalized expression for those genes
wpn_vsd[1:5,1:10]

#Subset gene list - expression profiles
subexpr = wpn_vsd[submod$gene_id,]

#Make into a dataframe
submod_df = data.frame(subexpr) %>%
  mutate(
    gene_id = row.names(.)
  ) %>%
  pivot_longer(-gene_id) %>%
  mutate(
    module = module_df[gene_id,]$colors
  )

submod_df %>% ggplot(., aes(x=name, y=value, group=gene_id)) +
  geom_line(aes(color = module),
            alpha = 0.2) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90)
  ) +
  scale_colour_manual(values = c("black", "blue", "brown", "green", "greenyellow", "grey", "magenta", "pink", "purple", "red", "salmon", "forestgreen", "turquoise", "yellow"))+
  facet_grid(rows = vars(module)) +
  labs(x = "sample",
       y = "normalized expression")




genes_of_interest = module_df %>%
  subset(colors %in% modules_of_interest)

expr_of_interest = wpn_vsd[genes_of_interest$gene_id,]
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

# Only recalculate TOM for modules of interest (faster, altho there's some online discussion if this will be slightly off)
TOM = TOMsimilarityFromExpr(t(expr_of_interest),
                            power = picked_power)
#> TOM calculation: adjacency..
#> ..will use 4 parallel threads.
#>  Fraction of slow calculations: 0.000000
#> ..connectivity..
#> ..matrix multiplication (system BLAS)..
#> ..normalization..
#> ..done.

# Add gene names to row and columns
row.names(TOM) = row.names(expr_of_interest)
colnames(TOM) = row.names(expr_of_interest)


edge_list = data.frame(TOM) %>%
  mutate(
    gene1 = row.names(.)
  ) %>%
  pivot_longer(-gene1) %>%
  dplyr::rename(gene2 = name, correlation = value) %>%
  unique() %>%
  subset(!(gene1==gene2)) %>%
  mutate(
    module1 = module_df[gene1,]$colors,
    module2 = module_df[gene2,]$colors
  )


head(edge_list)
#> # A tibble: 6 x 5
#>   gene1            gene2            correlation module1   module2  
#>   <chr>            <chr>                  <dbl> <chr>     <chr>    
#> 1 AC186512.3_FG001 AC186512.3_FG007      0.0238 turquoise turquoise
#> 2 AC186512.3_FG001 AC190623.3_FG001      0.0719 turquoise turquoise
#> 3 AC186512.3_FG001 AC196475.3_FG004      0.143  turquoise turquoise
#> 4 AC186512.3_FG001 AC196475.3_FG005      0.0117 turquoise turquoise
#> 5 AC186512.3_FG001 AC196489.3_FG002      0.0181 turquoise turquoise
#> 6 AC186512.3_FG001 AC198481.3_FG004      0.0240 turquoise turquoise


adj <- TOM
adj[adj > 0.1] = 1
adj[adj != 1] = 0
network <- igraph::graph_from_adjacency_matrix(adj)
network <- igraph::simplify(network)  # removes self-loops
#results <- netwk
V(network)$color <- netwk$colors #Assign colours to genes for their respective modules

#Plot for sanity checking
par(mar=c(0,0,0,0))
# remove unconnected nodes
network <- delete_vertices(network, degree(network)==0)
multtest::plot(network, layout=layout.fruchterman.reingold(network), edge.arrow.size = 0.2)

#Add extra information to network plot
#E(network$label) <- ifelse(E(network)$weight > 0, '+', '-')
#E(network)$weight_abs <- abs(E(network)$weight)

#Make module tab for Gephi object
V(network)$module =  V(network)$color

#Add extra information to network plot
V(network)$Function <- tax[V(network)$name, "Name"]
V(network)$Direction <- tax[V(network)$name, "Direction"]
V(network)$Compound <- tax[V(network)$name, "Compound"]
V(network)$Class <- tax[V(network)$name, "Class"]
V(network)$label = V(network)$name



# Export Network file to be read into Gephi, Cytoscape, VisANT, etc
write_graph(network, "./Network/WGCNA_NC_MT.graphml", format = "graphml")

#Export edge file for back up
write_delim(edge_list,
            file = "Network/edgelist_MT.tsv",
            delim = "\t")


```
###Correlate to environmental data

The Pearson correlation test answers something like the question

When X goes up, does Y also go up? 
When X goes down, does Y also go down?

while the Mantel test answers something like the question

When any two X observations are similar, are the corresponding Y observations also similar? 
When any two X observations are dissimilar, are the corresponding Y observations also dissimilar?
 
```{r}

MEs0

#Run loop for motus vs individual physicochemical parameters
Results_WGCNA_MT.df = data.frame("Data_type" = "TranscriptsPerGene",
                                 "Module_name" = "DELETEME",
                                 "PhysicochemicalParameter" = "DELETEME",
                                 "Pearson_corr_value" = 9999,
                                 "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric) 

i=1
x=1
for (i in 1:(which(colnames(MEs0) == "treatment")-1)) {
  
  print(paste0("Working on module ", i, " out of ", (which(colnames(MEs0) == "treatment")-1)))
  
  for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    module.name = colnames(MEs0)[i]
    
    #Remove all samples that have NAs for that PP
    PP.tmp <- PP_loop.df[x,] %>%
      as.data.frame() %>%
      dplyr::select_if(~ !any(is.na(.))) %>%
      t()
      #t(as.data.frame(PP_loop.df[x,][,is.na(PP_loop.df[x,])]))
    
    
    #Normalise PP metrics and extract module eigenvalues
    PP.tmp <- PP.tmp %>%
      as.data.frame() %>%
      mutate_at(c(PP.name), ~(scale(.) %>% as.vector))
    module.tmp = MEs0 %>%
      as.data.frame() %>%
      dplyr::select(all_of(module.name))
    
    #Make sure to only include samples/treatments that are present in both PP and microbiome dissimialrity matrices
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(rownames(PP.tmp))))
    module_samples = data.frame(module_sample = sort(as.numeric(rownames(module.tmp))))


    #Compare and put into dataframe
    PP_samples$module_match = match(PP_samples$PP_sample, module_samples$module_sample)
    module_samples$PP_match = match(module_samples$module_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_module_matches = subset(PP_samples, module_match!="NA")


    #Subset distance matrices by matching samples
    module_sub.tmp = module.tmp %>% # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = PP.tmp %>%  # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    #For bug hunting
    #dim(module.tmp)
    #dim(module_sub.tmp)
    #dim(PP.tmp)
    #dim(PP_sub.tmp)
    
    #Run correlation test
    test.tmp = cor.test(PP_sub.tmp[,1], module_sub.tmp[,1], method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Module_name" = module.name,
                             "PhysicochemicalParameter" = PP.name,
                             "Pearson_corr_value" = test.tmp$estimate,
                             "pvalue" = test.tmp$p.value
                             )
    
    #Combine results with previous dataframe
    Results_WGCNA_MT.df = rbind(Results_WGCNA_MT.df, Results.tmp)
    
   # print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  
    } 
  }


#Check results and clean up dataframe
Results_WGCNA_MT.df = Results_WGCNA_MT.df[-1,]
Results_WGCNA_MT.df

#Check if each PP was included
unique(Results_WGCNA_MT.df$PhysicochemicalParameter)



```
## Plots
```{r}


WGCNA_PP.df = rbind(Results_WGCNA_MG.df, Results_WGCNA_MT.df)

WGCNA_PP.df$PhysicochemicalParameter = factor(WGCNA_PP.df$PhysicochemicalParameter,
                                              levels = c("Sat_O2_Perc",
                                                         "Temperature_TBDHereon",
                                                         "station_km",
                                                         "Salinity_PSU",
                                                         "Turbidity_NTU",
                                                         "pH",
                                                         "O2_uM",
                                                         "DOC_mg.L",
                                                         "DIC_mg.L",
                                                         "TN_mg.L",
                                                         "Ammonium_mg.L",
                                                         "Nitrite_mg.L",
                                                         "Nitrate_mg.L",
                                                         "TotalDissolvedPhosphate_mg.L",
                                                         "SRP_mgperL",
                                                         "Silicate_mg.L",
                                                         "dCO2_uM",
                                                         "dCH4_nM",
                                                         "SPM_mgperL",
                                                         "POC_mgperL",
                                                         "PTC_mgperL",
                                                         "PTN_mgperL",
                                                         "TEP_um2perL",
                                                         "CSP_um2perL",
                                                         "Free_living",
                                                         "Light_fraction",
                                                         "Heavy_fraction",
                                                         "May.21",
                                                         "Jul.21", 
                                                         "Feb.22", 
                                                         "May.22",
                                                         "Jun.22",
                                                         "Nov.22"
                                                         )
                                              )

WGCNA.plt = ggplot(WGCNA_PP.df, aes(x = PhysicochemicalParameter, y = Module_name, fill = Pearson_corr_value))+
  geom_tile()+
  geom_text(aes(label = ifelse(pvalue > 0.05, "", 
                               ifelse(pvalue > 0.01, "*", 
                                      ifelse(pvalue > 0.001, "**", 
                                             ifelse(pvalue < 0.001, "***", ""))))),
            size = 20 / .pt)+
  scale_fill_gradient2("Pearson Correlation", low = "navy", mid = "white", high = "red", midpoint = 0)+ 
  #scale_x_discrete(
  #  expand = expansion(mult = c(0,0)), guide = guide_axis(angle = 90),
  #  position = "top",
  #  limits = rev
  #)+
  #scale_y_discrete(
  #  expand = expansion(mult = c(0,0)),
  #  position = "right"
  #)+
  xlab("Physicochemical parameters") + 
  ylab("WGCNA calculated module")+
  facet_grid(. ~ Data_type)+
  My_Theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
WGCNA.plt


pdf("E:/Functional_R_analysis/Network/WGCNA_pearson.pdf", width = 18, height = 8)
WGCNA.plt
dev.off()


```


#Autotrophy estimate
##Carbon fixation pathways - key genes
```{r}
#Import metadata
metadata <- read.csv("E:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT


metadata2 <- read.csv("E:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
rownames(metadata)<-metadata$sampleid
```

```{r}
#Carbon fixing pathways (CFPs) - 7 major ones
#Calvin cycle
#the reverse tricarboxylic acid (rTCA) cycle, the 3-hydroxypropionate (3HP) bi-cycle, the 4-hydroxybutyrate/3-hydroxypropionate (4HB/3HP) cycle, the dicarboxylate/4-hydroxybutyrate (DC/4HB) cycle, the reductive acetyl-CoA pathway (WoodâLjungdahl pathwayâWLP), and the reductive glycine pathway
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/


#Calvin cycle - K01601 (cbbL) + cbbM  + K00855 (prkB)
#While both RubisCO and ribulose 5-phosphate kinase are required for the operation of the Calvin cycle, we amplified only portions of genes encoding form I (cbbL) and form II (cbbM) RubisCO as Calvin cycle markers (45). The form III, or archaeal, RubisCO was not included in this analysis, as a functional Calvin cycle has not been demonstrated in members of the domain Archaea that actively express this enzyme (17)
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC522104/#:~:text=Three%20key%20genes%20of%20the,synthase%20%5BnifJ%5D)%3B%20and%202%2D
#Phosphoribulokinase I (PRK1)Phosphoribulokinase II (PRK2)
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/

#rTCA - 	K15230 K15231 (aclAB) +  K00169 K00171 K00169 K00170 (porCDAB) + K00176 K00174 K00175 K00177 (oorDABC)
#rTCA cycle were amplified: ATP citrate lyase (aclAB); pyruvate:ferredoxin oxidoreductase (or ferredoxin-dependent pyruvate synthase), which has two independent genes (heterodimeric pyruvate:ferredoxin oxidoreductase [porCDAB] and homodimeric ferredoxin-dependent pyruvate synthase [nifJ]); and 2-oxoglutarate:ferredoxin oxidoreductase (or Î±-ketoglutarate:acceptor oxidoreductase) (oorDABC) (18, 45).
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC522104/#:~:text=Three%20key%20genes%20of%20the,synthase%20%5BnifJ%5D)%3B%20and%202%2D
#Citryl-CoA lyase (CCL)Citryl-CoA synthetase small (CCSs)Citryl-CoA synthetase large (CCSl
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/


#3-hydroxypropionate (3HP) bi-cycle - 	K14468 (mcr) 	+ K15019 (pcc)
#MalonylâCoA is reduced to 3âhydroxypropionate in a NADPHâdependent reaction, which is catalyzed by the bifunctional enzyme malonylâCoA reductase. This key enzyme comprises malonate semialdehyde and 3âhydroxypropionate dehydrogenase activity (HÃ¼gler et al., 2002).
#Hydroxypropionate is further converted to propionylâCoA by a trifunctional enzyme, propionylâCoA synthase, the second key enzyme of the cycle.
  #https://www.sciencedirect.com/science/article/abs/pii/S0076687905970122?via%3Dihub
  #https://www.sciencedirect.com/science/article/pii/S0021925818520366

#4-hydroxybutyrate/3-hydroxypropionate (4HB/3HP) cycle - K18120 K00043 K08318
#4-Hydroxybutyrate dehydrogenase(HBD)
#https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/

#dicarboxylate/4-hydroxybutyrate (DC/4HB) cycle - 
#4-Hydroxybutyrate dehydrogenase(HBD)
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/

#The following 2 use the exact same enzymes for the reverse (oxidation) reaction, so we cannot actually tell what direction is occuring in the sample, hence we must exclude it from the analysis
#reductive acetyl-CoA pathway (WoodâLjungdahl pathwayâWLP) - K00193 (cdhC) + K00194 (cdhD) + K00197 (cdhE) + K00195 (cdhB) + K00196 (cooF) + K00198 (cooS) + K00192 (cdhA)
#CODH/ACS complex - K00193 (cdhC) + K00194 (cdhD) + K00197 (cdhE) + K00195 (cdhB) + K00196 (cooF) + K00198 (cooS) + K00192 (cdhA)
  #https://www.pnas.org/doi/full/10.1073/pnas.1716667115

#reductive glycine pathway - 
#Can run in either direction with identicsl enzymes so no further analysis was pursued


#pufm - K08929
#anoxygenic phototrophy

#### Metagenomes ####

CarbonfixationKeygenes.df = read.csv("E:/Functional_R_analysis/CarbonFixationPathway_KeyGenes.csv", sep = ";") %>%
  dplyr::filter(KO %nin% c("K08929")) %>%
  dplyr::filter(Notes %nin% c("Overestimating due to aclA requirements"))
dim(CarbonfixationKeygenes.df)


CFix_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  filter(KO %in% CarbonfixationKeygenes.df$KO) %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  
  #filter(KO %in% CarbonfixationKeygenes.df$KO) %>% # only extract the CO2CH4 gene
  dplyr::select(gene_cluster, DESCRIPTION, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(-c(KO), sum, na.rm = TRUE)) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(CFix_geneabund_KO)
unique(CFix_geneabund_KO$DESCRIPTION) # Should be 8


CFix_geneabund_KO_long <- CFix_geneabund_KO %>%
  pivot_longer(-c(, DESCRIPTION), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonfixationKeygenes.df, by = c("KO" = "KO")) %>% # Add the carbon fixtion pathway information
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()
  

#Correct abundance
CFix_geneabund_KO_long$counts = CFix_geneabund_KO_long$counts / 1000

#Clean up for plot
CFix_geneabund_KO_long$station_km = as.numeric(as.character(CFix_geneabund_KO_long$station_km))


CFix_geneabund_KO_long$Sample_date = factor(CFix_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

CFix_geneabund_KO_long.sum = Rmisc::summarySE(CFix_geneabund_KO_long, measurevar = "counts", groupvars = c("station_km", "Sample_date", "pathway"))

#Keep for records
write.csv(CFix_geneabund_KO_long.sum, "E:/Functional_R_analysis/CarbonFixationPathways_MG.csv")

#CFix_geneabund_KO_long.sum = read.csv("F:/Functional_R_analysis/CarbonFixationPathways_MG.csv")


CFix_geneabund_KO_long_MG.sum = CFix_geneabund_KO_long.sum



####Metatranscriptomes ####

CFix_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonfixationKeygenes.df$KO) %>% # only extract the CO2CH4 gene
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(CFix_geneabund_KO)



CFix_geneabund_KO_long <- CFix_geneabund_KO %>%
  filter(KO %in% CarbonfixationKeygenes.df$KO) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonfixationKeygenes.df, by = c("KO"="KO")) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ungroup() %>% 
  distinct()

#Correct abundance
CFix_geneabund_KO_long$counts = CFix_geneabund_KO_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(CFix_geneabund_KO_long)


#Reorder factors
CFix_geneabund_KO_long$Station = factor(CFix_geneabund_KO_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

CFix_geneabund_KO_long$Sample_date = gsub("-", " ",CFix_geneabund_KO_long$Sample_date)

CFix_geneabund_KO_long$Sample_date = factor(CFix_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
CFix_geneabund_KO_long$data_type = gsub("METAT", "Transcriptomes", CFix_geneabund_KO_long$data_type)
CFix_geneabund_KO_long$data_type = gsub("METAG", "Metagenomes", CFix_geneabund_KO_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CFix_TG.df <- spread(CFix_geneabund_KO_long[ , ! names(CFix_geneabund_KO_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(CFix_geneabund_KO_long)
dim(CFix_TG.df)

#Calculate Transcripts per gene copy
CFix_TG.df$TranscriptsPerGenome = CFix_TG.df$Transcriptomes / CFix_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CFix_TG.df = CFix_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Remove samples for which we have no metatranscriptomes
CFix_TG.df = subset(CFix_TG.df, Associatednumber > 116)

#Remove samples for which sequencing failed
CFix_TG.df = subset(CFix_TG.df, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))

#Make sure data is set up properly
CFix_TG.df$TranscriptsPerGenome = as.numeric(as.character(CFix_TG.df$TranscriptsPerGenome))
CFix_TG.df$Transcriptomes = NULL
CFix_TG.df$Metagenomes = NULL
CFix_TG.df$Associatednumber = as.character(CFix_TG.df$Associatednumber)

CFix_TG.df$Sample_date = factor(CFix_TG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

CFix_TG.sum = Rmisc::summarySE(CFix_TG.df, measurevar = "TranscriptsPerGenome", groupvars = c("station_km", "Sample_date", "pathway"))

#Keep for records
write.csv(CFix_TG.sum, "E:/Functional_R_analysis/CarbonFixationPathways_MT.csv")

#CFix_TG.sum = read.csv("E:/Functional_R_analysis/CarbonFixationPathways_MT.csv")

CFix_geneabund_KO_long_MT.sum = CFix_TG.sum






#### Plotting ####

#Read in dataframes
CFix_geneabund_KO_long_MG.sum = read.csv("E:/Functional_R_analysis/CarbonFixationPathways_MG.csv")
CFix_geneabund_KO_long_MT.sum = read.csv("E:/Functional_R_analysis/CarbonFixationPathways_MT.csv")
CFix_geneabund_KO_long_MT.sum$X = NULL
CFix_geneabund_KO_long_MG.sum$X = NULL

CFix_geneabund_KO_long_MT.sum$counts = CFix_geneabund_KO_long_MT.sum$TranscriptsPerGenome
CFix_geneabund_KO_long_MT.sum$TranscriptsPerGenome = NULL
colnames(CFix_geneabund_KO_long_MG.sum)
colnames(CFix_geneabund_KO_long_MT.sum)

CFix_geneabund_KO_long_MG.sum$data_type = "Metagenomes"
CFix_geneabund_KO_long_MT.sum$data_type = "TranscriptsperGenome"

CFix_geneabund_KO_long_MT.sum = CFix_geneabund_KO_long_MT.sum %>% relocate(counts, .after = N)


#Combine
CFix_geneabund_KO_long.sum = rbind(CFix_geneabund_KO_long_MG.sum, CFix_geneabund_KO_long_MT.sum)
CFix_geneabund_KO_long.sum


CFix_geneabund_KO_long.sum$Sample_date = factor(CFix_geneabund_KO_long.sum$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))


#Plot
CFix.plt = ggplot(CFix_geneabund_KO_long.sum, aes(y = counts, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_smooth()+
  facet_grid(data_type ~ pathway)+
  scale_y_log10("Gene abundance (per genome)")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
CFix.plt

pdf("E:/Functional_R_analysis/Figures/CarbonFixationPaths.pdf", width = 12, height = 8)
CFix.plt
dev.off()

```
#Methanotrophy

##Prep metadata
```{r}
#Import metadata
metadata <- read.csv("E:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT


metadata2 <- read.csv("E:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
rownames(metadata)<-metadata$sampleid
```

```{r}

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
#sort(unique(amoAMatches.ls$KO))


#### Metagenomes ####


MethTroph_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  filter(KO %in% "K10944") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
  mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  dplyr::select(gene_cluster, DESCRIPTION, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(-c(KO), sum, na.rm = TRUE)) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(MethTroph_geneabund_KO)
unique(MethTroph_geneabund_KO$DESCRIPTION) # Should be 8


MethTroph_geneabund_KO_long <- MethTroph_geneabund_KO %>%
  pivot_longer(-c(, DESCRIPTION), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information for amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct() %>%
  dplyr::filter(SName!="amoA")
MethTroph_geneabund_KO_long

#Correct abundance
MethTroph_geneabund_KO_long$counts = MethTroph_geneabund_KO_long$counts / 1000

#Clean up for plot
MethTroph_geneabund_KO_long$station_km = as.numeric(as.character(MethTroph_geneabund_KO_long$station_km))


MethTroph_geneabund_KO_long$Sample_date = factor(MethTroph_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

MethTroph_geneabund_KO_long.sum = Rmisc::summarySE(MethTroph_geneabund_KO_long, measurevar = "counts", groupvars = c("station_km", "Sample_date", "Sample_type"))

#Keep for records
write.csv(MethTroph_geneabund_KO_long.sum, "E:/Functional_R_analysis/pmoA_MG.csv")

#MethTroph_geneabund_KO_long.sum = read.csv("F:/Functional_R_analysis/pmoA_MG.csv")


MethTroph_geneabund_KO_long_MG.sum = MethTroph_geneabund_KO_long.sum



####Metatranscriptomes ####

MethTroph_geneabund_KO = annot %>%
  filter(KO %in% "K10944") %>% # only extract the CO2CH4 gene
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
  mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  
  dplyr::select(gene_cluster, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(MethTroph_geneabund_KO)



MethTroph_geneabund_KO_long <- MethTroph_geneabund_KO %>%
  pivot_longer(!DESCRIPTION, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information fpr amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ungroup() %>% 
  distinct()

#Correct abundance
MethTroph_geneabund_KO_long$counts = MethTroph_geneabund_KO_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(MethTroph_geneabund_KO_long)


#Reorder factors
MethTroph_geneabund_KO_long$Station = factor(MethTroph_geneabund_KO_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

MethTroph_geneabund_KO_long$Sample_date = gsub("-", " ",MethTroph_geneabund_KO_long$Sample_date)

MethTroph_geneabund_KO_long$Sample_date = factor(MethTroph_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
MethTroph_geneabund_KO_long$data_type = gsub("METAT", "Transcriptomes", MethTroph_geneabund_KO_long$data_type)
MethTroph_geneabund_KO_long$data_type = gsub("METAG", "Metagenomes", MethTroph_geneabund_KO_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
MethTroph_TG.df <- spread(MethTroph_geneabund_KO_long[ , ! names(MethTroph_geneabund_KO_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(MethTroph_geneabund_KO_long)
dim(MethTroph_TG.df)

#Calculate Transcripts per gene copy
MethTroph_TG.df$TranscriptsPerGenome = MethTroph_TG.df$Transcriptomes / MethTroph_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
MethTroph_TG.df = MethTroph_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Remove samples for which we have no metatranscriptomes
MethTroph_TG.df = subset(MethTroph_TG.df, Associatednumber > 116)

#Remove samples for which sequencing failed
MethTroph_TG.df = subset(MethTroph_TG.df, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))

#Make sure data is set up properly
MethTroph_TG.df$TranscriptsPerGenome = as.numeric(as.character(MethTroph_TG.df$TranscriptsPerGenome))
MethTroph_TG.df$Transcriptomes = NULL
MethTroph_TG.df$Metagenomes = NULL
MethTroph_TG.df$Associatednumber = as.character(MethTroph_TG.df$Associatednumber)

MethTroph_TG.df$Sample_date = factor(MethTroph_TG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

MethTroph_TG.sum = Rmisc::summarySE(MethTroph_TG.df, measurevar = "TranscriptsPerGenome", groupvars = c("station_km", "Sample_date", "Sample_type"))

#Keep for records
write.csv(MethTroph_TG.sum, "E:/Functional_R_analysis/pmoA_MT.csv")

#MethTroph_TG.sum = read.csv("E:/Functional_R_analysis/pmoA_MT.csv")

MethTroph_geneabund_KO_long_MT.sum = MethTroph_TG.sum






#### Plotting ####

#Read in dataframes
MethTroph_geneabund_KO_long_MG.sum = read.csv("E:/Functional_R_analysis/pmoA_MG.csv")
MethTroph_geneabund_KO_long_MT.sum = read.csv("E:/Functional_R_analysis/pmoA_MT.csv")
MethTroph_geneabund_KO_long_MT.sum$X = NULL
MethTroph_geneabund_KO_long_MG.sum$X = NULL

MethTroph_geneabund_KO_long_MT.sum$counts = MethTroph_geneabund_KO_long_MT.sum$TranscriptsPerGenome
MethTroph_geneabund_KO_long_MT.sum$TranscriptsPerGenome = NULL
colnames(MethTroph_geneabund_KO_long_MG.sum)
colnames(MethTroph_geneabund_KO_long_MT.sum)

MethTroph_geneabund_KO_long_MG.sum$data_type = "Metagenomes"
MethTroph_geneabund_KO_long_MT.sum$data_type = "TranscriptsperGenome"

MethTroph_geneabund_KO_long_MT.sum = MethTroph_geneabund_KO_long_MT.sum %>% relocate(counts, .after = N)


#Combine
MethTroph_geneabund_KO_long.sum = rbind(MethTroph_geneabund_KO_long_MG.sum, MethTroph_geneabund_KO_long_MT.sum)
MethTroph_geneabund_KO_long.sum


MethTroph_geneabund_KO_long.sum$Sample_date = factor(MethTroph_geneabund_KO_long.sum$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))


#Plot
MethTroph.plt = ggplot(MethTroph_geneabund_KO_long.sum, aes(y = counts, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_smooth()+
  facet_grid(data_type ~ Sample_type)+
  scale_y_log10("Gene abundance (per genome)")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MethTroph.plt

pdf("E:/Functional_R_analysis/Figures/pmoA.pdf", width = 12, height = 8)
MethTroph.plt
dev.off()




```

#pH plot
```{r}

PP_data.df = read.csv("E:/Functional_R_analysis/PhysicochemicalParameters_mod2.txt", sep = "\t")

PP_data.df$Sample_date = gsub("-", " ", PP_data.df$Sample_date)

pH.plt = ggplot(PP_data.df, aes(x = Stromkilometer, y = pH, colour = Sample_date, group = Sample_date)) +
  geom_line()+
  geom_point()+
  xlab("Elbe km")+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme

pH.plt
#Mean of two points was used

pdf("E:/Functional_R_analysis/Final_Figures_Tables/pH.pdf", width = 6, height = 6)
pH.plt
dev.off()
```

#Poster Results Section

```{r}

#Top25_Fraction_MT.plt = read.csv("Figures/CO2CH4_MT_IndivGenes.RDS")
#NMDS_Gene.plt = read.csv("Figures/DFG_Gene_METAG_NMDS.RDS")


PeaksSlopes_wide.df = readRDS("Figures/PeaksSlopes_wide.df")
rescurated.pca = readRDS("Figures/rescurated.pca")

#Biplot of individuals and variables
Figure6_DOM_PCA.plt = factoextra::fviz_pca_biplot(rescurated.pca,
                            label = "var",
                            col.var = "#000000", # Variables color
                            select.var = list(contrib = 5),
                            geom = "point"#,
                            #colour = "white"
                            )+
  geom_point(aes(shape = factor(PeaksSlopes_wide.df$Date), 
                 colour = as.numeric(PeaksSlopes_wide.df$Elbe_km)), 
             size = 10)+
    scale_shape_manual("Sampling Dates", 
                     values = c(15,16,17,18,25))+
  scale_color_gradient2("Elbe km", 
                        low="green", 
                        mid="blue",
                        high="red", 
                        midpoint=680,
                        guide = "colourbar")+
  guides(colour = guide_colorbar(order = 1, reverse = T),
         Groups = "none",
         shape = guide_legend(order = 2))+
  My_Theme+
  theme(legend.position = "bottom")

Figure6_DOM_PCA.plt


DFG_Results.plt = ggpubr::ggarrange(Figure6_DOM_PCA.plt,NMDS_Gene.plt, Top25_Fraction_MT.plt,
                                    labels = "AUTO",
                                    align = "h")
DFG_Results.plt

pdf("F:/Functional_R_analysis/Figures/DFG_Results.pdf", width = 12, height = 10)
DFG_Results.plt
dev.off()
```


#Attic

```{r}


####Calculate variability####

#Extract ellipse coordinates from plot
pb = ggplot_build(NMDS_Gene.plt)
el = pb$data[[2]][c("colour", 
                    #"shape",
                    "x",
                    "y")]


i=1
ellipseAreaList = data.frame()
group_list = unique(el$colour)
#Separate into groups
for (i in 1:length(group_list)) {

  #Subset to separate into individual ellipse groups - if you used shape in addition to colour you'll want to change this as well
  Object = subset(el, 
                  colour == group_list[i])
  
  #Remove grouping column
  Object = Object[-1]
  
  # Center of ellipse
  ctr = MASS::cov.trob(Object)$center  
  
  # Calculate distance to center from each point on the ellipse
  dist2center <- sqrt(rowSums((t(t(Object)-ctr))^2))

  # Calculate area of ellipse from semi-major and semi-minor axes. 
  # These are, respectively, the largest and smallest values of dist2center. 
  value = pi*min(dist2center)*max(dist2center)
  
  #Store in the area list
  ellipseAreaList = rbind(ellipseAreaList, data.frame(group_list[i], value))
}

#Assign days from the colour scheme
ellipseAreaList$Date[grep("red", ellipseAreaList$group_list.i.)] = "Mai 21"
ellipseAreaList$Date[grep("forestgreen", ellipseAreaList$group_list.i.)] = "Jul 21"
ellipseAreaList$Date[grep("black", ellipseAreaList$group_list.i.)] = "Feb 22"
ellipseAreaList$Date[grep("green", ellipseAreaList$group_list.i.)] = "Mai 22"
ellipseAreaList$Date[grep("magenta", ellipseAreaList$group_list.i.)] = "Jun 22"
ellipseAreaList$Date[grep("navy", ellipseAreaList$group_list.i.)] = "Nov 22"

#Arrange for easier reading
ellipseAreaList = arrange(ellipseAreaList, desc(value))
ellipseAreaList

#Is the trend significant?
#cor.test(ellipseAreaList$value, ellipseAreaList$Date, method = "spearman")
kruskal.test(ellipseAreaList$value, ellipseAreaList$Date, p.adjust.method = "bonferroni") # this trend is not significant
```
##Individual MAG analysis
###Carbon gene count
```{r}


Temp_MG_MT_mOTU_taxa.ls = c("Bacteria__Actinobacteriota__Actinomycetia__Nanopelagicales__Nanopelagicaceae__Nanopelagicus__Nanopelagicus sp003569185",
                            "Bacteria__Actinobacteriota__Actinomycetia__Nanopelagicales__Nanopelagicaceae__Planktophila__",
                            "Bacteria__Actinobacteriota__Actinomycetia__Nanopelagicales__Nanopelagicaceae__Planktophila__Planktophila vernalis",
                            "Bacteria__Proteobacteria__Alphaproteobacteria__Pelagibacterales__Pelagibacteraceae__Fonsibacter__Fonsibacter sp018882565",
                            "Bacteria__Proteobacteria__Gammaproteobacteria__Burkholderiales__Burkholderiaceae__Limnohabitans__A__",
                            "Bacteria__Proteobacteria__Gammaproteobacteria__Burkholderiales__Burkholderiaceae__Rhodoferax__")




####Metagenomes####

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Temp = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  unite(fulltaxa, c("domain", "phylum", "class", "order", "family", "genus", "species")) # make new column that contains taxa information

  #Remove phylogenetic level info
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("d__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("p__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("c__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("o__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("f__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("g__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("s__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("_", "__", amoAClean_geneabund_KO_Temp$fulltaxa)

amoAClean_geneabund_KO_Temp = amoAClean_geneabund_KO_Temp %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2/CH4 gene
  filter(fulltaxa %in% Temp_MG_MT_mOTU_taxa.ls) %>% # subset to only those 6 taxa we're interested in
anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome, fulltaxa) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(fulltaxa, genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Temp)
#View(amoAClean_geneabund_KO_Temp)

amoAClean_CO2CH4_tbl_long_Temp <- amoAClean_geneabund_KO_Temp %>%
  pivot_longer(cols = -c(KO, genome, fulltaxa), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, fulltaxa, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long_Temp$counts = amoAClean_CO2CH4_tbl_long_Temp$counts / 1000

#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Temp$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Temp$genome)

Temp_taxa_MG.df = amoAClean_CO2CH4_tbl_long_Temp %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Clean up for plot
Temp_taxa_MG.df$station_km = as.numeric(as.character(Temp_taxa_MG.df$station_km))


Temp_taxa_MG.df$Sample_date = factor(Temp_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Temp_taxa_MG.sum = Rmisc::summarySE(Temp_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#Keep for records
write.csv(Temp_taxa_MG.df, "F:/Functional_R_analysis/MGMTmOTUCorr_MG_Temp.csv")

#Temp_taxa_MG.df = read.csv("F:/Functional_R_analysis/MGMTmOTUCorr_MG_Temp.csv")

unique(Temp_taxa_MG.sum$fulltaxa)




####Metatranscriptomes ####

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Temp = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  unite(fulltaxa, c("domain", "phylum", "class", "order", "family", "genus", "species")) # make new column that contains taxa information

  #Remove phylogenetic level info
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("d__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("p__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("c__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("o__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("f__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("g__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("s__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("_", "__", amoAClean_geneabund_KO_Temp$fulltaxa)

amoAClean_geneabund_KO_Temp = amoAClean_geneabund_KO_Temp %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2/CH4 gene
  filter(fulltaxa %in% Temp_MG_MT_mOTU_taxa.ls) %>% # subset to only those 6 taxa we're interested in
anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome, fulltaxa) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(fulltaxa, genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Temp)
#View(amoAClean_geneabund_KO_Temp)

amoAClean_CO2CH4_tbl_long_Temp <- amoAClean_geneabund_KO_Temp %>%
  pivot_longer(cols = -c(KO, genome, fulltaxa), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, fulltaxa, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long_Temp$counts = amoAClean_CO2CH4_tbl_long_Temp$counts / 1000

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Temp$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Temp$data_type)
amoAClean_CO2CH4_tbl_long_Temp$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Temp$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Temp.df <- spread(amoAClean_CO2CH4_tbl_long_Temp[ , ! names(amoAClean_CO2CH4_tbl_long_Temp) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Temp)
dim(CO2CH4_TG_Temp.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Temp.df$TranscriptsPerGenome = CO2CH4_TG_Temp.df$Transcriptomes / CO2CH4_TG_Temp.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Temp.df = CO2CH4_TG_Temp.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuTemply the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Temp.lng = gather(CO2CH4_TG_Temp.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, fulltaxa)
dim(CO2CH4_TG_Temp.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Temp.lng$counts = as.numeric(as.character(CO2CH4_TG_Temp.lng$counts))
CO2CH4_TG_Temp.lng$Associatednumber = as.character(CO2CH4_TG_Temp.lng$Associatednumber)


#Check how many unique genera
unique(CO2CH4_TG_Temp.lng$fulltaxa)
unique(CO2CH4_TG_Temp.lng$genome)

Temp_taxa_MT.df = CO2CH4_TG_Temp.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Clean up for plot
Temp_taxa_MT.df$station_km = as.numeric(as.character(Temp_taxa_MT.df$station_km))


Temp_taxa_MT.df$Sample_date = factor(Temp_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Temp_taxa_MT.sum = Rmisc::summarySE(Temp_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#Keep for records
write.csv(Temp_taxa_MT.df, "F:/Functional_R_analysis/MGMTmOTUCorr_MT_Temp.csv")

#Temp_taxa_MT.df = read.csv("E:/Functional_R_analysis/MGMTmOTUCorr_MT_Temp.csv")

unique(Temp_taxa_MT.sum$fulltaxa)




#### Calculations - no need for MT as we calculate transcripts per gene ####

#Read in dataframes
Temp_taxa_MG.df = read.csv("F:/Functional_R_analysis/MGMTmOTUCorr_MG_Temp.csv")
#Temp_taxa_MT.df = read.csv("E:/Functional_R_analysis/MGMTmOTUCorr_MT_Temp.csv")
unique(Temp_taxa_MG.df$fulltaxa)

#Summary for ease
Temp_MG.sum = Rmisc::summarySE(Temp_taxa_MG.df, measurevar = "counts", groupvars = c("KO", "fulltaxa"))
Temp_MG.sum = Rmisc::summarySE(Temp_MG.sum, measurevar = "counts", groupvars = c("fulltaxa"))
#Temp_MT.sum = Rmisc::summarySE(Temp_taxa_MT.df, measurevar = "counts", groupvars = c("KO", "fulltaxa"))
#Temp_MT.sum = Rmisc::summarySE(Temp_MT.sum, measurevar = "counts", groupvars = c("fulltaxa"))

#How many of our selected carbon KOs are associated with each taxa?
View(Temp_MG.sum)
#Temp_MT.sum

#How many KOs shared between all taxa?
Temp_MG.sum = Rmisc::summarySE(Temp_taxa_MG.df, measurevar = "counts", groupvars = c("KO", "fulltaxa"))

KO_count.df = Temp_MG.sum %>%
  group_by(KO) %>%
  dplyr::summarise(count=n_distinct(fulltaxa))%>%
  data.table::setorder(., order = -count) %>%
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% # split description into long and short name
  select(KO, count, SName) %>% # only keep relevant columns
  distinct()

KO_count.df 


#Where do unique genes come from?
test = subset(Temp_MG.sum, KO %in% subset(KO_count.df, count == 1)$KO) %>%
  Rmisc::summarySE(measurevar = "counts", groupvars = "fulltaxa") %>%
  data.table::setorder(., order = -N)
test  


```


###Attic
```{r}

Temp_MG_MT_mOTU_taxa.ls = c("Bacteria__Actinobacteriota__Actinomycetia__Nanopelagicales__Nanopelagicaceae__Nanopelagicus__Nanopelagicus sp003569185",
                            "Bacteria__Actinobacteriota__Actinomycetia__Nanopelagicales__Nanopelagicaceae__Planktophila__",
                            "Bacteria__Actinobacteriota__Actinomycetia__Nanopelagicales__Nanopelagicaceae__Planktophila__Planktophila vernalis",
                            "Bacteria__Proteobacteria__Alphaproteobacteria__Pelagibacterales__Pelagibacteraceae__Fonsibacter__Fonsibacter sp018882565",
                            "Bacteria__Proteobacteria__Gammaproteobacteria__Burkholderiales__Burkholderiaceae__Limnohabitans_A",
                            "Bacteria__Proteobacteria__Gammaproteobacteria__Burkholderiales__Burkholderiaceae__Rhodoferax__")




####Metagenomes####

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Temp = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  unite(fulltaxa, c("domain", "phylum", "class", "order", "family", "genus", "species")) # make new column that contains taxa information

  #Remove phylogenetic level info
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("d__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("p__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("c__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("o__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("f__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("g__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("s__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("_", "__", amoAClean_geneabund_KO_Temp$fulltaxa)

amoAClean_geneabund_KO_Temp = amoAClean_geneabund_KO_Temp %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2/CH4 gene
  filter(fulltaxa %in% Temp_MG_MT_mOTU_taxa.ls) %>% # subset to only those 6 taxa we're interested in
anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome, fulltaxa) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(fulltaxa, genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Temp)
#View(amoAClean_geneabund_KO_Temp)

amoAClean_CO2CH4_tbl_long_Temp <- amoAClean_geneabund_KO_Temp %>%
  pivot_longer(cols = -c(KO, genome, fulltaxa), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, fulltaxa, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long_Temp$counts = amoAClean_CO2CH4_tbl_long_Temp$counts / 1000


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Temp$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Temp$genome)

Temp_taxa_MG.df = amoAClean_CO2CH4_tbl_long_Temp %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Clean up for plot
Temp_taxa_MG.df$station_km = as.numeric(as.character(Temp_taxa_MG.df$station_km))


Temp_taxa_MG.df$Sample_date = factor(Temp_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Temp_taxa_MG.sum = Rmisc::summarySE(Temp_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#Keep for records
write.csv(Temp_taxa_MG.df, "F:/Functional_R_analysis/MGMTmOTUCorr_MG_Temp.csv")

#Temp_taxa_MG.df = read.csv("F:/Functional_R_analysis/MGMTmOTUCorr_MG_Temp.csv")

unique(Temp_taxa_MG.sum$fulltaxa)




####Metatranscriptomes ####

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Temp = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  unite(fulltaxa, c("domain", "phylum", "class", "order", "family", "genus", "species")) # make new column that contains taxa information

  #Remove phylogenetic level info
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("d__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("p__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("c__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("o__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("f__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("g__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("s__", "", amoAClean_geneabund_KO_Temp$fulltaxa)
amoAClean_geneabund_KO_Temp$fulltaxa = gsub("_", "__", amoAClean_geneabund_KO_Temp$fulltaxa)

amoAClean_geneabund_KO_Temp = amoAClean_geneabund_KO_Temp %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2/CH4 gene
  filter(fulltaxa %in% Temp_MG_MT_mOTU_taxa.ls) %>% # subset to only those 6 taxa we're interested in
anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome, fulltaxa) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(fulltaxa, genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Temp)
#View(amoAClean_geneabund_KO_Temp)

amoAClean_CO2CH4_tbl_long_Temp <- amoAClean_geneabund_KO_Temp %>%
  pivot_longer(cols = -c(KO, genome, fulltaxa), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, fulltaxa, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long_Temp$counts = amoAClean_CO2CH4_tbl_long_Temp$counts / 1000

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Temp$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Temp$data_type)
amoAClean_CO2CH4_tbl_long_Temp$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Temp$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Temp.df <- spread(amoAClean_CO2CH4_tbl_long_Temp[ , ! names(amoAClean_CO2CH4_tbl_long_Temp) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Temp)
dim(CO2CH4_TG_Temp.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Temp.df$TranscriptsPerGenome = CO2CH4_TG_Temp.df$Transcriptomes / CO2CH4_TG_Temp.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Temp.df = CO2CH4_TG_Temp.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuTemply the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Temp.lng = gather(CO2CH4_TG_Temp.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, fulltaxa)
dim(CO2CH4_TG_Temp.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Temp.lng$counts = as.numeric(as.character(CO2CH4_TG_Temp.lng$counts))
CO2CH4_TG_Temp.lng$Associatednumber = as.character(CO2CH4_TG_Temp.lng$Associatednumber)


#Check how many unique genera
unique(CO2CH4_TG_Temp.lng$fulltaxa)
unique(CO2CH4_TG_Temp.lng$genome)

Temp_taxa_MT.df = CO2CH4_TG_Temp.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Clean up for plot
Temp_taxa_MT.df$station_km = as.numeric(as.character(Temp_taxa_MT.df$station_km))


Temp_taxa_MT.df$Sample_date = factor(Temp_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Temp_taxa_MT.sum = Rmisc::summarySE(Temp_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#Keep for records
write.csv(Temp_taxa_MT.df, "F:/Functional_R_analysis/MGMTmOTUCorr_MT_Temp.csv")

#Temp_taxa_MT.df = read.csv("F:/Functional_R_analysis/MGMTmOTUCorr_MT_Temp.csv")

unique(Temp_taxa_MT.sum$fulltaxa)





#### Make plots ####

#Read in data
Temp_taxa_MG.df = read.csv("E:/Functional_R_analysis/MGMTmOTUCorr_MG_Temp.csv", row.names = 1)
Temp_taxa_MT.df = read.csv("E:/Functional_R_analysis/MGMTmOTUCorr_MT_Temp.csv", row.names = 1)
Temp_taxa_mOTU.df = read.csv("E:/Functional_R_analysis/MGMTmOTUCorr_mOTU_Temp.csv", row.names = 1)

#Add data origin
Temp_taxa_MG.df$data_type = "Metagenomes"
Temp_taxa_MT.df$data_type = "TranscriptsPerGene"
Temp_taxa_mOTU.df$data_type = "mOTUs"

#Make sure MG and MG dataframes are mergable and merge them
colnames(Temp_taxa_MG.df)
colnames(Temp_taxa_MT.df)
Temp_taxa_MTMG.df = rbind(Temp_taxa_MG.df, Temp_taxa_MT.df)

#Make summaries
Temp_taxa_MTMG.sum = Rmisc::summarySE(Temp_taxa_MTMG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "data_type"))
Temp_taxa_mOTU.sum = Rmisc::summarySE(Temp_taxa_mOTU.df, measurevar = "Abundance", groupvars = c("fulltaxa", "station_km", "date", "data_type"))

#Rename counts to abundance and remove counts column
Temp_taxa_MTMG.sum$Abundance = Temp_taxa_MTMG.sum$counts
Temp_taxa_MTMG.sum$counts = NULL
Temp_taxa_MTMG.sum$date = Temp_taxa_MTMG.sum$Sample_date
Temp_taxa_MTMG.sum$Sample_date = NULL


colnames(Temp_taxa_mOTU.sum)
colnames(Temp_taxa_MTMG.sum)

#Final merge of all three microbiome aspects
Temp_taxa.df = rbind(Temp_taxa_mOTU.sum, Temp_taxa_MTMG.sum)


####Make plot####

Temp_Taxa.plt = ggplot(Temp_taxa.df, aes(x = station_km, y = Abundance, colour = data_type, shape = fulltaxa))+
  geom_line()+
  geom_point()+
  facet_wrap(. ~ date)+
  ylim(0,1)



Temp_Taxa.plt 


```


##amoA
```{r}

# make taxonomy table
amoa_tbl <- annot %>% 
  rownames_to_column("gene_cluster") %>%  # remove rownames and rename to gene_cluster
  filter(KO == "K10944") %>% # only extract the amoA gene
  select(gene_cluster) %>% # only get the gene cluster id
  left_join(gene_cluster_taxa) %>%  # Combine gene_cluster information with the genome information
  left_join(taxa, by = c("genome" = "GENOME"), relationship= "many-to-many") %>% # add taxonomic information based on genome name
  select(gene_cluster, phylum, class, order, family, genus) %>% # extract only the gene_cluster and taxonomic information
  distinct() %>% # make sure each line is unique
  filter(phylum != "NA") # remove any rows that are not associated with a specific phyla

# make abundance table, subset by taxonomy 
amoA_otu_tbl <- annot %>% 
  rownames_to_column("gene_cluster") %>%  # remove rownames and rename to gene_cluster
  filter(KO == "K10944") %>% # only extract the amoA gene
  select(gene_cluster) %>%  # only get the gene cluster id
  left_join(gene_cluster_taxa) %>%  # Combine gene_cluster information with the genome information
  left_join(taxa, by = c("genome" = "GENOME"), relationship= "many-to-many") %>% # add taxonomic information based on genome name
  select(gene_cluster, phylum, class, order, family, genus) %>% # extract only the gene_cluster and taxonomic information
  distinct() %>% # make sure each line is unique
  filter(phylum != "NA") %>% # remove any rows that are not associated with a specific phyla
  filter(grepl("Nitro", genus)) %>% # Extract only genus that include "Nitro" in their name
  select(gene_cluster) %>% # extract gene_cluster information
  left_join(geneabund_2) # match these gene clusters with the abundance information

# make dataframe ready to plot by combining abundance with taxonomy information in a long format
amoA_otu_tbl_long <- amoA_otu_tbl %>%
  select(-length) %>% # remove length column
  pivot_longer(!gene_cluster, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(amoa_tbl, relationship = "many-to-many") %>%  # combine this with the taxonomic information we previously generated
  left_join(metadata)%>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') # remove sample from BunthausSpitze

#Reorder factors for better plotting
amoA_otu_tbl_long$Station = factor(amoA_otu_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoA_otu_tbl_long$Sample_date = factor(amoA_otu_tbl_long$Sample_date,
                                   levels = c("Mai 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "Mai 22",
                                              "Jun 22",
                                              "Nov 22"))


amoA_otu_tbl_long$counts = amoA_otu_tbl_long$counts/1000
# Plot
ggplot(amoA_otu_tbl_long) + 
  geom_tile(aes(x=Station, y=genus, fill=log(counts))) +
  facet_wrap(~ data_type *Sample_date )+
  scale_fill_gradient2(low= "green", mid = "white", high = "red", na.value = "green")+
  ggtitle("amoA")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

tiff("amoA_genecatalogue.tiff", res = 100, units = "in", width = 10, height = 15)
last_plot()
dev.off()

```
This is still normalised to a per genome count based on the whole sample
