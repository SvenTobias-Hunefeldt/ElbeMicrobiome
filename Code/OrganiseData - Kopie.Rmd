---
title: "Organise data"
author: "Sven Tobias-HÃ¼nefeldt"
date: "2023-11-28"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Load packages
```{r}
require(RCurl)
require(R.utils)
require(phyloseq)
require(plotly)
require(forcats)
require(vegan)
require(dplyr)
require(ggpubr)
library(stringr)
library(tidyr)
library(tibble)

require(WGCNA)

library(Hmisc)
library(igraph)
library(tidyverse)     # tidyverse will pull in ggplot2, readr, other useful libraries
library(magrittr)      # provides the %>% operator
library(genefilter)


```

#Make environment and functions
```{r Set up environment}
#Set seed to make results more reproducible
set.seed(2)
#Set language to english
Sys.setenv(LANG = "en")
#Set up working directory
setwd("F:/Functional_R_analysis/")
#Define theme for plotting
My_Theme = theme_bw()+
  theme(axis.title.x = element_text(size=18),
       # theme_grey(base_size = 22),
        axis.text.x = element_text(angle=0, colour = "black", vjust=1, hjust = 0.5, size=18), 
        axis.text.y = element_text(colour = "black", size=18),
        axis.title.y = element_text(size=18),
        plot.title = element_text(size = 18, hjust = 0.5),
        legend.title =element_text(size = 18),
        legend.text = element_text(size = 16),
        legend.position="right",
        legend.key.size = unit(1, "cm"),
        strip.text.x = element_text(size=18, face="bold"),
        strip.text.y = element_text(size=18, face="bold"),
        #panel.background = element_blank(),
        panel.border = element_rect(fill = NA, colour = "black"),
        strip.background = element_rect(colour="black"),
       text = element_text(family = "sans"))

Poster_Theme = theme_bw()+
  theme(axis.title.x = element_text(size=28),
       # theme_grey(base_size = 22),
        axis.text.x = element_text(angle=0, colour = "black", vjust=1, hjust = 0.5, size=24), 
        axis.text.y = element_text(colour = "black", size=24),
        axis.title.y = element_text(size=28),
        plot.title = element_text(size = 24, hjust = 0.5),
        legend.title =element_text(size = 28),
        legend.text = element_text(size = 24),
        legend.position="right",
        legend.key.size = unit(1, "cm"),
        strip.text.x = element_text(size=24, face="bold"),
        strip.text.y = element_text(size=24, face="bold"),
        #panel.background = element_blank(),
        panel.border = element_rect(fill = NA, colour = "black"),
        strip.background = element_rect(colour="black"),
       text = element_text(family = "sans"))

#Station specific colours for consistency
Station_colour_list <- c("Muelenberger Loch" =  "black",
                "Twielenfleth" = "red",
                #"" = "violet",
                #"" = "violetred4", 
                "Schwarztonnensand" = "navy",
                #"" = "",
                #"" = "thistle3", 
                "Brunbuettel" = "forestgreen",
                #"" = "darkred",
                "Medemgrund" = "green",
                #"" = "orange",
                #"" = "turquoise",
                #"" = "cornflowerblue",
                #"" = "beige",
                "Station6" = "magenta")

Date_colour_list <- c(
                "May 21" = "forestgreen",
                "Jul 21" =  "red",
                #"" = "violet",
                #"" = "violetred4", 
                #"" = "",
                #"" = "thistle3", 
                "Feb 22" = "black",
                #"" = "darkred",
                #"" = "turquoise",
                #"" = "cornflowerblue",
                #"" = "beige",
                #"" = "orange",
                "May 22" = "green",
                "Jun 22" = "darkorange",
                "Nov 22" = "cornflowerblue"
                )

#Colourblind friendly pallete
cbbPalette <- c("black",
                "red",
                "navy", 
                "green", 
                "magenta",
                "forestgreen")
#If more options are needed
expanded_cbbPalette <- c("#000000", #Black
                "#E69F00", #Orange
                "#56B4E9", #Blue (light)
                "#009E73", #Sea green
                "#CC79A7", #Magenta (light)
                "#F0E442", #Yellow
                "#0072B2", #Blue
                "#D55E00", #Burnt orange
                "dodgerblue4",
                "rosybrown",
                "floralwhite",
                "lightgoldenrod4",
                "cornsilk3",
                "coral4",
                "gray38",
                "turquoise4",
                "springgreen3",
                "slateblue3",
                "forestgreen",
                "lightgreen") 

#Shapes for ggplot2
Shape_list = c(0, #Hollow square
               15, #Filled square
               1, #Hollow circle
               16, #Filled circle
               2, #Hollow triangle
               17, #Filled triangle
               5, #Hollow diamond
               23) #Filled diamond
                
#Set up position dodge for ggplot2
pd = position_dodge(0.15)

ConditionColourList <- c("AlcianBlue" = "black",
                         "CBBG" = "red")

#Colourblind friendly pallete
FractionColourList <- c("Suspended" = "grey50",
                        "Sinking" = "black")
FractionSecondaryColourList <- c(#"Suspended" = "black",
                                 #"Sinking" = "red",
                                 #"navy",
                                 "Suspended" = "grey", 
                                 "Sinking" = "grey40")


Group_colours = c("Dissolved Organic" = "#000000", #Black
                  "Dissolved Inorganic" =  "#E69F00", #Orange
                  "Free-Living Organisms"= "#56B4E9", #Blue (light),
                  "Suspended PAO" = "#009E73", #Sea green,
                  "Sinking PAO" = "#CC79A7", #Magenta (light),
                  "Suspended Organic Particles" = "#F0E442", #Yellow,
                  "Suspended Inorganic Particles" = "#0072B2", #Blue,
                  "Sinking Organic Particles" = "#D55E00", #Burnt orange,
                  "Sinking Inorganic Particles" = "dodgerblue4")

```
```{r Hour:Minute to Hour function}
i="1"
#hours_minutes = Results.df$TimeDiff
hours_minutes_to_hours <- function(hours_minutes) {
  #print(length(hours_minutes))
  
  output =list()
  
  for (i in 1:length(hours_minutes)) {
    if(grepl(pattern =":",  x = hours_minutes[i]) == T) {
    
      splitNumbers = strsplit(hours_minutes[i], split = ":")
      minutes = as.numeric(splitNumbers[[1]][2])/60
      hours = as.numeric(splitNumbers[[1]][1])
    
      tmp_output = as.numeric(hours + minutes)
    
      output = c(output, tmp_output)
    
    }
    else if (grepl(pattern =".",  x = hours_minutes[i]) == T) {
      
      tmp_output = as.numeric(hours_minutes[i])
    
      output = c(output, tmp_output)
    
    }
  else {
    print("Sample did not match format, hours and minutes must be separated by :")
  }  
  }
  
  return(output)
}

```
```{r String cutting function}

substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))
}

```
```{r standard error function}
# Function to calculate standard error
se <- function(x) {
  sd(x, na.rm = TRUE) / sqrt(length(x[!is.na(x)]))
}
```
```{r exclusion function}
`%nin%` = Negate(`%in%`)
```


#Import dataframes and make analysis data frames - metagenomes and metatranscriptomes
```{r}
####Download, unzip, and load in metagenome/metatranscriptome data ####
path="F:/Functional_R_analysis"
#path <- getwd()

h <- curl::new_handle()
curl::handle_setopt(
  handle = h,
  httpauth = 1,
  userpwd = #please ask for access
)

#url_geneabund <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gene_catalog/GROS22__insertcounts.lengthnorm.profile.cellab.profile.gz" 
#curl::curl_download(url_geneabund,paste(path,"/BICEST_cellabund.tsv.gz", sep=""), handle =  h)
#gunzip(paste(path,"/BICEST_cellabund.tsv.gz", sep=""))
geneabund <- read.csv(paste0(path,"/BICEST_cellabund.tsv"), sep="\t", skip=1, header = TRUE, row.names = 1)

#url_annot <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gene_catalog/GROS22.kegg-annotations.tsv.gz" 
#curl::curl_download(url_annot,paste(path,"/GROS22.kegg-annotations.tsv.gz", sep=""), handle =  h)
#gunzip(paste(path,"/GROS22.kegg-annotations.tsv.gz", sep=""))
annot <- read.csv(paste0(path,"/GROS22.kegg-annotations.tsv"), sep="\t", skip=0, header = TRUE, row.names = 1, quote="")

#url_clstr <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gene_catalog/GROS22.clstr.gz" 
#curl::curl_download(url_clstr,paste(path,"/GROS22.clstr.gz", sep=""), handle =  h)
#gunzip(paste(path,"/GROS22.clstr.gz", sep=""))
clstr <- read.csv(paste0(path,"/GROS22.clstr"), sep="\t", skip=0, header = FALSE)
colnames(clstr) <- c("gene_cluster", "mem", "gene", "length", "pos")


#url_taxa <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-2.prok.genomes_2_gtdb.tsv.gz"
#curl::curl_download(url_taxa,paste(path,"/GROS22-2.gtdb.gz", sep=""), handle =  h)
#gunzip(paste(path,"/GROS22-2.gtdb.gz", sep=""))

#url_taxa2 <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-1.prok.genomes_2_gtdb.tsv.gz"
#curl::curl_download(url_taxa2,paste(path,"/GROS22-1.gtdb.gz", sep=""), handle =  h)
#gunzip(paste(path,"/GROS22-1.gtdb.gz", sep=""))

taxa <- read.csv(paste0(path,"/GROS22-2.gtdb"), sep="\t", skip=0, header = TRUE)
taxa <- rbind(taxa,read.csv(paste0(path,"/GROS22-2.gtdb"), sep="\t", header = TRUE))
taxa <- taxa %>% 
  separate(GTDBTK_TAXONOMY, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";")


##### Process abundance data ####
geneabund_2 <- geneabund %>% 
  rownames_to_column("gene_cluster") # remove rownames and rename to gene_cluster

geneabund_KO <- annot %>% 
  rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  dplyr::select(gene_cluster, KO) %>% # select only the columns titled gene_sluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values


geneabund_ko_otu_table <-
  geneabund_KO %>% 
  column_to_rownames("KO") %>% # remove rownames and rename to gene_cluster
  otu_table(., taxa_are_rows = TRUE) #make as a otu_table to generate a phyloseq object

sample_names(geneabund_ko_otu_table)
taxa_names(geneabund_ko_otu_table)

gene_abund_ko_annots <- annot %>%
 rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  dplyr::select(-"gene_cluster") %>% # remove the gene_cluster column
  distinct(., .keep_all = TRUE ) %>% # keep only unique KO id's
  rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  dplyr::select(KO, everything()) %>%  # reorders - so KO is in front
  column_to_rownames("KO") %>% # remove column named KO and make it the rowname
  as.matrix() %>% # convert to a matrix
  tax_table() # convert to a taxa table object for phyloseq object creation


taxa_names(gene_abund_ko_annots)


#####
metadata <- readxl::read_xlsx("F:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT

metadata2 <- readxl::read_xlsx("F:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
rownames(metadata)<-metadata$sampleid

metadata_v0 = metadata

genecat_ps <- phyloseq(geneabund_ko_otu_table, gene_abund_ko_annots, metadata)  # Combine into a single phyloseq object


gene_cluster_taxa <- clstr %>% 
  dplyr::select("gene_cluster", "gene") %>%  # retrieve the gene cluster and gene column
  dplyr::mutate(genome=stringr::str_replace(gene, "-scaf.*", "")) # remove the scaffold information to only keep the MAG ID the gene cluster is associated with.

```
##mOTUs
```{r Download data}
h <- curl::new_handle()
curl::handle_setopt(
  handle = h,
  httpauth = 1,
  userpwd = "BICEST:vJGDYLs7"
)

##Download Data##

# url_new_motus <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/motus/mag_2_new_motus" 
# url_ref_motus <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/motus/mag_2_existing_motus" 
# url_tax_bac <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gtdb/gtdbtk.bac120.summary.R214.tsv"
# url_tax_arc <-"https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/gtdb/gtdbtk.ar53.summary.R214.tsv"
# url_tax_motus <- "https://zenodo.org/records/10275750/files/mOTUs3.1.0.genome_metadata.tsv.gz?download=1"
# url_checkm <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-2.prok.genomes_2_quality.tsv.gz"
# url_checkm2 <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-1.prok.genomes_2_quality.tsv.gz"
# motus_pkg_url <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/motus/motus/GROS22_mOTUs3.1.grosextended.motus"
# drep_url <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/drep/drep-099/data_tables/Cdb.csv.gz"
# url_16S_1 <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-1.prok.barrnap.0.9.tsv.gz"
# url_16S_2 <- "https://sunagawalab.ethz.ch/share/BICEST/GROS22/MAGs/metadata/GROS22-2.prok.barrnap.0.9.tsv.gz"
# 
# curl::curl_download(url_new_motus,paste(path,"/BICEST_mag_2_new_motus", sep=""), handle =  h)
# curl::curl_download(url_ref_motus,paste(path,"/BICEST_mag_2_existing_motus", sep=""), handle =  h)
# curl::curl_download(url_tax_bac,paste(path,"/BICEST_gtdbtk.bac120.summary.R214.tsv", sep=""), handle =  h)
# curl::curl_download(url_tax_arc,paste(path,"/BICEST_gtdbtk.ar53.summary.R214.tsv", sep=""), handle =  h)
# curl::curl_download(url_tax_motus,paste(path,"/mOTUs3.1.0.genome_metadata.tsv.gz", sep=""), handle =  h)
# curl::curl_download(url_checkm,paste(path,"/GROS22-2.prok.genomes_2_quality.tsv.gz", sep=""), handle =  h)
# curl::curl_download(url_checkm2,paste(path,"/GROS22-1.prok.genomes_2_quality.tsv.gz", sep=""), handle =  h)
# curl::curl_download(motus_pkg_url,paste(path,"/GROS22_mOTUs3.1.grosextended.motus", sep=""), handle =  h)
# curl::curl_download(drep_url,paste(path,"/Cdb.csv.gz", sep=""), handle =  h)
# curl::curl_download(url_16S_1,paste(path,"/GROS22-1.prok.barrnap.0.9.tsv.gz", sep=""), handle =  h)
# curl::curl_download(url_16S_2,paste(path,"/GROS22-2.prok.barrnap.0.9.tsv.gz", sep=""), handle =  h)

# gunzip(paste0(path,"/mOTUs3.1.0.genome_metadata.tsv.gz"), overwrite = T)
# gunzip(paste0(path,"/Cdb.csv.gz"), overwrite = T)
# gunzip(paste0(path,"/GROS22-2.prok.genomes_2_quality.tsv.gz"), overwrite = T)
# gunzip(paste0(path,"/GROS22-1.prok.genomes_2_quality.tsv.gz"), overwrite = T)
# gunzip(paste0(path,"/GROS22-1.prok.barrnap.0.9.tsv.gz"), overwrite = T)
# gunzip(paste0(path,"/GROS22-2.prok.barrnap.0.9.tsv.gz"), overwrite = T)
```


```{r Import data}
##Read mOTUs##

motus <- read.csv(paste0(path,"/GROS22_mOTUs3.1.grosextended.motus"), sep="\t", skip=2, header = TRUE, row.names = 1) ##Theres some junk in the first two lines
colnames(motus) <- gsub(".*_S", "S", colnames(motus) ) ##here im just removing the projectid for whatever reason. If you want to add this to gene_cat or remove here
rownames(motus) <- gsub(".* ", "", gsub("\\[|\\]", "", rownames(motus))) ##mOTUs contain a taxonomy followed by [mOTU_id] i just want mOTU_id


##Now we want to create  a list which matches each genome to its mOTU 
membership.new = read.csv(paste0(path, "/BICEST_mag_2_new_motus"), sep = "\t", header = FALSE) %>%
  dplyr::rename(mOTU = V1, reps=V2) %>%
  separate_wider_delim(reps, ";", names_sep = "split", too_few=c("align_start")) %>% 
  pivot_longer(!mOTU, values_to = "user_genome",values_drop_na = TRUE) %>% 
  select(user_genome, mOTU)
membership.ref = read.csv(paste0(path, "/BICEST_mag_2_existing_motus"), sep = "\t", header = FALSE, quote="") %>% 
  select(V1, V2)%>%
  dplyr::rename(., user_genome=V1, mOTU=V2)
membership <- rbind(membership.ref, membership.new)
nrow(membership)## 13765
##Read mOTUs Taxonomic Data

bac_gtdb = read.csv(paste0(path, "/BICEST_gtdbtk.bac120.summary.R214.tsv"), sep = "\t", header = TRUE) 
arc_gtdb = read.csv(paste0(path, "/BICEST_gtdbtk.ar53.summary.R214.tsv"), sep = "\t", header = TRUE)
gtdb = rbind(bac_gtdb, arc_gtdb) %>% 
  select(user_genome, classification )##Read in both archaea and bacteria
nrow(gtdb)## 13765
###Read in dRep data 

drep <- read.csv("Cdb.csv") %>% 
  select(genome, secondary_cluster)%>%
  dplyr::rename(user_genome=genome, drep_cluster = secondary_cluster) %>% 
  mutate(user_genome = gsub(".fa", "", user_genome))
nrow(drep) ## 13765
##Read in qa data 

qa <- read.csv(paste0(path,"/GROS22-2.prok.genomes_2_quality.tsv"), sep="\t", quote="") %>% 
  rbind(., read.csv(paste0(path,"/GROS22-1.prok.genomes_2_quality.tsv"), sep="\t", quote="")) %>% 
  dplyr::rename(user_genome = GENOME, completeness=COMPLETENESS, contamination=CONTAMINATION, genome_size=GENOME_SIZE) %>% 
  select(user_genome, completeness, contamination, N50, genome_size)
nrow(qa) ## 13765


##Read in barrnap (16S data)

barrnap <- read.csv(paste0(path, "/GROS22-1.prok.barrnap.0.9.tsv"), sep="\t", quote="") %>% 
  rbind(., read.csv(paste0(path, "/GROS22-2.prok.barrnap.0.9.tsv"), sep="\t", quote="")) %>% 
  dplyr::rename(user_genome = genome, full_16S_rRNA = X16S_rRNA, partial_16S_rRNA = X16S_rRNA_partial) %>%
  select(user_genome, full_16S_rRNA, partial_16S_rRNA)

###Combine all together
genome_stats <- left_join(membership, gtdb) %>% 
  left_join(drep) %>% 
  left_join(qa) %>%
  left_join(barrnap)
nrow(genome_stats) ## 13765
```

###Make dataframes 
```{r}
motu_stats <- genome_stats %>%
  mutate(type = if_else(grepl("NotEnoughMGs", mOTU), "Unassigned", if_else(grepl("ELB", mOTU), "BICEST", "mOTUs.3.1.0"))) 

###If you want to you can use this opportunity to reassign some of your MAGs from Unassigned using dRep clusters###
motu_stats %>% 
  group_by(drep_cluster, mOTU) %>%
  dplyr::summarise(n_mags = n_distinct(user_genome))

##You can already see that for instance 1000_1 has a MAG annotated as NotEnoughMGs, but this probably is ELBEEST_794
##However 1002_1  has 6 MAgs that are NotEnoughMGs, but then 2 that are ELBEEST_87 and ELBEEST_88. It would be nice to know which.
##This can also work in reverse, if we write this to output and search for ext_mOTU_v31_19264, we find around 10 drep clusters, 
##one of these has 141 and the rest 1 MAG each. Here I would tend towards assuming that each of these should be associated to this single mOTU
##Like i said before bad quality MAGs might not cluster with dREp but we find the MGs.
##Just be careful, if you want to modify the easiest way would be
motu_stats %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(n_drep = n_distinct(drep_cluster)) %>%
  filter(n_drep >1) %>% 
  arrange(desc(n_drep))

##This gives you a list of all the mOTUs with lots of drep clusters, 

##Double check the data 
motu_stats[which(motu_stats$mOTU == "ELBEEST_35"),] %>% 
  select(mOTU, drep_cluster, user_genome) %>% 
  group_by(drep_cluster) %>% 
  dplyr::summarise(n_mags = n_distinct(user_genome)) %>% 
  arrange(desc(n_mags))

##Now a quick one liner will rename all the drep_clusters to match the major mOTU cluster
motu_stats[which(motu_stats$mOTU == "ELBEEST_35"), "drep_cluster"] <- "568_8" ##This will remove the additional drep clusters
##Now just rerun the code block above to see that it worked and move on to the next one. 

##Now thats sorted lets see about those NotEnoughMG annots, here we are only interested in those that have 2 unique mOTU, ie un-/classified

motu_stats %>% 
  group_by(drep_cluster, mOTU) %>%
  dplyr::summarise(n_mags = n_distinct(user_genome)) %>% 
  ungroup() %>%
  group_by(drep_cluster) %>% 
  dplyr::summarise(n_mOTU = n_distinct(mOTU), n_mags=sum(n_mags)) %>%
  filter(n_mOTU ==2) %>% 
  arrange(desc(n_mags))

##This gives you a list of all the drep_clusters with lots of mOTUs, 

##Double check the data 
motu_stats[which(motu_stats$drep_cluster == "616_1"),] %>% 
  select(mOTU, drep_cluster, user_genome) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(n_mags = n_distinct(user_genome)) %>% 
  arrange(desc(n_mags))

##So we can see here that there are 134 assigned to ELBEEST_33 and 3 unassigned, lets go ahead and assign these. 
##Again a quick one liner
motu_stats[which(motu_stats$drep_cluster == "616_1"), "mOTU"] <- "ELBEEST_33" ##This will remove the additional drep clusters
##rerun the chunk above and we can see that now all are assigned to ELBEEST_33. 

###Lets plot the data to see how its looking. 
###We dont want to plot all groups so lets see which ones to focus on 
motu_stats %>% 
  separate(classification, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";") %>%
  group_by(phylum) %>%
  dplyr::summarise(n_mags = n_distinct(user_genome)) %>% 
  arrange(desc(n_mags))

##Lets select the top 7 to plot and assign the rest to the "Other" bin

motu_stats %>% 
  separate(classification, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";") %>% 
  mutate(Phylum_plot = ifelse(grepl("p__Pseudomonadota|p__Actinomycetota|p__Bacteroidota|p__Verrucomicrobiota|p__Patescibacteria|p__Planctomycetota|p__Chloroflexota", phylum), phylum, "Other")) %>%
  mutate(Phylum_plot = gsub("p__", "", Phylum_plot)) %>%
  group_by(type, Phylum_plot) %>%
  dplyr::summarise(n_mags = n_distinct(user_genome), PRESENT = sum(partial_16S_rRNA, full_16S_rRNA), ABSENT = n_mags-PRESENT) %>% 
  pivot_longer(cols = c("PRESENT", "ABSENT"), names_to = "rRNA", values_to ="counts") %>% 
  ggplot(aes(y=factor(type, levels=c("Unassigned", "mOTUs.3.1.0", "BICEST")), 
             x = n_mags, 
             alpha = factor(rRNA, levels=c("PRESENT","ABSENT")),
             fill=factor(type, levels=c("Unassigned", "mOTUs.3.1.0", "BICEST")))) + 
  geom_col() + scale_alpha_manual(values = c(1,0.5)) +
  theme_bw() +
  facet_grid(rows=vars(factor(Phylum_plot, levels=c("Actinomycetota", "Bacteroidota", "Chloroflexota", "Patescibacteria", "Planctomycetota",  "Pseudomonadota", "Verrucomicrobiota", "Other"))), 
             drop = TRUE, 
             scales="free", 
             switch = "y", 
             as.table = TRUE
  ) + xlab(label = "MAGs with and without partial 16S rRNA") +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        strip.text.y.left = element_text(angle = 0),
        strip.text = element_text(angle = 90),
        strip.background = element_blank(),
        legend.position = "bottom",
        panel.spacing = unit(0,'lines'),
        panel.border = element_blank()) + 
  labs (fill= "Database Sournce", alpha = "Contains full/partial 16S rRNA") +
  guides(fill = guide_legend(order=2, ncol=3, title.position = "top", 
                             label.hjust = 0, title.vjust = 1,
                             keywidth = unit(0.5, 'cm'), override.aes=list(size = 1)),
         alpha = guide_legend(order=2, ncol=3, title.position = "top", 
                              label.hjust = 0, title.vjust = 1,
                              keywidth = unit(0.5, 'cm')))

#####Ok so we have all that information together.

```

###Plot for instance genome completeness, size etc
```{r}
##First we need to create a single taxonomy for each of the new ELBEEST/BICEST mOTUs

genome_stats %>% 
  select(mOTU) %>% 
  unique() %>% 
  nrow() ## So I get 1172 unique mOTUs, including 874 ELBEEST mOTUs. Depending on your cleaning steps (drep etc) the following might change a bit
##particularly when we look at unique classifications. Lets keep that in mind and go forward

genome_stats %>% 
  select(mOTU, classification) %>% 
  unique() %>% 
  nrow() ## 1946, so now we have added classification and so we have a few hundred examples where there is more than one classification for a mOTU

genome_stats %>% 
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  arrange(desc(count))

##Ok that was a false alarm as we have 732 classifications for unclassified mOTUs

genome_stats %>% 
  filter(mOTU != "NotEnoughMGs") %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  arrange(desc(count)) %>% 
  nrow() ##ok so we need to resolve 40, this might differ when you add unclassified mOTUs into mOTU clusters above. 

##Ok so lets go through and see if we can do this relatively quickly 

motu_to_check <- genome_stats %>% 
  filter(mOTU != "NotEnoughMGs") %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  select(mOTU) %>% 
  pull()

##Ok so we have our list of 40 mOTUs that are conflicting

genome_stats %>% 
  filter(mOTU %in% motu_to_check) %>% 
  select(mOTU, classification, user_genome) %>% 
  group_by(mOTU, classification) %>%
  dplyr::summarise(count = n_distinct(user_genome)) %>%
  arrange(mOTU) %>% 
  print(n=100)
  
##Here we see at a first look that usually there is a more complete and less complete taxonomy. 
##Wracking my brain to automate this but I think we need to do a manual curate so lets set that up.
```

###Curate data
```{r Curate data}
##Just a quick note, how do we make sense of different level tax assignments. Lets say there are 10 MAGs belonging to a mOTU and 9 are assigned to species and 1 not. 
##This is an easy fix, ok lets just take the majority and go to species level. 
##Now what about if we have 9 not assigned and 1 is. Well this might be because only 1 was HQ and able to be assigned to species level. Shouldn't we trust the info from our HQ mag. I say yes!
##Of course with 10 it would be better if a few MAGs were assigned to species not just 1. 
##Generally most of your analysis will occur at the mOTU level or higher taxonomy (family or even phylum ) so dont stress about the need to assign each mOTU to species level. 

##You will also get mOTUs that are assigned to the same species but are two distinct mOTUs, so its not all that simple.

##code hidden here
genome_stats[which(genome_stats$mOTU == "ELBEEST_124" & genome_stats$classification == "d__Bacteria;p__Nitrospirota;c__Nitrospiria;o__Nitrospirales;f__Nitrospiraceae;g__Nitrospira_F;s__"), "classification"] <- "d__Bacteria;p__Nitrospirota;c__Nitrospiria;o__Nitrospirales;f__Nitrospiraceae;g__Nitrospira_F;s__Nitrospira_F sp919902665"
#The next example has two genus annotations for one mOTU, but the major is assigned to a single so we take that one 
genome_stats[which(genome_stats$mOTU == "ELBEEST_125" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Xanthomonadales;f__SZUA-36;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Xanthomonadales;f__SZUA-36;g__JABDPF01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_125" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Xanthomonadales;f__SZUA-36;g__JAHEFT01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Xanthomonadales;f__SZUA-36;g__JABDPF01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_174" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__Halioglobus;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_193" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__UBA3439;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__UBA3439;s__UBA3439 sp016778825"
genome_stats[which(genome_stats$mOTU == "ELBEEST_194" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__UBA3439;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__UBA3439;s__UBA3439 sp016778825"
genome_stats[which(genome_stats$mOTU == "ELBEEST_200" & genome_stats$classification == "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__"), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sulfonica"
genome_stats[which(genome_stats$mOTU == "ELBEEST_221" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Porticoccaceae;g__HTCC2207;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Porticoccaceae;g__HTCC2207;s__HTCC2207 sp002685195"
##Again here we have a genus conflict with 12/14 mOTUs assigned to a single genus which we will take
genome_stats[which(genome_stats$mOTU == "ELBEEST_272" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__SG8-39;g__CAILKO01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__SG8-39;g__SG8-39;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_310" & genome_stats$classification == "d__Bacteria;p__Actinomycetota;c__Acidimicrobiia;o__Acidimicrobiales;f__Ilumatobacteraceae;g__UBA3006;s__"), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Acidimicrobiia;o__Acidimicrobiales;f__Ilumatobacteraceae;g__UBA3006;s__UBA3006 sp903850275"
genome_stats[which(genome_stats$mOTU == "ELBEEST_362" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_A;g__JAHDXY01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_A;g__JAHDXY01;s__JAHDXY01 sp023257915"
genome_stats[which(genome_stats$mOTU == "ELBEEST_370" & genome_stats$classification == "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Pedosphaerales;f__AAA164-E04;g__;s__"), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Pedosphaerales;f__AAA164-E04;g__AAA164-E04;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_376" & genome_stats$classification == "d__Bacteria;p__Desulfobacterota_B;c__Binatia;o__HRBIN30;f__;g__;s__"), "classification"] <- "d__Bacteria;p__Desulfobacterota_B;c__Binatia;o__HRBIN30;f__JAGDMS01;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_403" & genome_stats$classification == "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__UBA3478;s__"), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__UBA3478;s__UBA3478 sp016780435"
genome_stats[which(genome_stats$mOTU == "ELBEEST_412" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_A;g__UBA2463;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_A;g__UBA2463;s__UBA2463 sp945901825"
genome_stats[which(genome_stats$mOTU == "ELBEEST_427" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Micavibrionales;f__UBA2020;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Micavibrionales;f__UBA2020;g__UBA2020;s__"
##here the most are unclassifed at the species level with 3 and 1 assigned to two genera. Lets be rational and take up to family 
genome_stats[which(genome_stats$mOTU == "ELBEEST_439" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__PHCI01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_439" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__JAKFVA01;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__;s__"
##Again two genera 5/1 split
genome_stats[which(genome_stats$mOTU == "ELBEEST_455" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__Rhodoferax_A;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae_B;g__CAIKVZ01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_458" & genome_stats$classification == "d__Bacteria;p__Patescibacteria;c__Paceibacteria;o__UBA9983_A;f__JAACPR01;g__;s__"), "classification"] <- "d__Bacteria;p__Patescibacteria;c__Paceibacteria;o__UBA9983_A;f__JAACPR01;g__JAGOTN01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_492" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudohongiellaceae;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudohongiellaceae;g__CAILUG01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_504" & genome_stats$classification == "d__Bacteria;p__Myxococcota;c__UBA727;o__UBA727;f__JABDBI01;g__;s__"), "classification"] <- "d__Bacteria;p__Myxococcota;c__UBA727;o__UBA727;f__JABDBI01;g__JAHFEG01;s__"
##Here we have a family split 10/4. im tempted to take to order level but for now will select dominant family
genome_stats[which(genome_stats$mOTU == "ELBEEST_514" & genome_stats$classification == "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__DEV007;g__;s__"), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__SKLO01;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_517" & genome_stats$classification == "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__;g__;s__"), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__SKLO01;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_519" & genome_stats$classification == "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__;s__"), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__Lutibacter;s__"
##genus 6/1 split
genome_stats[which(genome_stats$mOTU == "ELBEEST_542" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Methylophilaceae;g__BACL14;s__BACL14 sp905181685"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Gammaproteobacteria;o__Burkholderiales;f__Methylophilaceae;g__BACL14;s__BACL14 sp019823025"
genome_stats[which(genome_stats$mOTU == "ELBEEST_58" & genome_stats$classification == "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__"), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp014190015"
genome_stats[which(genome_stats$mOTU == "ELBEEST_585" & genome_stats$classification == "d__Bacteria;p__Acidobacteriota;c__Vicinamibacteria;o__Vicinamibacterales;f__UBA2999;g__;s__"), "classification"] <- "d__Bacteria;p__Acidobacteriota;c__Vicinamibacteria;o__Vicinamibacterales;f__UBA2999;g__CADEFD01;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_59" & genome_stats$classification == "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__"), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp014190015"
##Family 3/1 split 
genome_stats[which(genome_stats$mOTU == "ELBEEST_601" & genome_stats$classification == "d__Bacteria;p__Patescibacteria;c__Paceibacteria;o__UBA9983_A;f__W02-35-19;g__;s__"), "classification"] <- "d__Bacteria;p__Patescibacteria;c__Paceibacteria;o__UBA9983_A;f__JAGLPS01;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_623" & genome_stats$classification == "d__Bacteria;p__Bdellovibrionota;c__UBA1018;o__UBA1018;f__UBA1018;g__;s__"), "classification"] <- "d__Bacteria;p__Bdellovibrionota;c__UBA1018;o__UBA1018;f__UBA1018;g__CAINWE01;s__"
##Genus 2/1 split, definately going up to family level
genome_stats[which(genome_stats$mOTU == "ELBEEST_700" & genome_stats$classification == "d__Bacteria;p__Cyanobacteriota;c__Vampirovibrionia;o__LMEP-6097;f__LMEP-6097;g__JAJTHA01;s__"), "classification"] <- "d__Bacteria;p__Cyanobacteriota;c__Vampirovibrionia;o__LMEP-6097;f__LMEP-6097;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_700" & genome_stats$classification == "d__Bacteria;p__Cyanobacteriota;c__Vampirovibrionia;o__LMEP-6097;f__LMEP-6097;g__CAIYXB01;s__"), "classification"] <- "d__Bacteria;p__Cyanobacteriota;c__Vampirovibrionia;o__LMEP-6097;f__LMEP-6097;g__;s__"
genome_stats[which(genome_stats$mOTU == "ELBEEST_779" & genome_stats$classification == "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Rickettsiales;f__UBA1997;g__;s__"), "classification"] <- "d__Bacteria;p__Pseudomonadota;c__Alphaproteobacteria;o__Rickettsiales;f__UBA1997;g__UBA2645;s__"


##So that is all of the BICEST mOTUs, we will deal with the mOTUs3.1 seperately because they are built from MAGs that might have a better taxonomic assignment than ours. 
##

genome_stats %>% 
  filter(mOTU != "NotEnoughMGs") %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  select(mOTU) %>% 
  pull()

##Ok so now we only have a few conflicts relating to the ext_mOTUs, first lets extract the classificaiton for the BICEST mOTUs

elbe_taxa <- genome_stats %>% 
  filter(grepl("ELBEEST", mOTU)) %>% 
  select(mOTU, classification) %>% 
  group_by(mOTU) %>%
  unique()
##Quick sanity check

length(unique(elbe_taxa$mOTU)) ##1046
nrow(elbe_taxa) ##1046

##Ok so now we have a single taxonomy for each BICEST mOTU!!

##Lets deal with the reference mOTUs. 

motus_taxa <- read.table(paste0(path, "/mOTUs3.1.0.genome_metadata.tsv"), sep="\t", header=TRUE, quote="") %>% 
  select(GENOME..MOTU, GTDB.R207) %>% 
  dplyr::rename(mOTU = GENOME..MOTU, classification = GTDB.R207)
nrow(motus_taxa) ## so we have taxonomy for 700K MAGs/genomes!!
length(unique(motus_taxa$mOTU)) ## This is around 34195 mOTUs

##Lets see how many are in our profile

motus %>% 
  rownames_to_column("mOTU") %>% 
  select(mOTU) %>%
  filter(!grepl("ELBE", mOTU)) %>% 
  nrow() ## so we have 34341 mOTUs 

##This is a very similar number to the total number of mOTUs so maybe there are quite some zero values

refmOTUs_in_profile <- motus %>% 
  rownames_to_column("mOTU") %>% 
  pivot_longer(!mOTU, names_to = "samples", values_to = "counts") %>% 
  group_by(mOTU) %>%
  dplyr::mutate(total = sum(counts)) %>% 
  filter(total != 0) %>%
  ungroup() %>%
  select(-total) %>% 
  select(mOTU)  %>% 
  unique() %>%
  filter(!grepl("ELBE", mOTU)) %>% 
  pull() ##%>%
  #length() ## Ok so now we have only 2072 ref mOTUs, also for sanity we can remove ! from filter and see that all 1046 BICEST mOTUs are also detected in our profiles.  
length(refmOTUs_in_profile)

##Ok lets check some taxonomy!!  

##First lets remove all of the information for mOTUs not in our profiles      
  
motus_taxa <- motus_taxa %>% 
    rownames_to_column("user_genome") %>% 
    filter(mOTU %in% refmOTUs_in_profile) %>% 
    select(mOTU, classification, user_genome)

nrow(motus_taxa) ##Ok so we are down from 700K genomes to 126k. 
length(unique(motus_taxa$mOTU)) ##Now we lost 11 mOTUs. This is meta_mOTUs which dont have taxonomy associated with them, they are built on MG profiles not MAGs (check paper for details) - we will fix later

##Lets add also our genome taxonomy information incase this helps 

motus_taxa <- genome_stats %>% 
  filter(mOTU %in% motu_to_check) %>% 
  select(mOTU, classification, user_genome) %>% 
  rbind(motus_taxa) 

##So we added around 180 MAGs to the 126K (obviously not much) mOTUs3.1.0 metadata file from our own dataset

##Now we make again a list of taxa with conflict
motu_to_check <- motus_taxa %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  select(mOTU) %>% 
  pull()
length(motu_to_check)
##Great so now we have a list of around 218 mOTUs to check. Lets do this!!

motus_taxa %>% 
  filter(mOTU %in% motu_to_check) %>% 
  select(mOTU, classification, user_genome) %>% 
  group_by(mOTU, classification) %>%
  dplyr::summarise(count = n_distinct(user_genome)) %>%
  arrange(mOTU) %>% 
  print(n=800)

##Now I just realised that this could be a lot more efficient than what we did above.

##code hidden here
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_14660"), "classification"] <- "d__Archaea;p__Thermoproteota;c__Nitrososphaeria;o__Nitrososphaerales;f__Nitrosopumilaceae;g__Nitrosarchaeum;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_15383"), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Coriobacteriia;o__Coriobacteriales;f__Atopobiaceae;g__NM07-P-09;s__NM07-P-09 sp004793665"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_15977"), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__S36-B12;g__S36-B12;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_16111"), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Rhodoferax;s__Rhodoferax sp014190675"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_16115"), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Crocinitomicaceae;g__UBA952;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_16131"), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Polynucleobacter;s__Polynucleobacter sp009927445"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_17177"), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Pelagibacterales;f__Pelagibacteraceae;g__Pelagibacter;s__Pelagibacter sp902565935"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_17878"), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Phocaeicola;s__Phocaeicola vulgatus"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19170" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Crocinitomicaceae;g__M0103;s__M0103 sp903930085"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19171" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp009702965"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19172" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Nanopelagicus;s__Nanopelagicus sp001437855"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19173" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Nanopelagicus;s__Nanopelagicus sp001437855"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19207" ), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__V1-33;g__CAJBME01;s__CAJBME01 sp903954065"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19221" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Chitinophagales;f__Saprospiraceae;g__BJGN01;s__BJGN01 sp014190515"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19232" ), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Opitutales;f__UBA953;g__UBA953;s__UBA953 sp004293385"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19239" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Limnohabitans_A;s__Limnohabitans_A sp001517545"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19252" ), "classification"] <- "dd__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp014190015"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19259" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Nanopelagicus;s__Nanopelagicus sp003569185"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19260" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Methylophilaceae;g__Methylotenera;s__Methylotenera sp903951385"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19262" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila vernalis"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19273" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Chitinophagales;f__Chitinophagaceae;g__Sediminibacterium;s__Sediminibacterium sp017987615"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19287" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__Flavobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19290" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Crocinitomicaceae;g__Fluviicola;s__Fluviicola sp017983675"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19295" ), "classification"] <- "d__Bacteria;p__Actinomycetota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp014190015"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19298" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Caulobacterales;f__Hyphomonadaceae;g__Hyphomonas;s__Hyphomonas sp016124495"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19383" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Schleiferiaceae;g__TMED14;s__TMED14 sp005786915"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19415" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Cytophagales;f__Cyclobacteriaceae;g__ELB16-189;s__ELB16-189 sp016787665"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19437" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Thermoleophilia;o__Gaiellales;f__F1-60-MAGs149;g__F1-60-MAGs149;s__F1-60-MAGs149 sp903960645"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19455" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__Planktophila sp903839585"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19461" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Crocinitomicaceae;g__Fluviicola;s__Fluviicola sp017983675"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19467" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingorhabdus_B;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_19767" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__MED-G116;s__MED-G116 sp004212735"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_21813" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__S36-B12;g__S36-B12;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_22053" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Nitrincolaceae;g__ASP10-02a;s__ASP10-02a sp002335115"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_21767" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Puniceispirillales;f__Puniceispirillaceae;g__MED-G116;s__MED-G116 sp004212735"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_28513" ), "classification"] <- "d__Bacteria;p__Chloroflexota;c__Limnocylindria;o__Limnocylindrales;f__Limnocylindraceae;g__Limnocylindrus;s__Limnocylindrus sp903937225"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_28707" ), "classification"] <- "d__Bacteria;p__Planctomycetota;c__Planctomycetia;o__Gemmatales;f__Gemmataceae;g__UBA969;s__"
motus_taxa[which(motus_taxa$mOTU == "ext_mOTU_v31_28709" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Chitinophagales;f__Chitinophagaceae;g__OLB11;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12332" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__Prevotella copri_A"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12366" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Lachnospirales;f__Lachnospiraceae;g__Agathobacter;s__Agathobacter faecis"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12572" ), "classification"] <- "d__Archaea;p__Thermoproteota;c__Nitrososphaeria;o__Nitrososphaerales;f__Nitrosopumilaceae;g__Nitrosopumilus;s__Nitrosopumilus sp002690535"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12608" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__HIMB59;f__HIMB59;g__HIMB59;s__HIMB59 sp902529795"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12714" ), "classification"] <- "d__;p__;c__;o__;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12781" ), "classification"] <- "d__Archaea;p__Thermoplasmatota;c__Poseidoniia;o__Poseidoniales;f__Poseidoniaceae;g__MGIIa-L2;s__MGIIa-L2 sp002171315"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12833" ), "classification"] <- "d__Bacteria;p__;c__;o__;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_12945" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Rhodothermia;o__Balneolales;f__Balneolaceae;g__UBA1275;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13018" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Puniceispirillales;f__AAA536-G10;g__AAA536-G10;s__AAA536-G10 sp016777705"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13056" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__Luminiphilus;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13185" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhodobacterales;f__Rhodobacteraceae;g__MED-G52;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13209" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__Luminiphilus;s__Luminiphilus sp905182485"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13257" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhodobacterales;f__Rhodobacteraceae;g__GCA-2697345;s__GCA-2697345 sp002697345"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13622" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Flavobacteriaceae;g__GCA-002733185;s__GCA-002733185 sp002713705"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_13782" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__UBA10066;g__MED-G20;s__MED-G20 sp016780365"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_14148" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_14237" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Halieaceae;g__Luminiphilus;s__"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_14284" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__SAR86;f__SAR86;g__GCA-2707915;s__GCA-2707915 sp016777005"
motus_taxa[which(motus_taxa$mOTU == "meta_mOTU_v31_14430" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00049" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00050" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00051" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00052" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00056" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00085" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Enterobacteriaceae;g__Klebsiella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00086" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Enterobacteriaceae;g__Klebsiella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00095" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Enterobacteriaceae;g__Escherichia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00122" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00129" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00131" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00133" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00140" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00150" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00164" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00167" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00168" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00169" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00170" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00188" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00201" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00206" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00215" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00227" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00259" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Acinetobacter;s__Acinetobacter baumannii"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00267" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Acinetobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00283" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Lactobacillales;f__Streptococcaceae;g__Streptococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00296" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Lactobacillales;f__Streptococcaceae;g__Streptococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00312" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Lactobacillales;f__Streptococcaceae;g__Streptococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00328" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Bacillales;f__Bacillaceae_G;g__Bacillus_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00344" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Staphylococcales;f__Staphylococcaceae;g__Staphylococcus;s__Staphylococcus hominis"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00424" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Janthinobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00444" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Curvibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00453" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Acidovorax_A;s_"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00459" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Comamonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00474" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Variovorax;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00483" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Variovorax;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00485" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Variovorax;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00487" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Variovorax;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00520" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00521" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Duganella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00547" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Achromobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00576" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Vibrionaceae;g__Photobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00728" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Micromonosporaceae;g__Micromonospora;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00738" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Micromonosporaceae;g__Micromonospora;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00772" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Rhizobiaceae;g__Mesorhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00800" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Propionibacteriales;f__Propionibacteriaceae;g__Cutibacterium;s__Cutibacterium acnes"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00802" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Corynebacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00853" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Oscillospirales;f__Acutalibacteraceae;g__Ruminococcus_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00855" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Bacteroides;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00870" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00871" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00873" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00881" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Burkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00882" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Comamonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00964" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Micrococcaceae;g__Micrococcus;s__Micrococcus luteus"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00996" ), "classification"] <- "d__Bacteria;p__Campylobacterota;c__Campylobacteria;o__Campylobacterales;f__Campylobacteraceae;g__Campylobacter_B;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_00999" ), "classification"] <- "d__Bacteria;p__Fusobacteriota;c__Fusobacteriia;o__Fusobacteriales;f__Fusobacteriaceae;g__Fusobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01010" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rickettsiales;f__Rickettsiaceae;g__Rickettsia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01011" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rickettsiales;f__Rickettsiaceae;g__Rickettsia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01035" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Oleiphilaceae;g__Marinobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01043" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Rhizobiaceae;g__Rhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01071" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Caulobacterales;f__Caulobacteraceae;g__Brevundimonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01089" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Enterobacteriaceae;g__Yersinia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01096" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Pseudoduganella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01141" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Beijerinckiaceae;g__Methylobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01170" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Tannerellaceae;g__Macellibacteroides;s__Macellibacteroides fermentans"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01185" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Xanthobacteraceae;g__Bradyrhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01191" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Xanthobacteraceae;g__Bradyrhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01211" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01213" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Rhodococcus;s_"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01234" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Paraburkholderia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01241" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Cupriavidus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01242" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Cupriavidus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01243" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Cupriavidus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01274" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Mycobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01337" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01338" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01361" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Chromatiales;f__Chromatiaceae;g__Marichromatium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01404" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Vibrionaceae;g__Vibrio;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01513" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhodobacterales;f__Rhodobacteraceae;g__Cereibacter_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01518" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Azospirillales;f__Azospirillaceae;g__Azospirillum;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01547" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Sphingobacteriales;f__Sphingobacteriaceae;g__Pedobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01556" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Bacillales;f__Bacillaceae;g__Bacillus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01692" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Xanthobacteraceae;g__Bradyrhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01693" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Xanthobacteraceae;g__Bradyrhizobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01786" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Stenotrophomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01789" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingomonas;s__Sphingomonas aquatilis"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01861" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Alteromonadaceae;g__Pseudoalteromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01862" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Alteromonadaceae;g__Pseudoalteromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01866" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Alteromonadaceae;g__Pseudoalteromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01874" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Microbacteriaceae;g__Clavibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01920" ), "classification"] <- "d__Bacteria;p__Cyanobacteria;c__Cyanobacteriia;o__PCC-6307;f__Cyanobiaceae;g__Synechococcus_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01940" ), "classification"] <- "d__Bacteria;p__Firmicutes_C;c__Negativicutes;o__Veillonellales;f__Veillonellaceae;g__Veillonella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01941" ), "classification"] <- "d__Bacteria;p__Firmicutes_C;c__Negativicutes;o__Veillonellales;f__Veillonellaceae;g__Veillonella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_01953" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02019" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Actinomycetaceae;g__Actinomyces;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02037" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Flavobacteriales;f__Weeksellaceae;g__Elizabethkingia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02129" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Rhizobiaceae;g__Aurantimonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02154" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Lachnospirales;f__Lachnospiraceae;g__Blautia_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02348" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhizobiales;f__Stappiaceae;g__Pannonibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02367" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Phocaeicola;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02398" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02485" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Vibrionaceae;g__Vibrio;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02580" ), "classification"] <- "d__Bacteria;p__Cyanobacteria;c__Cyanobacteriia;o__Cyanobacteriales;f__Microcystaceae;g__Microcystis;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02588" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_K;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02642" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Polaromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02650" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Acinetobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02696" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Caulobacterales;f__Caulobacteraceae;g__Brevundimonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02700" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Bifidobacteriaceae;g__Bifidobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02783" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Lactobacillales;f__Enterococcaceae;g__Enterococcus_D;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02795" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02801" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Staphylococcales;f__Staphylococcaceae;g__Staphylococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02804" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Rhodanobacteraceae;g__Rhodanobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_02810" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Bacteroides;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03205" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Acinetobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03341" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Oscillospirales;f__Oscillospiraceae;g__Dysosmobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03342" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Lachnospirales;f__Lachnospiraceae;g__Blautia_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03567" ), "classification"] <- "d__Bacteria;p__Cyanobacteria;c__Cyanobacteriia;o__Cyanobacteriales;f__Microcoleaceae;g__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03572" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Tissierellales;f__Peptoniphilaceae;g__Finegoldia;s_"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03577" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Bifidobacteriaceae;g__Bifidobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03591" ), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Verrucomicrobiales;f__Akkermansiaceae;g__Akkermansia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03640" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Tannerellaceae;g__Parabacteroides;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03657" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Lachnospirales;f__Lachnospiraceae;g__Agathobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03701" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Bacteroidales;f__Bacteroidaceae;g__Prevotella;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03761" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Aeromonadaceae;g__Aeromonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03850" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Lysobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_03854" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Sphaerotilus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04025" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Oleiphilaceae;g__Marinobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04078" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Enterobacterales;f__Vibrionaceae;g__Vibrio;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04204" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Rhodobacterales;f__Rhodobacteraceae;g__Ascidiaceihabitans;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04231" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Arenimonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04265" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Pelagibacterales;f__Pelagibacteraceae;g__Pelagibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04339" ), "classification"] <- "d__Bacteria;p__Firmicutes;c__Bacilli;o__Staphylococcales;f__Staphylococcaceae;g__Staphylococcus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04469" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Lysobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04470" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Lysobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04516" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingobium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04596" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__Burkholderiaceae;g__Rhizobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04616" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Actinomycetales;f__Microbacteriaceae;g__Plantibacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04737" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Pseudomonadaceae;g__Pseudomonas_E;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04792" ), "classification"] <- "d__Bacteria;p__Bacteroidota;c__Bacteroidia;o__Sphingobacteriales;f__Sphingobacteriaceae;g__Sphingobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04802" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Corynebacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_04827" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Halomonadaceae;g__Halomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05125" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Pseudonocardiaceae;g__Pseudonocardia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05354" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Mycobacteriales;f__Mycobacteriaceae;g__Mycobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05380" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Lysobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05437" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Caulobacterales;f__Caulobacteraceae;g__Phenylobacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05522" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Burkholderiales;f__;g__;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05841" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Marinomonadaceae;g__Marinomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_05975" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Sphingomonadales;f__Sphingomonadaceae;g__Sphingomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06002" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Moraxella_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06109" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Oscillospirales;f__Ruminococcaceae;g__Faecalibacterium;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06146" ), "classification"] <- "d__Bacteria;p__Campylobacterota;c__Campylobacteria;o__Campylobacterales;f__Arcobacteraceae;g__Aliarcobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06160" ), "classification"] <- "d__Bacteria;p__Myxococcota;c__Myxococcia;o__Myxococcales;f__Anaeromyxobacteraceae;g__Anaeromyxobacter;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06277" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Xanthomonadales;f__Xanthomonadaceae;g__Stenotrophomonas;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06494" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Pelagibacterales;f__Pelagibacteraceae;g__IMCC9063;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_06514" ), "classification"] <- "d__Bacteria;p__Verrucomicrobiota;c__Verrucomicrobiae;o__Pedosphaerales;f__AAA164-E04;g__AAA164-E04;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_07361" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__SAR86;f__D2472;g__D2472;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_09389" ), "classification"] <- "d__Bacteria;p__Firmicutes_A;c__Clostridia;o__Peptostreptococcales;f__Peptostreptococcaceae;g__Romboutsia;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_10657" ), "classification"] <- "d__Bacteria;p__Proteobacteria;c__Alphaproteobacteria;o__Pelagibacterales;f__Pelagibacteraceae;g__Pelagibacter_A;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_12136" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Nanopelagicus;s__"
motus_taxa[which(motus_taxa$mOTU == "ref_mOTU_v31_12137" ), "classification"] <- "d__Bacteria;p__Actinobacteriota;c__Actinomycetia;o__Nanopelagicales;f__Nanopelagicaceae;g__Planktophila;s__"


motus_taxa %>%
  select(mOTU, classification) %>% 
  group_by(mOTU) %>% 
  dplyr::summarise(count = n_distinct(classification)) %>%
  filter(count > 1) %>% 
  select(mOTU) %>% 
  pull()

##Hurrah so now we have a single taxonomy for each of the mOTUs3.1.0 db mOTUs. 

motu_final_taxa <- motus_taxa %>% 
  select(mOTU, classification) %>% 
  group_by(mOTU) %>%
  unique()

##Quick sanity check

length(unique(motu_final_taxa$mOTU)) ##2063
nrow(motu_final_taxa) ##2063

##If this doesnt look right reload mOTUs db and try again, i was having some issues.

elbe_motu_taxa <- rbind(elbe_taxa, motu_final_taxa) %>% 
  separate(classification, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";")

#Fix errors
elbe_motu_taxa[c(1394,1660,1683,1684),]
elbe_motu_taxa[c(1394,1660,1683,1684),]$domain = c("d__Bacteria", "d__Bacteria","d__Bacteria","d__Bacteria")
elbe_motu_taxa[c(1394,1660,1683,1684),]$phylum = c("p__Cyanobacteria", "p__","p__","p__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$class = c("c__Cyanobacteriia", "c__","c__","c__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$order = c("o__Cyanobacteriales", "o__","o__","o__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$family = c("f__Microcoleaceae ", "f__","f__","f__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$genus = c("g__", "g__","g__","g__")
elbe_motu_taxa[c(1394,1660,1683,1684),]$species = c("s__", "s__","s__","s__")
elbe_motu_taxa[c(1394,1660,1683,1684),]
```

###Create tables to use
```{r Create final tables}
##Lets also do what we didnt before and create a simplified mOTU table

motus_final <- motus %>% 
  rownames_to_column("mOTU") %>% 
  pivot_longer(!mOTU, names_to = "samples", values_to = "counts") %>% 
  group_by(mOTU) %>%
  dplyr::mutate(total = sum(counts)) %>% 
  filter(total != 0) %>%
  ungroup() %>%
  select(-total) %>% 
  pivot_wider(names_from = "samples", values_from = "counts")

nrow(motus_final) #3118 which is longer than our 3109 taxa, this includes some meta_motus that dont have taxonomy, as well as unclassified seqs, lets fix this.

elbe_motu_taxa <- motus_final %>%
  select(mOTU) %>% 
  filter(!mOTU %in% elbe_motu_taxa$mOTU) %>% 
  dplyr::mutate(classification = "d__;p__;c__;o__;f__;g__;s__") %>%
  separate(classification, c("domain", "phylum", "class", "order", "family",  "genus", "species"), ";") %>%
  rbind(.,elbe_motu_taxa) %>%
  distinct()
dim(elbe_motu_taxa)  
##Great so now we have taxonomy for the 3118 mOTUs (inc unassigned) that occur in our profile
```


```{r Add metadata and assess fraction splits}
#All we are missing is the metadata, I steal code chunk from the functional profile##

metadata <- read.csv("SAMEAID_SampleID.csv", header=TRUE, sep=";", dec=",") %>% 
  mutate(sampleid=paste0(BioSample,"_METAT")) %>%
  mutate(data_type="METAT")

metadata2 <- read.csv("SAMEAID_SampleID.csv", header=TRUE, sep=";", dec=",") %>% 
  mutate(sampleid=paste0(BioSample,"_METAG"))%>%
  mutate(data_type="METAG")

metadata <- rbind(metadata, metadata2) 
##There are some missing values for replicates and I want to simplify headers using good practice (lowercases, no special char, english)

metadata <- metadata %>% 
  select(sampleid, station=Station, station_km = Stromkilometer, sample_type = Sample_type, date=Sample_date, o2_sat=Sat_O2_TBDHereon, wtemp=Temperature_TBDHereon, 
         salinity=Salinity_TBDHereon, turbidty=Turbidity_TBDHereon, ph=pH_TBDHereon, o2_conc=O2_TBDHereon, spm_mg_l=SPM_mgperL, doc_mg_l=DOC_mg.L, tn_mg_l=TN_mg.L,
         dic_mg_l=DIC_mg.L, si_mg_l=Silicate_mg.L, nh4_mg_l=Ammonium_mg.L, no2_mg_l=Nitrite_mg.L, no3_mg_l=Nitrate_mg.L, din_um=Total_DIN_ÂµM, srp_ml_l=SRP_mgperL,
         tdp_mg_l=TotalDissolvedPhosphate_mg.L, nh4_um = Ammonium_ÂµM, no2_um = Nitrite_ÂµM, no3_um = Nitrate_ÂµM, srp_um = SRP_ÂµM, tdp_um = Phosphate_ÂµM,
         si_um = Silicate_ÂµM, doc_um = DOC_uM.L, dic_um = DIC_uM.L, respiration_o2_ug_l_h=RespirationRate_O2ug.L.h, poc_mg_l = POC_mgperL, ptc_mg_l = PTC_mgperL, 
         ptn_mg_l = PTN_mgperL, pth_mg_l = PTH_mgperL, BioSample, ERANumber, data_type)

##Sometimes the replicates miss values, to correct we will group by station, date, sample_type(fraction), then calculate the mean value ignoring na. 
##If there isnt a measurement it returns a NaN value

metadata <- metadata %>% 
  group_by(station, date, sample_type) %>%
  mutate(across(where(is.numeric), ~mean(., na.rm = TRUE))) %>% 
  ungroup()

#Check if there's any duplicates
metadata$duplicate = duplicated(metadata) | duplicated(metadata, fromLast = TRUE)
unique(metadata$duplicate)

metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(714.98, 613, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)

write.csv(metadata, "metadata.csv")
#saveRDS(metadata, file="metadata.RDS")

##Lets create a dataframe to hold all the data (yes this can be done with phyloseq but phyloseq has its own problems and we usually end up exporting tables back out for vegan anyway so we can work from here )

motus_final_taxa_metadata <- motus_final %>%
  pivot_longer(!mOTU, names_to = "sampleid", values_to = "counts") %>% 
  left_join(., elbe_motu_taxa) %>% 
  left_join(., metadata)

##Lets save what we have produced and cleanup some of the rubbish
##Its a good idea to hash this out so we dont accidentally overwrite anything

saveRDS(motus_final_taxa_metadata, file="motus_final_taxa_metadata.RDS")
saveRDS(motu_stats, file="motu_stats.RDS")
saveRDS(metadata, file="metadata.RDS")

rm(list=ls())
```



```{r Re-read in saved data}
motus_final_taxa_metadata <- readRDS(file="D:/Functional_R_analysis/motus_final_taxa_metadata.RDS")
metadata <- readRDS(file="D:/Functional_R_analysis/metadata.RDS")
##Lets check out experimental scheme

setwd("D:/Functional_R_analysis/")
path <- getwd()

motus_final_taxa_metadata %>% 
  select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, date) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##So when we consider fraction and date we see that Nov 21 has few samples, we should consider removing

motus_final_taxa_metadata %>% 
  select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, station) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##By station we see that Kollmar, SeemanshÃÂ¶ft and BunthausSpitze also were sampled infrequently, lets also remove these. 

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date))
```


```{r Check counts}
####Lets see how our counts look across all the samples, im going to create sub_files for plotting rather than piping directly to ggplot because it takes time
##when we want to adjust visuals

sample_specific_counts <- motus_final_taxa_metadata %>% 
  group_by(sampleid) %>%
  dplyr::mutate(sample_sums=sum(counts)) %>% 
  select(sampleid, data_type, sample_type, sample_sums)


  ggplot(sample_specific_counts,aes(x=sampleid, y=sample_sums)) + geom_point() 

##Ok there are clearly some samples with far fewer mOTU counts. Lets see how this looks when we compare metaT and metaG, also for the different size fractions

sample_specific_counts %>%
  ggplot() +
  geom_point(aes(x=sampleid, y=sample_sums)) +
  facet_wrap(~data_type*sample_type, scales="free_y", nrow=2)

###So take homes. We shouldnt compare metaG an metaT because the counts are an order of magnitude. You can look at metaT later. For now i will ignore. 
###Should we compare FL and PA (maybe but also maybe not), 
###There is an argument for comparing FL and PA but generally you want to explore what are the drivers of composition independent of fraction anyway. 
##Lets split the files, i will keep heavy and light together, splitting more reduces the number of pairwise comparisons which also helps.

colnames(motus_final_taxa_metadata)

motus_metadata_metag_fl <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG" & sample_type == "Free_living")

motus_metadata_metag_pa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG" & sample_type != "Free_living")

##Lets start with free-living by first checking the sample_sums again

motus_metadata_metag_fl %>% 
  group_by(sampleid) %>%
  mutate(sample_sums=sum(counts)) %>%
  select(sampleid, station, date, sample_sums) %>%
  unique() %>% 
  arrange(sample_sums) %>% 
  print(n=61)

##So we can see here that counts from Feb 22 are also quite low from all free-living samples. 

motus_metadata_metag_pa %>% 
  group_by(sampleid) %>%
  mutate(sample_sums=sum(counts)) %>%
  select(sampleid, station, date, sample_sums) %>%
  unique() %>% 
  arrange(sample_sums) %>% 
  print(n=61)

##So we can see here that counts from Feb 22 are also quite low from all particle-associated samples. These are in theory the only winter samples. 
##These samples generally had lower read counts. Anyway lets compare this also with the functional profiles to make an assessment. 
##We dont want to throw away a whole month of samples if the data are biologically interesting but also we shouldnt force a perspective based on sampling depth

##For now I will remove them

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Feb 22", date))

motus_metadata_metag_fl <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG" & sample_type == "Free_living")

motus_metadata_metag_pa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG" & sample_type != "Free_living")

##Lets check again

motus_metadata_metag_fl %>% 
  group_by(sampleid) %>%
  mutate(sample_sums=sum(counts)) %>%
  select(sampleid, station, date, sample_sums) %>%
  unique() %>% 
  arrange(sample_sums) %>% 
  print(n=61)

##Theres two samples with low counts (lower than 14k), lets remove these also

motus_metadata_metag_fl <- motus_metadata_metag_fl %>% 
  filter(!grepl("SAMEA112714820_METAG|SAMEA110290254_METAG", sampleid))

##and the particle associated

motus_metadata_metag_pa %>% 
  group_by(sampleid) %>%
  mutate(sample_sums=sum(counts)) %>%
  select(sampleid, station, date, sample_sums) %>%
  unique() %>% 
  arrange(sample_sums) %>% 
  print(n=61)

#Here the sums are generally lower with a plateau around 8k reads. For now we will leave everything and come back if these cause issues.
```
###Make phyloseq ovbject

```{r}
#so to do a ternary plot we actually need to create a physeq object really quick 
motus_table <- motus_final_taxa_metadata %>%
  filter(data_type == "METAG") %>%
  select(mOTU, sampleid, counts) %>%
  group_by(sampleid) %>% 
  mutate(total=sum(counts)) %>% 
  filter(total > 2400) %>%  ##Here we just remove those with low counts
  select(-total) %>% 
  ungroup() %>% 
  pivot_wider(names_from = sampleid, values_from = counts, values_fill = 0) %>% 
  column_to_rownames("mOTU") %>% 
  phyloseq::otu_table(taxa_are_rows = TRUE)
motus_taxa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  select(mOTU, phylum, class, order, family, genus, species) %>% 
  unique() %>% 
  column_to_rownames("mOTU") %>% 
  as.matrix() %>%
  phyloseq::tax_table()
motus_sampledata <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  select(-phylum, -class, -order, -family, -genus, -species, -counts, -mOTU, -domain) %>% 
  unique() %>%  
  column_to_rownames("sampleid") %>% 
  sample_data()
bicest_motu_ps <- phyloseq(motus_table, motus_taxa, motus_sampledata)
bicest_motu_ps
#bicest_motu_ps_v0 = bicest_motu_ps
```


#Sequencing info and stats - Figure 1

```{r}
#Sample numbers
Samplenumbers = read.csv("Datasets_ReadGeneInfo.csv", sep = "\t") %>%
  mutate(across(-c(SAMPLE), gsub, pattern = "\\.", replacement = "")) %>%
  mutate(across(-c(SAMPLE), gsub, pattern = " ", replacement = "")) %>%
  separate(., SAMPLE, sep = "_", into = c("projectid", "sampleid", "sequencing"))

Samplenumbers %>%
  group_by(sequencing) %>%
  count(sequencing) 
  

#How many MAGs - total and average
MAGnumbers = gene_cluster_taxa %>%
  select(genome) %>%
  distinct()
MAGnumbers %>%
  group_by(genome) %>%
  count(genome)


#How many reads - total and average
Sequ_info_METAG.df = read.csv("Datasets_ReadGeneInfo.csv", sep = "\t") %>%
  mutate(across(-c(SAMPLE), gsub, pattern = "\\.", replacement = "")) %>%
  mutate(across(-c(SAMPLE), gsub, pattern = " ", replacement = "")) %>%
  mutate(across(-c(SAMPLE), as.numeric))
  #bind_rows(summarise_all(., ~if(is.numeric(.)) sum(.) else "Total"))
  #bind_rows(summarise_all(., ~if(is.numeric(.)) median(.) else "Median"))
total = Sequ_info_METAG.df %>%
  filter(!is.na(Predicted_Genes)) %>%
  bind_rows(summarise_all(., ~if(is.numeric(.)) sum(.) else "Total")) %>%
  tail(., n = 1)
total[nrow(total), ]
average = Sequ_info_METAG.df %>%
  filter(!is.na(Predicted_Genes)) %>%
  bind_rows(summarise_all(., ~if(is.numeric(.)) mean(.) else "Average")) %>%
  tail(., n = 1)
average[nrow(average), ]

#How many genes? - total and average
dim(clstr)[1] / 263
#How many unique genes? - total and average
length(unique(clstr$gene_cluster))
length(unique(clstr$gene_cluster)) / 263

```
#Physicochemical PCA - Figure 1
```{r}

#Read in new PP dataframe as a clean data frame
Physicochem.df = readxl::read_xlsx("D:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Make relevant columns numeric
#Physicochem.df = Physicochem.df %>% mutate_at(c('SPM_mgperL', 'POC_mgperL'), as.numeric)
Physicochem.df$SPM_mgperL = as.numeric(Physicochem.df$SPM_mgperL)
Physicochem.df$POC_mgperL = as.numeric(Physicochem.df$POC_mgperL)
Physicochem.df$PTC_mgperL = as.numeric(Physicochem.df$PTC_mgperL)
Physicochem.df$PTN_mgperL = as.numeric(Physicochem.df$PTN_mgperL)
Physicochem.df$PTH_mgperL = as.numeric(Physicochem.df$PTH_mgperL)
Physicochem.df$TEP_um2perL = as.numeric(Physicochem.df$TEP_um2perL)
Physicochem.df$CSP_um2perL = as.numeric(Physicochem.df$CSP_um2perL)
Physicochem.df$ParticleArea_um2perL = as.numeric(Physicochem.df$ParticleArea_um2perL)


#Add PA PP to Free-living rows 

#Extract sample numbers for FL - MG
FL_samples.df = Physicochem.df %>%
  filter(Sample_type == "Free_living")
PA_PP.ls = c("SPM_mgperL", "POC_mgperL", "PTC_mgperL", "PTN_mgperL", "PTH_mgperL", "TEP_um2perL", "CSP_um2perL", "ParticleArea_um2perL")
count = 1
i=92
x="TEP_um2perL"
for (i in 1:length(Physicochem.df$Associatednumber)) {
  if (grepl(Physicochem.df$Sample_type[i], "Free_living") == T ) {
    #Bug hunting
    #print(paste0("Match ",count, " found"))
    PA_sub.df = subset(Physicochem.df, Sample_type!="Free_living" & 
                         station_km == Physicochem.df$station_km[i] & 
                         Sample_date == Physicochem.df$Sample_date[i])
    for (x in PA_PP.ls) {
      
      print(x)
      #Bug hunting
      #print(paste0("Matching ", x))
      mean.tmp = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
      #Bug hunt
      #print(paste0("Getting ", mean.tmp))
      Physicochem.df[i,x] = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
    }
    count = count + 1
  }
}


#Select only relevant parameters
PCA.df = Physicochem.df %>%
  select(station_km, Sample_type, Sample_date, Sat_O2_Perc, Temperature_TBDHereon, Salinity_PSU, Turbidity_NTU, 
         #pH, 
         #Silicate_mg.L, 
         Ammonium_mg.L, Nitrite_mg.L, Nitrate_mg.L, SRP_mgperL, TotalDissolvedPhosphate_mg.L, 
         dCH4_nM, dCO2_uM, 
         SPM_mgperL, DOC_mg.L, DIC_mg.L, TN_mg.L, PTN_mgperL, TEP_um2perL, CSP_um2perL, ParticleArea_um2perL) %>%
  na.omit() %>%
  mutate(across(-c(Sample_type, Sample_date), as.numeric))


dim(PCA.df)


pca_result <- prcomp(PCA.df[,-c(1:3)], center = TRUE, scale. = TRUE)

# Display the PCA results
summary(pca_result)

# Convert PCA scores to a dataframe
pca_scores <- as.data.frame(pca_result$x)

# Add the categorical column to the PCA scores
pca_scores$station_km <- as.factor(as.character(PCA.df$station_km))
pca_scores$Sample_type <- as.factor(as.character(PCA.df$Sample_type))
pca_scores$Sample_date <- as.factor(as.character(gsub("-", " ", PCA.df$Sample_date)))

# Extract PCA loadings (contributions of variables to PCs)
loadings <- as.data.frame(pca_result$rotation[, 1:2]) # Only PC1 and PC2
loadings$variable <- rownames(loadings)

# Calculate the magnitude of loadings to rank contributions
loadings$contribution <- sqrt(loadings$PC1^2 + loadings$PC2^2)

# Select top 5 contributing variables
top5_variables <- loadings %>%
  arrange(desc(contribution)) %>%
  slice(1:5)

# Scale loadings for better visualization (optional, e.g., to match plot dimensions)
scale_factor <- max(abs(pca_scores$PC1), abs(pca_scores$PC2))
top5_variables <- top5_variables %>%
  mutate(PC1_scaled = PC1 * scale_factor,
         PC2_scaled = PC2 * scale_factor)

pca_scores$Sample_date = factor(pca_scores$Sample_date,
                                levels = c("May 21",
                                           "Jul 21",
                                           "Feb 22",
                                           "May 22",
                                           "Jun 22",
                                           "Nov 22"))

# Add top 5 variables to the plot
Env.PCA <- ggplot(pca_scores, aes(x = PC1, y = PC2, color = Sample_date, shape = station_km)) +
  geom_point(size = 3) +  # Size of the points
  xlab("Principal Component 1 (30.6%)") + #added percentage value based on summary
  ylab("Principal Component 2 (16.2%)") + #added percentage value based on summary
  scale_color_manual("Date", values = Date_colour_list) +
  scale_shape_manual("Station", values = Shape_list) +
  geom_segment(data = top5_variables, aes(x = 0, y = 0, xend = PC1_scaled, yend = PC2_scaled), # add top 5 variables
               arrow = arrow(length = unit(0.2, "cm")), color = "black", inherit.aes = FALSE) +
  ggrepel::geom_text_repel(data = top5_variables, aes(x = PC1_scaled, y = PC2_scaled, label = variable), # add text labels tp top 5 variables
                  inherit.aes = FALSE, color = "black", size = 5) +
  My_Theme

Env.PCA


pdf("D:/Functional_R_analysis/Figures/EnvironmentalPCA.pdf", height = 5, width = 6)
Env.PCA
dev.off()
```
##Associated statistics
```{r}


dissimilarity_matrix <- vegdist(PCA.df[, -c(1:3)], method = "bray")

PCA.df$station_km = as.factor(as.character(PCA.df$station_km))

# Perform PERMANOVA using adonis() to test the effects of X1 and X2
adonis_result <- adonis2(dissimilarity_matrix ~ station_km * Sample_type * Sample_date, data = PCA.df)
print(adonis_result)


```

#Physicochemical heatmap - Figure 2
```{r Set up physicochemical plot}


#Read in new PP dataframe as a clean data frame
Physicochem.df = readxl::read_xlsx("D:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Make relevant columns numeric
#Physicochem.df = Physicochem.df %>% mutate_at(c('SPM_mgperL', 'POC_mgperL'), as.numeric)
Physicochem.df$SPM_mgperL = as.numeric(Physicochem.df$SPM_mgperL)
Physicochem.df$POC_mgperL = as.numeric(Physicochem.df$POC_mgperL)
Physicochem.df$PTC_mgperL = as.numeric(Physicochem.df$PTC_mgperL)
Physicochem.df$PTN_mgperL = as.numeric(Physicochem.df$PTN_mgperL)
Physicochem.df$PTH_mgperL = as.numeric(Physicochem.df$PTH_mgperL)
Physicochem.df$TEP_um2perL = as.numeric(Physicochem.df$TEP_um2perL)
Physicochem.df$CSP_um2perL = as.numeric(Physicochem.df$CSP_um2perL)
Physicochem.df$ParticleArea_um2perL = as.numeric(Physicochem.df$ParticleArea_um2perL)


#Add PA PP to Free-living rows 

#Extract sample numbers for FL - MG
FL_samples.df = Physicochem.df %>%
  filter(Sample_type == "Free_living")
PA_PP.ls = c("SPM_mgperL", "POC_mgperL", "PTC_mgperL", "PTN_mgperL", "PTH_mgperL", "TEP_um2perL", "CSP_um2perL", "ParticleArea_um2perL")
count = 1
i=92
x="TEP_um2perL"
for (i in 1:length(Physicochem.df$Associatednumber)) {
  if (grepl(Physicochem.df$Sample_type[i], "Free_living") == T ) {
    #Bug hunting
    #print(paste0("Match ",count, " found"))
    PA_sub.df = subset(Physicochem.df, Sample_type!="Free_living" & 
                         station_km == Physicochem.df$station_km[i] & 
                         Sample_date == Physicochem.df$Sample_date[i])
    for (x in PA_PP.ls) {
      
      print(x)
      #Bug hunting
      #print(paste0("Matching ", x))
      mean.tmp = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
      #Bug hunt
      print(paste0("Getting ", mean.tmp))
      Physicochem.df[i,x] = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
    }
    count = count + 1
  }
}

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DOC_uM.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

colnames(PP_totest.df)
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% 
  dplyr::select(all_of(PP_totest.ls))

#Make sure rownames have been preserved
rownames(PP_totest.df)
dim(PP_totest.df)


#Apply row numbers from sample IDs
rownames(PP_totest.df) = PP_totest.df$Associatednumber
PP_totest.df$Associatednumber = NULL


#Add density data - calculated from dry-weight and area
PP_totest.df$Density_mgperL_um2perL = (as.numeric(PP_totest.df$SPM_mgperL) / (as.numeric(PP_totest.df$ParticleArea_um2perL))) * 10^5

Physicochem.df = PP_totest.df

Physicochem.df = sapply(Physicochem.df, as.numeric)
```

##Heatmap generation
```{r}
#Make results dataframe
Results_PPvsPP.df = data.frame(Var1 = as.character("DELETEME"),
                        Var2 = as.character("DELETEME"),
                        p.value = as.numeric(9999999),
                        rho.value = as.numeric(9999999))
#Make results dataframe
Results_PPvsPP_pearson.df = data.frame(Var1 = as.character("DELETEME"),
                        Var2 = as.character("DELETEME"),
                        p.value = as.numeric(9999999),
                        rho.value = as.numeric(9999999))
Results_PPvsPP.df = subset(Results_PPvsPP.df, Var1!= "dCH4_uM")

#Run pearson for directionality
stats::cor(Physicochem.df)
     
#Run comparison tests
i=8
x=8
count = 1
for (i in 1:ncol(Physicochem.df)) {
  #print(paste0("The first PP variable is ", colnames(Physicochem.df)[i]))
  
  for (x in 1:ncol(Physicochem.df)) {
  #print(paste0("PP2 is ", colnames(Physicochem.df)[x]))
    
    if (grepl(colnames(Physicochem.df)[i], "Silicate_mg.L") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "Silicate_mg.L") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "dCH4_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "dCH4_nM") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "dCO2_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "Total_DIN_uM") == T & grepl(colnames(Physicochem.df)[x], "dCO2_nM") == T |
        grepl(colnames(Physicochem.df)[i], "dCH4_uM") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "dCH4_nM") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "dCO2_uM") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T | 
        grepl(colnames(Physicochem.df)[i], "dCO2_nM") == T & grepl(colnames(Physicochem.df)[x], "Total_DIN_uM") == T ) {
          
  print(paste0("Error with: i = ", colnames(Physicochem.df)[i] ," & x = ", colnames(Physicochem.df)[x]))
          
} else {
  
  
    #Convert to dataframe
    PP1.tmp <- as.data.frame(Physicochem.df[,i])
    PP2.tmp <- as.data.frame(Physicochem.df[,x])
    
    
    #Make PP dissimilarity matrix
    PP1.dist = dist(PP1.tmp)
    PP2.dist = dist(PP2.tmp)
    
    #Run mantel test
    test.tmp = vegan::mantel(PP1.dist, PP2.dist, method = "pearson", permutations = 999, na.rm = TRUE) # we are looking for linear relationships, so we use a pearson instead of a spearman test (which also includes more complex monotonic relationships)
    
    
    
    
  
    tmp.df = data.frame(Var1 = colnames(Physicochem.df)[i],
                        Var2 = colnames(Physicochem.df)[x],
                        p.value = as.numeric(test.tmp$signif),
                        rho.value = as.numeric(test.tmp$statistic))
    
    Results_PPvsPP.df = rbind(Results_PPvsPP.df, tmp.df)
    
  
}
    count = count + 1
    
  print(paste0("Completed ", count, " out of ", ncol(Physicochem.df)^2, " physicochemical parameters, which is ", round(count/(ncol(Physicochem.df)^2)*100, digits = 2), "%"))
  
  }  
  
}

test = as.data.frame(Physicochem.df)
#Run pearson for directionality
tmp = stats::cor(Physicochem.df, use = "pairwise.complete.obs")
#write.csv(tmp, "D:/Functional_R_analysis/PP_correlation_pearsondirection.csv")


#Remove initial row with DELETEME
Results_PPvsPP.df = Results_PPvsPP.df[-1,]

#Remove self comparisons
Results_PPvsPP.df = Results_PPvsPP.df %>% 
  as_tibble() %>% 
  mutate(duplicates = if_else(Var1 == Var2,
                              TRUE,
                              FALSE)) %>% 
  filter(duplicates == FALSE)

#Select only significant interactions
Results_PPvsPP_sign.df = subset(Results_PPvsPP.df, p.value < 0.05)

#Add Density to both Var1 and Var2, as nothing was significant
Results_PPvsPP_sign.df = 	rbind(Results_PPvsPP_sign.df, list('Density_mgperL_um2perL', 'Density_mgperL_um2perL', 0, 0, FALSE))


Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="dCH4_uM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="dCH4_uM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="dCO2_nM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="dCO2_nM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="PTH_mgperL")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="PTH_mgperL")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="Sat_O2_Perc")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="Sat_O2_Perc")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var1!="Total_DIN_uM")
Results_PPvsPP_sign.df = subset(Results_PPvsPP_sign.df, Var2!="Total_DIN_uM")

#For adjusting code
#colnames(Results_PPvsPP_sign.df)
#colnames(Results_PPvsPP_sign.df) = c("Var1", "Var2", "p.value", "rho.value", "duplicates")

#Change variable names for nice plots
Results_PPvsPP_sign.df$Var1 = gsub("station_km", "Elbe km", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Salinity_PSU", "Salinity (PSU)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Temperature_TBDHereon", "Temperature (Â°C)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("dCO2_uM", "dCO2 (ÂµM)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("dCH4_nM", "dCH4 (nM)", Results_PPvsPP_sign.df$Var1)

Results_PPvsPP_sign.df$Var1 = gsub("O2_uM", "dO2 (ÂµM)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Turbidity_NTU", "Turbidity (NTU)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("PTC_mgperL", "PTC (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("SPM_mgperL", "Dry-weight (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("POC_mgperL", "POC (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("DOC_mg.L", "DOC (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("DIC_mg.L", "DIC (mg L-1)", Results_PPvsPP_sign.df$Var1)

Results_PPvsPP_sign.df$Var1 = gsub("PTN_mgperL", "PTN (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("TN_mg.L", "DTN (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Ammonium_mg.L", "NH4+ (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Nitrite_mg.L", "NO2- (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Nitrate_mg.L", "NO3- (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Silicate_mg.L", "Si (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("TotalDissolvedPhosphate_mg.L", "DP (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("SRP_mgperL", "SRP (mg L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("TEP_um2perL", "TEP (Âµm2 L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("CSP_um2perL", "CSP (Âµm2 L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("Density_mgperL_um2perL", "Density (mgL-1 Âµm2L-1)", Results_PPvsPP_sign.df$Var1)
Results_PPvsPP_sign.df$Var1 = gsub("ParticleArea_um2perL", "Particle area (um2 L-1)", Results_PPvsPP_sign.df$Var1)

#Change variable names for nice plots
Results_PPvsPP_sign.df$Var2 = gsub("station_km", "Elbe km", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Salinity_PSU", "Salinity (PSU)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Temperature_TBDHereon", "Temperature (Â°C)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("dCO2_uM", "dCO2 (ÂµM)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("dCH4_nM", "dCH4 (nM)", Results_PPvsPP_sign.df$Var2)

Results_PPvsPP_sign.df$Var2 = gsub("O2_uM", "dO2 (ÂµM)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Turbidity_NTU", "Turbidity (NTU)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("PTC_mgperL", "PTC (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("SPM_mgperL", "Dry-weight (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("POC_mgperL", "POC (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("DOC_mg.L", "DOC (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("DIC_mg.L", "DIC (mg L-1)", Results_PPvsPP_sign.df$Var2)

Results_PPvsPP_sign.df$Var2 = gsub("PTN_mgperL", "PTN (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("TN_mg.L", "DTN (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Ammonium_mg.L", "NH4+ (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Nitrite_mg.L", "NO2- (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Nitrate_mg.L", "NO3- (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Silicate_mg.L", "Si (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("TotalDissolvedPhosphate_mg.L", "DP (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("SRP_mgperL", "SRP (mg L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("TEP_um2perL", "TEP (Âµm2 L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("CSP_um2perL", "CSP (Âµm2 L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("Density_mgperL_um2perL", "Density (mgL-1 Âµm2L-1)", Results_PPvsPP_sign.df$Var2)
Results_PPvsPP_sign.df$Var2 = gsub("ParticleArea_um2perL", "Particle area (um2 L-1)", Results_PPvsPP_sign.df$Var2)


#Reorder for easy interpretation
levelsVar1 = c(
  "CSP (Âµm2 L-1)",
  "TEP (Âµm2 L-1)",
  "Si (mg L-1)","SRP (mg L-1)",
  "DP (mg L-1)",
  "pH",
  "NO3- (mg L-1)",
  "NO2- (mg L-1)",
  "NH4+ (mg L-1)",
  "DTN (mg L-1)",
  "PTN (mg L-1)",
  "dO2 (ÂµM)",
  "dCH4 (nM)",
  "dCO2 (ÂµM)",
  "DIC (mg L-1)",
  "DOC (mg L-1)",
  "POC (mg L-1)",
  "PTC (mg L-1)",
  "Density (mgL-1 Âµm2L-1)",
  "Particle area (um2 L-1)",
  "Dry-weight (mg L-1)",
  "Turbidity (NTU)",
  "Temperature (Â°C)",
  "Salinity (PSU)",
  "Elbe km"
  )

# Assuming filtered_cov is your data frame
# Convert Var1 and Var2 to factors with the same levels
#levels <- unique(c(Results_PPvsPP_sign.df$Var1, Results_PPvsPP_sign.df$Var2))
Results_PPvsPP_sign.df <- Results_PPvsPP_sign.df %>%
  mutate(Var1 = factor(Var1, levels = levelsVar1),
         Var2 = factor(Var2, levels = levelsVar1))

# Filter the data to keep only the lower triangle
filtered_cov_lower <- Results_PPvsPP_sign.df %>%
  filter(as.numeric(Var1) <= as.numeric(Var2))

#Make rho value heatmap
Physico_rhovalue.plt = ggplot(Results_PPvsPP_sign.df, aes(x = Var1, y = Var2, fill = rho.value))+
  geom_tile()+
  geom_text(aes(label = ifelse(p.value > 0.05, "", 
                               ifelse(p.value > 0.01, "*", 
                                      ifelse(p.value > 0.001, "**", 
                                             ifelse(p.value <= 0.001, "***", ""))))),
            size = 20 / .pt,
            colour = "black")+
  scale_fill_gradient2("Pearson Correlation", low = "navy", mid = "white", high = "red", midpoint = 0)+ 
  scale_x_discrete(
    expand = expansion(mult = c(0,0)), guide = guide_axis(angle = 90),
    position = "top",
    limits = rev
  )+
  scale_y_discrete(
    expand = expansion(mult = c(0,0)),
    position = "right"
  )+
  xlab("Physicochemical parameters") + 
  ylab("Physicochemical parameters")+
  My_Theme
Physico_rhovalue.plt


pdf("E:/Functional_R_analysis/Figures/Physicochem_heatmap_pearson_mod.pdf", width = 14, height = 10)
Physico_rhovalue.plt 
dev.off()

#Cut off for very strong relationships is >0.8 according to Chan YH. Biostatistics 104: correlational analysis. Singapore Med J. 2003 Dec;44(12):614-9. PMID: 14770254.
#Subset to this
#Results_sign_VS.df = subset(Results_sign.df[,-5], rho.value > 0.8 | rho.value < -0.8)

#Extract dataframe to identify representative physicochemical paremeters
#write.csv(Results_PPvsPP_sign.df, "Figure2_Physicochem_MantelPearson.csv")
#Results_PPvsPP_sign.df = read.csv("Figure2_Physicochem_MantelPearson.csv")
```


###Identify significantly correlated parameters for later species, functional potential, and transcript per gene correlation analyses
```{r}
#Extract the individual physicochemical parameters that have to be used - for later 
Networked.ls = paste0(Results_sign_VS.df$Var1)

Networked_unique.ls = unique(Networked.ls)

#Extract the individual physicochemical parameters that have to be used
NonNetworked.ls = unique(paste0(Results.df$Var1))

NonNetworked_unique.ls = unique(NonNetworked.ls)


```
#Microbiome aspects in the ecosystem - Figure 3

##NMDS - split by fraction
###Facet split metagenomes
```{r}
####Metadata ####
metadata <- read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT


metadata2 <- read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)


#Add relevant rownames for making the phyloseq object
rownames(metadata) = metadata$sampleid
#Change names for consistency
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
#Reorder station km 
metadata$Station = factor(metadata$Station,
                          levels = c("Medemgrund",
                                     "Brunsbuettel",
                                     "Schwarztonnensand",
                                     "Twielenfleth",
                                     "Muehlenberger Loch",
                                     "Kollmar"))
#Reorder Dates
metadata$Sample_date = factor(metadata$Sample_date,
                          levels = c("May 21",
                                     "Jul 21",
                                     "Nov 21",
                                     "Feb 22",
                                     "May 22",
                                     "Jun 22",
                                     "Nov 22"))


#### gene abundance ####

geneabund_2 <- geneabund %>% 
  rownames_to_column("gene_cluster") # remove rownames and rename to gene_cluster

geneabund_KO <- annot %>% 
  rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  select(gene_cluster, KO) %>% # select only the columns titled gene_sluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values


geneabund_ko_otu_table <-
  geneabund_KO %>% 
  column_to_rownames("KO") %>% # remove rownames and rename to gene_cluster
  otu_table(., taxa_are_rows = TRUE) #make as a otu_table to generate a phyloseq object

gene_abund_ko_annots <- annot %>%
 rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  select(-"gene_cluster") %>% # remove the gene_cluster column
  distinct(., .keep_all = TRUE ) %>% # keep only unique KO id's
  rownames_to_column("gene_cluster") %>% # remove rownames and rename to gene_cluster
  select(KO, everything()) %>%  # reorders - so KO is in front
  column_to_rownames("KO") %>% # remove column named KO and make it the rowname
  as.matrix() %>% # convert to a matrix
  tax_table() # convert to a taxa table object for phyloseq object creation

####Combine into phyloseq object and run####


metadata$station_km = as.factor(metadata$station_km)

#Reorder station km 
metadata$Station = factor(metadata$Station,
                          levels = c("713",
                                     "692",
                                     "665",
                                     "651",
                                     "633"))

#Edit fraction for plot
metadata$Sample_type = gsub("Heavy_fraction", "PA", metadata$Sample_type)
metadata$Sample_type = gsub("Light_fraction", "PA", metadata$Sample_type)
metadata$Sample_type = gsub("Free_living", "FL", metadata$Sample_type)


#Make phyloseq object
genecat_ps <- phyloseq(geneabund_ko_otu_table, gene_abund_ko_annots, sample_data(metadata))

#Subset to samples we want
genecat_ps = subset_samples(genecat_ps, data_type=="METAG")


#Clean up samples for the relevant ones
#genecat_MG.ps = subset_samples(genecat_pgene_abund_ko_annotsgenecat_ps, station_km!="713" | Sample_date!="Jun 22")

genecat_MG.ps = subset_samples(genecat_MG.ps, Sample_date!="Nov 21")

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(genecat_MG.ps, method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.1199889

####Make plots ####

#Design plot
NMDS_Gene.plt = plot_ordination(genecat_MG.ps, 
                             Gene.ord, 
                             color = "Sample_date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  #stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = Sample_date), show.legend = F)+
  #geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  facet_grid(. ~ Sample_type)+
  annotate("text", x=-0.12, y=0.29, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("Functional potential NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene.plt

#png("Figures/DFG_Gene_METAG_NMDS.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

#pdf("Figures/NMDS_Gene_METAG.pdf", width = 11, height = 8)
#NMDS_Gene.plt
#dev.off()

#saveRDS(NMDS_Gene.plt, "Figures/DFG_Gene_METAG_NMDS.RDS")

```

###Recalculate each metagenome fraction - FL vs PA
```{r}

####Free-living ####

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(subset_samples(genecat_MG.ps, Sample_type == "FL"), method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.1199889

####Make plots ####

#Design plot
NMDS_Gene_FL.plt = plot_ordination(genecat_MG.ps, 
                             Gene.ord, 
                             color = "Sample_date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  #stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = Sample_date), show.legend = F)+
  #geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  facet_grid(. ~ Sample_type)+
  annotate("text", x=-0.22, y=0.3, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("Functional potential NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene_FL.plt



####Particle-associated ####

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(subset_samples(genecat_MG.ps, Sample_type == "PA"), method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.1199889

####Make plots ####

#Design plot
NMDS_Gene_PA.plt = plot_ordination(genecat_MG.ps, 
                             Gene.ord, 
                             color = "Sample_date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  #stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = Sample_date), show.legend = F)+
  #geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  facet_grid(. ~ Sample_type)+
  annotate("text", x=-0.22, y=0.3, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("Functional potential NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene_PA.plt
```

###Compare facetted vs re-calculated metagenomes

```{r}


ggarrange(NMDS_Gene.plt,
          NMDS_Gene_FL.plt, NMDS_Gene_PA.plt,
          common.legend = TRUE,
          legend = "right")


```

###Facet split metatranscriptome
```{r}

####Metadata####
metadata <- read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT


metadata2 <- read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)

#Add relevant rownames for making the phyloseq object
rownames(metadata) = metadata$sampleid
#Change names for consistency
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
#Reorder station km 
metadata$Station = factor(metadata$Station,
                          levels = c("Medemgrund",
                                     "Brunsbuettel",
                                     "Schwarztonnensand",
                                     "Twielenfleth",
                                     "Muehlenberger Loch",
                                     "Kollmar"))
#Reorder Dates
metadata$Sample_date = factor(metadata$Sample_date,
                          levels = c("May 21",
                                     "Jul 21",
                                     "Feb 22",
                                     "May 22",
                                     "Jun 22",
                                     "Nov 22"))


####OTU table ####


#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)



amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  #mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  #mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  #group_by(KO) %>% 
  #mutate(occurrence = sum(abundance)/nsamples) %>% 
  #ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  #filter(occurrence > 0.2) %>%
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "amoAClean_CO2CH4.csv")

#amoAClean_CO2CH4_tbl_long = read.csv( "amoAClean_CO2CH4.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)


#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes


#Convert from wide to long format
CO2CH4_TG.lng = gather(CO2CH4_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber)
dim(CO2CH4_TG.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, Associatednumber > 116)
dim(CO2CH4_TG.lng)
#Remove samples for which sequencing failed
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
dim(CO2CH4_TG.lng)

#Make sure data is set up properly
CO2CH4_TG.lng$counts = as.numeric(as.character(CO2CH4_TG.lng$counts))
CO2CH4_TG.lng$Associatednumber = as.character(CO2CH4_TG.lng$Associatednumber)


Complete_Metadata.df = read.csv("D:/Functional_R_analysis/SAMEAID_SampleID.csv", sep = ";", header = T)[,c(1,3)]
typeof(Complete_Metadata.df$Associatednumber)
typeof(CO2CH4_TG.lng$Associatednumber)

Complete_Metadata.df$Associatednumber = as.character(Complete_Metadata.df$Associatednumber)

typeof(Complete_Metadata.df$Associatednumber)
typeof(CO2CH4_TG.lng$Associatednumber)

amoAClean_CO2CH4_wide_MT_mod = CO2CH4_TG.lng %>%
  #select(-X) %>%
  left_join(Complete_Metadata.df, by = c("Associatednumber" = "Associatednumber")) %>%
  mutate_at(c('counts'), as.numeric) %>%
  distinct()
dim(amoAClean_CO2CH4_wide_MT_mod)
amoAClean_CO2CH4_wide_MT_mod$Associatednumber = NULL

amoAClean_CO2CH4_wide_MT_mod$AccessionNumber_TBDSven = paste0("GROS22.2_", amoAClean_CO2CH4_wide_MT_mod$AccessionNumber_TBDSven, "_METAT.genecount.profile")

#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MT_mod <- data.frame(spread(unique(amoAClean_CO2CH4_wide_MT_mod),
                       key = AccessionNumber_TBDSven, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MT_mod)
#View(amoAClean_CO2CH4_wide_MT_mod)




#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MT_mod) = amoAClean_CO2CH4_wide_MT_mod$KO
amoAClean_CO2CH4_wide_MT_mod$KO = NULL


####Combine and plot ####

#Ensure only relevant rows of metadata make it into the phyloseq object
metadata = subset(metadata, sampleid %in% colnames(amoAClean_CO2CH4_wide_MT_mod))

#Edit fraction for plot
metadata$Sample_type = gsub("Heavy_fraction", "PA", metadata$Sample_type)
metadata$Sample_type = gsub("Light_fraction", "PA", metadata$Sample_type)
metadata$Sample_type = gsub("Free_living", "FL", metadata$Sample_type)


metadata$station_km = factor(metadata$station_km,
                             levels = c(633,
                                        651, 
                                        665,
                                        692,
                                        713))

#To make sure dissimialrities work, we have to add 0's in place of NAs in the otu table
amoAClean_CO2CH4_wide_MT_mod[is.na(amoAClean_CO2CH4_wide_MT_mod)] <- 0


#Make phyloseq object
genecat_MT_ps <- phyloseq(otu_table(amoAClean_CO2CH4_wide_MT_mod, taxa_are_rows = T), gene_abund_ko_annots, sample_data(metadata))

#Clean up samples for the relevant ones
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="139")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="155")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="164")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="187")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="199")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="188")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="200")
genecat_MT_ps = subset_samples(genecat_MT_ps, 
                               Associatednumber!="198")

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(genecat_MT_ps, method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Decent stress plot - seems to have two distinct groups
Gene.ord #Good level of stress - 0.1346861 

#Design plot
NMDS_Gene_MT.plt = plot_ordination(genecat_MT_ps, 
                             Gene.ord, 
                             color = "Sample_date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  #stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = Sample_date), show.legend = F)+
  #geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  facet_grid(. ~ Sample_type)+
  annotate("text", x=-0.38, y=0.46, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("Transcrits per gene NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene_MT.plt




#png("F:/Functional_R_analysis/Figures/Gene_METAT_NMDS.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

pdf("D:/Functional_R_analysis/Figures/NMDS_METAT.pdf", width = 11, height = 8)
NMDS_Gene_MT.plt
dev.off()

#Pairwise PERMANOVA - Sample_date
Sample_date_group = get_variable(genecat_MT_ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, Sample_date_group, nperm = 999, p.method = "bonferroni")
Depth_ado
#May and June are not significantly different


####Anosim and adonis date tests####

#anosim
date_group = get_variable(genecat_MT_ps@sam_data, "Sample_date")
date_ano = anosim(phyloseq::distance(genecat_MT_ps, method = "bray"), date_group, distance = "bray")
date_ano$signif #0.002
date_ano$statistic #0.13314
#Significant differences between group means - based on date

#Adonis
date_group = get_variable(genecat_MT_ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
date_ado = adonis2(Gene.dist ~ date_group)
date_ado
#Significant differences between group means and distribution - based on date
#R2 = 0.09
#p = 0.006

#Pairwise PERMANOVA
date_group = get_variable(genecat_MT_ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
date.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, date_group, nperm = 999, p.method = "bonferroni")
date.stat
#May and June are not significantly different


####Anosim and adonis station_km tests####

#anosim
station_km_group = get_variable(genecat_MT_ps@sam_data, "station_km")
station_km_ano = anosim(phyloseq::distance(genecat_MT_ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.001
station_km_ano$statistic #0.34
#Significant differences between group means - based on station_km

#Adonis
station_km_group = get_variable(genecat_MT_ps@sam_data, "station_km")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#Significant differences between group means and distribution - based on station_km
#R2 = 0.41
#p = 0.001

#Pairwise PERMANOVA
station_km_group = get_variable(genecat_MT_ps@sam_data, "station_km")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat
#Most saline match each other (MG/ST/BB), while all samples match their preceding and following samples


####Anosim and adonis fraction tests####

#anosim
station_km_group = get_variable(genecat_MT_ps@sam_data, "Sample_type")
station_km_ano = anosim(phyloseq::distance(genecat_MT_ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.094
station_km_ano$statistic #0.039
#No significant differences between group means

#Adonis
station_km_group = get_variable(genecat_MT_ps@sam_data, "Sample_type")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#No significant differences between group means and distribution - based on fraction
#R2 = 0.05018
#p = 0.124

#Pairwise PERMANOVA
station_km_group = get_variable(genecat_MT_ps@sam_data, "Sample_type")
Gene.dist = phyloseq::distance(genecat_MT_ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat
#No significant fraction difference


```


###Recalculate each metatranscriptome fraction - FL vs PA
```{r}

####Free-living ####

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(subset_samples(genecat_MT_ps, Sample_type == "FL"), method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.08

####Make plots ####

#Design plot
NMDS_Gene_MT_FL.plt = plot_ordination(genecat_MT_ps, 
                             Gene.ord, 
                             color = "Sample_date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  #stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = Sample_date), show.legend = F)+
  #geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  facet_grid(. ~ Sample_type)+
  annotate("text", x=-0.22, y=0.3, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("Transcrits per gene NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene_MT_FL.plt



####Particle-associated ####

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(subset_samples(genecat_MT_ps, Sample_type == "PA"), method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.128

####Make plots ####

#Design plot
NMDS_Gene_MT_PA.plt = plot_ordination(genecat_MT_ps, 
                             Gene.ord, 
                             color = "Sample_date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  #stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = Sample_date), show.legend = F)+
  #geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  facet_grid(. ~ Sample_type)+
  annotate("text", x=-0.22, y=0.3, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("Transcrits per gene NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_Gene_MT_PA.plt
```

###Compare facetted vs re-calculated metatranscriptomes

```{r}


ggarrange(
          NMDS_Gene_MT_FL.plt, NMDS_Gene_MT_PA.plt,
          NMDS_Gene_MT.plt,
          common.legend = TRUE,
          legend = "right"
          )
```
###mOTUs
```{r}
####Set up ####
motus_final_taxa_metadata <- readRDS(file="D:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS")
metadata = Physicochem.df

##Lets check out experimental scheme
motus_final_taxa_metadata %>% 
  dplyr::select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, date) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##So when we consider fraction and date we see that Nov 21 has few samples, we should consider removing it

motus_final_taxa_metadata %>% 
  dplyr::select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, station) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##By station we see that Kollmar, SeemanshÃÂ¶ft and BunthausSpitze also were sampled infrequently, lets also remove these. 

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date))


#so to do a ternary plot we actually need to create a physeq object really quick 
motus_table <- motus_final_taxa_metadata %>%
  filter(data_type == "METAG") %>%
  dplyr::select(mOTU, sampleid, counts) %>%
  group_by(sampleid) %>% 
  mutate(total=sum(counts)) %>% 
  filter(total > 2400) %>%  ##Here we just remove those with low counts
  dplyr::select(-total) %>% 
  ungroup() %>% 
  pivot_wider(names_from = sampleid, values_from = counts, values_fill = 0) %>% 
  column_to_rownames("mOTU") %>% 
  phyloseq::otu_table(taxa_are_rows = TRUE)
motus_taxa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  dplyr::select(mOTU, phylum, class, order, family, genus, species) %>% 
  unique() %>% 
  column_to_rownames("mOTU") %>% 
  as.matrix() %>%
  phyloseq::tax_table()
motus_sampledata <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  dplyr::select(-phylum, -class, -order, -family, -genus, -species, -counts, -mOTU, -domain) %>% 
  unique() %>%  
  column_to_rownames("sampleid") %>% 
  sample_data()

motus_sampledata$date = gsub("i", "y", motus_sampledata$date)

#Edit fraction for plot
motus_sampledata$sample_type = gsub("Heavy_fraction", "PA", motus_sampledata$sample_type)
motus_sampledata$sample_type = gsub("Light_fraction", "PA", motus_sampledata$sample_type)
motus_sampledata$sample_type = gsub("Free_living", "FL", motus_sampledata$sample_type)

#Reorder station km 
motus_sampledata$station_km = factor(motus_sampledata$station_km,
                          levels = c("633",
                                     "651",
                                     "665",
                                     "692",
                                     "713"))


#Reorder Dates
motus_sampledata$date = factor(motus_sampledata$date,
                          levels = c("May 21",
                                     "Jul 21",
                                     "Nov 21",
                                     "Feb 22",
                                     "May 22",
                                     "Jun 22",
                                     "Nov 22"))


#Create phyloseq object
bicest_motu_ps <- phyloseq(motus_table, motus_taxa, motus_sampledata)
bicest_motu_ps


#Clean up samples for the relevant ones
#genecat_LH_ps = subset_samples(genecat_pgene_abund_ko_annotsgenecat_ps, Sample_type!="Free_living")
#genecat_LH.ps = subset_samples(genecat_LH_ps, station_km > 613 & Sample_date!="Nov 21" )
bicest_motu_ps = subset_samples(bicest_motu_ps, station_km!="713" | date!="Jun 22")
bicest_motu_ps = subset_samples(bicest_motu_ps, date!="Nov 21")

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(bicest_motu_ps, method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.148

####Make plots ####


#Design plot
NMDS_mOTU.plt = plot_ordination(bicest_motu_ps, 
                             Gene.ord, 
                             color = "date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  #stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = date), show.legend = F)+
  #geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  facet_grid(. ~ sample_type)+
  annotate("text", x=-0.79, y=0.9, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("mOTU abundance NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_mOTU.plt


#png("Figures/DFG_Gene_METAG_NMDS.png", width = 10, height = 7, units = "in", res = 120)
#NMDS_Gene.plt
#dev.off()

pdf("Figures/NMDS_mOTU.pdf", width = 11, height = 8)
NMDS_mOTU.plt
dev.off()

#saveRDS(NMDS_Gene.plt, "Figures/DFG_Gene_METAG_NMDS.RDS")

#Pairwise PERMANOVA - Sample_date
Sample_date_group = get_variable(bicest_motu_ps@sam_data, "date")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
Depth_ado = RVAideMemoire::pairwise.perm.manova(Gene.dist, Sample_date_group, nperm = 999, p.method = "bonferroni")
Depth_ado
# All are unique.



####Anosim, adonis, and permanova date tests####

#anosim
date_group = get_variable(bicest_motu_ps@sam_data, "date")
date_ano = anosim(phyloseq::distance(bicest_motu_ps, method = "bray"), date_group, distance = "bray")
date_ano$signif #0.001
date_ano$statistic #0.4927809
#Significant differences between group means - based on date

#Adonis
date_group = get_variable(bicest_motu_ps@sam_data, "Sample_date")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
date_ado = adonis2(Gene.dist ~ date_group)
date_ado
#Significant differences between group means and distribution - based on date
#R2 = 0.33742  
#p = 0.001

#Pairwise PERMANOVA
date_group = get_variable(bicest_motu_ps@sam_data, "date")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
date.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, date_group, nperm = 999, p.method = "bonferroni")
date.stat
#All are unique.


####Anosim and adonis station_km tests####

#anosim
station_km_group = get_variable(bicest_motu_ps@sam_data, "station")
station_km_ano = anosim(phyloseq::distance(bicest_motu_ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.001
station_km_ano$statistic #0.3334253
#Significant differences between group means - based on station_km

#Adonis
station_km_group = get_variable(bicest_motu_ps@sam_data, "station")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#Significant differences between group means and distribution - based on station_km
#R2 = 0.23603 
#p = 0.001

#Pairwise PERMANOVA
station_km_group = get_variable(bicest_motu_ps@sam_data, "station")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat
#Patterns exist in the station differences - all except last estuary stations are similar to previous and subsequent stations


####Anosim and adonis fraction tests####

#anosim
station_km_group = get_variable(bicest_motu_ps@sam_data, "sample_type")
station_km_ano = anosim(phyloseq::distance(bicest_motu_ps, method = "bray"), station_km_group, distance = "bray")
station_km_ano$signif #0.001
station_km_ano$statistic #-0.1790517
#Significant differences between group means

#Adonis
station_km_group = get_variable(bicest_motu_ps@sam_data, "sample_type")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
station_km_ado = adonis2(Gene.dist ~ station_km_group)
station_km_ado
#Significant differences between group means and distribution - based on fraction
#R2 = 0.10712  
#p = 0.001

#Pairwise PERMANOVA
station_km_group = get_variable(bicest_motu_ps@sam_data, "sample_type")
Gene.dist = phyloseq::distance(bicest_motu_ps, method = "bray")
station_km.stat = RVAideMemoire::pairwise.perm.manova(Gene.dist, station_km_group, nperm = 999, p.method = "bonferroni")
station_km.stat
#No significant particle fraction difference, FL is unique



```

###Recalculate each fraction - FL vs PA
```{r}

####Free-living ####

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(subset_samples(bicest_motu_ps, sample_type == "FL"), method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.08

####Make plots ####

#Design plot
NMDS_mOTU_FL.plt = plot_ordination(bicest_motu_ps, 
                             Gene.ord, 
                             color = "date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  #stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = date), show.legend = F)+
  #geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  facet_grid(. ~ sample_type)+
  annotate("text", x=-0.22, y=0.3, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("mOTU abundance NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_mOTU_FL.plt



####Particle-associated ####

#Calculate ordination matrix based on Bray-Curtis dissimilarity
Gene.ord <- ordinate(subset_samples(bicest_motu_ps, sample_type == "PA"), method = "NMDS", distance = "bray")
#Ensure data is good fit
stressplot(Gene.ord) #Good stress plot
Gene.ord #Good level of stress - 0.128

####Make plots ####

#Design plot
NMDS_mOTU_PA.plt = plot_ordination(bicest_motu_ps, 
                             Gene.ord, 
                             color = "date",
                             shape = "station_km"
                             ) + 
  theme(legend.position = "right")+
  #stat_ellipse(aes(group = Sample_date, color = Sample_date), lwd = 1)+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Station", values = Shape_list)+
  geom_point(aes(size = 2, color = date), show.legend = F)+
  #geom_text(aes(label = Sample_type), size = 3, vjust = 1.8)+
  facet_grid(. ~ sample_type)+
  annotate("text", x=-0.22, y=0.3, size = 6, label= paste0("Stress = ", round(Gene.ord$stress, digits = 3)))+
  theme_bw()+
  ggtitle("mOTU abundance NMDS")+
  My_Theme+
  guides(colour = guide_legend(order = 1),
         shape = guide_legend(order = 2, override.aes = list(size = 4)),
         size = "none",
         linewidth = "none")
#Inspect plot
#NMDS_Gene.plt$layers = NMDS_Gene.plt$layers[-1]
NMDS_mOTU_PA.plt
```

###Compare facetted vs re-calculated mOTUs

```{r}


ggarrange(
          NMDS_mOTU_FL.plt, NMDS_mOTU_PA.plt,
          NMDS_mOTU.plt,
          common.legend = TRUE,
          legend = "right"
          )
```

###Final NMDS

```{r}

pdf("D:/Functional_R_analysis/Figures/Figure3_NMDS_FLvsPA.pdf", width = 12, height = 12)

ggarrange(
  NMDS_mOTU.plt,
  NMDS_Gene.plt,
  NMDS_Gene_MT.plt,
  ncol = 1,
  nrow = 3,
  common.legend = TRUE,
  legend = "right")

dev.off()




png("D:/Functional_R_analysis/Figures/Figure3_NMDS_FLvsPA.png", units = "in", res = 80, width = 12, height = 12)

ggarrange(
  NMDS_mOTU.plt,
  NMDS_Gene.plt,
  NMDS_Gene_MT.plt,
  ncol = 1,
  nrow = 3,
  common.legend = TRUE,
  legend = "right")

dev.off()

```



##Physicochemical to KO
###Set up physicochemical characteristics
```{r}

#Read in new PP dataframe as a clean data frame
Physicochem.df = readxl::read_xlsx("D:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DOC_uM.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

colnames(PP_totest.df)
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% select(all_of(PP_totest.ls))

#Make sure rownames have been preserved
rownames(PP_totest.df)
dim(PP_totest.df)

#Extract water specific parameters
PP_water.df = PP_totest.df %>%
  subset(Sample_type == "Free_living") %>%
  select(-SPM_mgperL, -TEP_um2perL, -CSP_um2perL, -PTC_mgperL , -POC_mgperL, -PTN_mgperL, -Sample_type) %>%
  distinct()
#Extract particle specific parameters
PP_particle.df = PP_totest.df %>%
  subset(Sample_type!="Free_living") %>%
  select(Associatednumber, PTC_mgperL, POC_mgperL, PTN_mgperL, SPM_mgperL, TEP_um2perL, CSP_um2perL, -Sample_type) %>%
  distinct()

#remove NAs and convert columns to numeric
#PP_water.df = na.omit(PP_water.df)
PP_water.df = as.data.frame(sapply(PP_water.df, as.numeric))

#Apply row numbers from sample IDs
rownames(PP_water.df) = PP_water.df$Associatednumber
PP_water.df$Associatednumber = NULL
rownames(PP_particle.df) = PP_particle.df$Associatednumber
PP_particle.df$Associatednumber = NULL

#Flip so columns are samples for dissimilarity assessment
PP_water.df = t(PP_water.df)
PP_particle.df = t(PP_particle.df)

#Get sample names for microbiome comparison
Samples_water.ls = colnames(PP_water.df)
Samples_particle.ls = colnames(PP_particle.df)


```
###Prepare metabolic dataframes
####Metagenomes
```{r}

#Import gene list
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")
dim(distinct(CarbonGenelist.df))
#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

#Correct abundance
amoAClean_geneabund_KO[c(2:264)] = amoAClean_geneabund_KO[c(2:264)] / 1000


amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")

#amoAClean_CO2CH4_tbl_long = read.csv( "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)

#Subset to split metagenomes and metatranscriptomes and remove superflous columns
amoAClean_CO2CH4_tbl_long_MG = subset(amoAClean_CO2CH4_tbl_long, data_type == "Metagenomes") %>%
  select(counts, KO, Associatednumber)

dim(amoAClean_CO2CH4_tbl_long_MG)
amoAClean_CO2CH4_tbl_long_MG = unique(amoAClean_CO2CH4_tbl_long_MG)
dim(amoAClean_CO2CH4_tbl_long_MG)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MG <- data.frame(spread(amoAClean_CO2CH4_tbl_long_MG,
                       key = Associatednumber, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MG)
#View(amoAClean_CO2CH4_wide_MG)

#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MG) = amoAClean_CO2CH4_wide_MG$KO
amoAClean_CO2CH4_wide_MG$KO = NULL

#Remove x from column names
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))

#So I don't need to waste time rerunning this every time
write.csv(amoAClean_CO2CH4_wide_MG, "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv")
#amoAClean_CO2CH4_wide_MG = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)
```
####Metatranscriptomes
```{r}

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

#Correct abundance
amoAClean_geneabund_KO[c(2:264)] = amoAClean_geneabund_KO[c(2:264)] / 1000


amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)



#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)




#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG.df = CO2CH4_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG.lng = gather(CO2CH4_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber)
dim(CO2CH4_TG.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG.lng$counts = as.numeric(as.character(CO2CH4_TG.lng$counts))
CO2CH4_TG.lng$Associatednumber = as.character(CO2CH4_TG.lng$Associatednumber)

#Long to wide
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MT <- data.frame(spread(unique(CO2CH4_TG.lng),
                       key = Associatednumber, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MT)
#View(amoAClean_CO2CH4_wide_MT)

#Bug check
max(amoAClean_CO2CH4_wide_MT$X117) # should be ~673.5397

#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MT) = amoAClean_CO2CH4_wide_MT$KO
amoAClean_CO2CH4_wide_MT$KO = NULL


#So I don't need to waste time rerunning this every time
write.csv(amoAClean_CO2CH4_wide_MT, "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv")
#amoAClean_CO2CH4_wide_MT = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove x from column names
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))
```

###Match physicochemical and microbial samples and remove extras
```{r}
####Set up dataframes and dissimilarities####

#Extract genes from samples matching conditions
MG_water.df = amoAClean_CO2CH4_wide_MG[names(amoAClean_CO2CH4_wide_MG) %in% Samples_water.ls]
MG_particles.df = amoAClean_CO2CH4_wide_MG[names(amoAClean_CO2CH4_wide_MG) %in% Samples_particle.ls]
MT_water.df = amoAClean_CO2CH4_wide_MT[names(amoAClean_CO2CH4_wide_MT) %in% Samples_water.ls]
MT_particles.df = amoAClean_CO2CH4_wide_MT[names(amoAClean_CO2CH4_wide_MT) %in% Samples_particle.ls]
#Check to make sure it worked
dim(MG_water.df)
dim(MG_particles.df)
dim(MT_water.df)
dim(MT_particles.df)


#Extract only microbial matched samples of Physicochemicals for dissimilarity otherwise mantel doesn't work
PP_water_MG.df = subset(PP_water.df, select = colnames(MG_water.df))
PP_particles_MG.df = subset(PP_particle.df, select = colnames(MG_particles.df))
PP_water_MT.df = subset(PP_water.df, select = colnames(MT_water.df))
PP_particles_MT.df = subset(PP_particle.df, select = colnames(MT_particles.df))

dim(PP_water_MG.df)
dim(PP_particles_MG.df)
dim(PP_water_MT.df)
dim(PP_particles_MT.df)

#Set seed for reproduceability
set.seed(2)

#Run dissimilarity comparison between samples
##Microbial
MG_water.diss = vegan::vegdist(t(MG_water.df), method = "bray")
MG_particles.diss = vegan::vegdist(t(MG_particles.df), method = "bray")
MT_water.diss = vegan::vegdist(t(MT_water.df), method = "bray")
MT_particles.diss = vegan::vegdist(t(MT_particles.df), method = "bray")
#Pysicochemical
PP_water_MG.diss = vegan::vegdist(t(PP_water_MG.df), method = "bray", na.rm = T)
PP_particles_MG.diss = vegan::vegdist(t(PP_particles_MG.df), method = "bray", na.rm = T)
PP_water_MT.diss = vegan::vegdist(t(PP_water_MT.df), method = "bray", na.rm = T)
PP_particles_MT.diss = vegan::vegdist(t(PP_particles_MT.df), method = "bray", na.rm = T)




####Mantel tests general ####

#Whole microbial vs whole physicochemical
mantel(MG_water.diss, PP_water_MG.diss) #p = 0.004, R=0.2411
mantel(MG_particles.diss, PP_particles_MG.diss) #p = 0.001, R=0.1607
mantel(MT_water.diss, PP_water_MT.diss) #p = 0.061, R=0.1937
mantel(MT_particles.diss, PP_particles_MT.diss) #p = 0.018, R=0.1945



#Run loop for individual genes vs individual physicochemical parameters
#####MG water ####
Results_MG_water.df = data.frame("Gene_KO" = "DELETEME",
                     "PhysicochemicalParameter" = "DELETEME",
                     "pvalue" = 99999,
                     "Mantel_Rvalue" = 99999)
i=1
x=7
for (i in 1:length(rownames(MG_water.df))) {
  for (x in 1:length(rownames(PP_water_MG.df))) {
    
    #Extracting names
    M.name = rownames(MG_water.df[i,])
    PP.name = rownames(as.data.frame(PP_water_MG.df)[x,])
    
    #Make dissimilarity matrices
    M.tmp = vegdist(t(MG_water.df[i,]), method = "euclidean")
    PP.tmp = vegdist(PP_water_MG.df[x,], method = "euclidean", na.rm = T)
    
    #Run mantel test
    test.tmp = mantel(M.tmp, PP.tmp, na.rm = T)
    
    #Make df for results
    Results.tmp = data.frame("Gene_KO" = M.name,
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_water.df = rbind(Results_MG_water.df, Results.tmp)
    
    
  }
  
  print(paste0("Completed ", i, " out of ", length(rownames(MG_water.df)), " genes, which is ", round((i/length(rownames(MG_water.df)))*100, digits = 2), "%"))
  
}

#Check results and clean up dataframe
Results_MG_water.df = Results_MG_water.df[-1,]
Results_MG_water.df

#Check if each PP was included
unique(Results_MG_water.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_water.df = subset(Results_MG_water.df, pvalue < 0.05)
dim(Results_MG_water.df)

#Check if each PP was included
unique(Results_MG_water.df$PhysicochemicalParameter)

Top25_Fraction_MG_water.df = Results_MG_water.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.75))
dim(Top25_Fraction_MG_water.df)

length(unique(Top25_Fraction_MG_water.df$Gene_KO))
unique(Top25_Fraction_MG_water.df$PhysicochemicalParameter)


#####MG particles ####
Results_MG_particles.df = data.frame("Gene_KO" = "DELETEME",
                     "PhysicochemicalParameter" = "DELETEME",
                     "pvalue" = 99999,
                     "Mantel_Rvalue" = 99999)
i=1
x=1
for (i in 1:length(rownames(MG_particles.df))) {
  for (x in 1:length(rownames(PP_particles_MG.df))) {
    
    #Extracting names
    M.name = rownames(MG_particles.df[i,])
    PP.name = rownames(as.data.frame(PP_particles_MG.df)[x,])
    
    #Make dissimilarity matrices
    M.tmp = vegdist(t(MG_particles.df[i,]), method = "euclidean")
    PP.tmp = vegdist(PP_particles_MG.df[x,], method = "euclidean", na.rm = T)
    
    #Run mantel test
    test.tmp = mantel(M.tmp, PP.tmp, na.rm = T)
    
    #Make df for results
    Results.tmp = data.frame("Gene_KO" = M.name,
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_particles.df = rbind(Results_MG_particles.df, Results.tmp)
    
    
  }
  
  print(paste0("Completed ", i, " out of ", length(rownames(MG_particles.df)), " genes, which is ", round((i/length(rownames(MG_particles.df)))*100, digits = 2), "%"))
  
}

#Check results and clean up dataframe
Results_MG_particles.df = Results_MG_particles.df[-1,]
Results_MG_particles.df

#Check if each PP was included
unique(Results_MG_particles.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_particles.df = subset(Results_MG_particles.df, pvalue < 0.05)
dim(Results_MG_particles.df)

Top25_Fraction_MG_particles.df = Results_MG_particles.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.75))
dim(Top25_Fraction_MG_particles.df)

length(unique(Top25_Fraction_MG_particles.df$Gene_KO))
unique(Top25_Fraction_MG_particles.df$PhysicochemicalParameter)



#####MT water ####
Results_MT_water.df = data.frame("Gene_KO" = "DELETEME",
                     "PhysicochemicalParameter" = "DELETEME",
                     "pvalue" = 99999,
                     "Mantel_Rvalue" = 99999)
i=1
x=7
for (i in 1:length(rownames(MT_water.df))) {
  for (x in 1:length(rownames(PP_water_MT.df))) {
    
    #Extracting names
    M.name = rownames(MT_water.df[i,])
    PP.name = rownames(as.data.frame(PP_water_MT.df)[x,])
    
    #Make dissimilarity matrices
    M.tmp = vegdist(t(MT_water.df[i,]), method = "euclidean")
    PP.tmp = vegdist(PP_water_MT.df[x,], method = "euclidean", na.rm = T)
    
    #Run mantel test
    test.tmp = mantel(M.tmp, PP.tmp, na.rm = T)
    
    #Make df for results
    Results.tmp = data.frame("Gene_KO" = M.name,
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_water.df = rbind(Results_MT_water.df, Results.tmp)
    
    
  }
  
  print(paste0("Completed ", i, " out of ", length(rownames(MT_water.df)), " genes, which is ", round((i/length(rownames(MT_water.df)))*100, digits = 2), "%"))
  
}

#Check results and clean up dataframe
Results_MT_water.df = Results_MT_water.df[-1,]
Results_MT_water.df

#Check if each PP was included
unique(Results_MT_water.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_water.df = subset(Results_MT_water.df, pvalue < 0.05)
dim(Results_MT_water.df)

Top25_Fraction_MT_water.df = Results_MT_water.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.75))
dim(Top25_Fraction_MT_water.df)

length(unique(Top25_Fraction_MT_water.df$Gene_KO))
unique(Top25_Fraction_MT_water.df$PhysicochemicalParameter)


#####MT particles ####
Results_MT_particles.df = data.frame("Gene_KO" = "DELETEME",
                     "PhysicochemicalParameter" = "DELETEME",
                     "pvalue" = 99999,
                     "Mantel_Rvalue" = 99999)
i=1
x=1
for (i in 1:length(rownames(MT_particles.df))) {
  for (x in 1:length(rownames(PP_particles_MT.df))) {
    
    #Extracting names
    M.name = rownames(MT_particles.df[i,])
    PP.name = rownames(as.data.frame(PP_particles_MT.df)[x,])
    
    #Make dissimilarity matrices
    M.tmp = vegdist(t(MT_particles.df[i,]), method = "euclidean")
    PP.tmp = vegdist(PP_particles_MT.df[x,], method = "euclidean", na.rm = T)
    
    #Run mantel test
    test.tmp = mantel(M.tmp, PP.tmp, na.rm = T)
    
    #Make df for results
    Results.tmp = data.frame("Gene_KO" = M.name,
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_particles.df = rbind(Results_MT_particles.df, Results.tmp)
    
    
  }
  
  print(paste0("Completed ", i, " out of ", length(rownames(MT_particles.df)), " genes, which is ", round((i/length(rownames(MT_particles.df)))*100, digits = 2), "%"))
  
}

#Check results and clean up dataframe
Results_MT_particles.df = Results_MT_particles.df[-1,]
Results_MT_particles.df

#Check if each PP was included
unique(Results_MT_particles.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_particles.df = subset(Results_MT_particles.df, pvalue < 0.05)
dim(Results_MT_particles.df)

Top25_Fraction_MT_particles.df = Results_MT_particles.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.75))
dim(Top25_Fraction_MT_particles.df)

length(unique(Top25_Fraction_MT_particles.df$Gene_KO))
unique(Top25_Fraction_MT_particles.df$PhysicochemicalParameter)


#### Combine all results ####

Results_MG_water.df$data_type = "Metagenomes"
Results_MG_particles.df$data_type = "Metagenomes"
Results_MT_water.df$data_type = "Metatranscriptomes"
Results_MT_particles.df$data_type = "Metatranscriptomes"

Results_MG_water.df$environment = "Water"
Results_MG_particles.df$environment = "Particles"
Results_MT_water.df$environment = "Water"
Results_MT_particles.df$environment = "Particles"



Results.df = rbind(Results_MG_water.df, Results_MG_particles.df,
                   Results_MT_water.df, Results_MT_particles.df)

write.csv(Results.df, "F:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv")


####Analyse ####

Results.df = read.csv("E:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

Results.df = subset(Results.df, PhysicochemicalParameter!="station_km")
dim(Results.df)

Results_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water")
dim(Results_MG_water.df)
Results_MG_particles.df = subset(Results.df, data_type == "Metagenomes" & environment == "Particles")
dim(Results_MG_particles.df)
Results_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water")
dim(Results_MT_water.df)
Results_MT_particles.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Particles")
dim(Results_MT_particles.df)

ggplot(Results_MG_water.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-1)
dim(Results_MG_water.df)
 
MeanPP.df = Results_MG_water.df %>%
  group_by(PhysicochemicalParameter) %>%
  dplyr::summarise(mean_val = mean(Mantel_Rvalue), sd_val = sd(Mantel_Rvalue))%>% 
  arrange(mean_val, decreasing = T)
 MeanPP.df = data.table::setorder(MeanPP.df, cols = mean_val)
MeanPP.df

ggplot(Results_MG_particles.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-1)

MeanPP.df = Results_MG_particles.df %>%
  group_by(PhysicochemicalParameter) %>%
  dplyr::summarise(mean_val = mean(Mantel_Rvalue), sd_val = sd(Mantel_Rvalue))%>% 
  arrange(mean_val, decreasing = T)
MeanPP.df = data.table::setorder(MeanPP.df, cols = mean_val)
MeanPP.df

ggplot(Results_MT_water.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-1)

MeanPP.df = Results_MT_water.df %>%
  group_by(PhysicochemicalParameter) %>%
  dplyr::summarise(mean_val = mean(Mantel_Rvalue), sd_val = sd(Mantel_Rvalue))%>% 
  arrange(mean_val, decreasing = T)
MeanPP.df = data.table::setorder(MeanPP.df, cols = mean_val)
MeanPP.df

ggplot(Results_MT_particles.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-1)

MeanPP.df = Results_MT_particles.df %>%
  group_by(PhysicochemicalParameter) %>%
  dplyr::summarise(mean_val = mean(Mantel_Rvalue), sd_val = sd(Mantel_Rvalue))%>% 
  arrange(mean_val, decreasing = T)
MeanPP.df = data.table::setorder(MeanPP.df, cols = mean_val)
MeanPP.df



#Water PP
Results_water.df = subset(Results.df, environment == "Water")

ggplot(Results_water.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=..count..), vjust=-1)

#Particle PP
Results_particle.df = subset(Results.df, environment == "Particles")
dim(Results_particle.df)
ggplot(Results_particle.df, aes(x = PhysicochemicalParameter)) + 
  geom_bar() +
  geom_text(stat='count', aes(label=..count..), vjust=-1)


##### Individual KOs####
#Extract top 5 taxa in each environment
Top5_MG_water.df = Results_MG_water.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.99))
Top5_MG_water.df # Need Salinity
Top5_MG_particles.df = Results_MG_particles.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.983))
Top5_MG_particles.df # Need SPM and PTC
Top5_MT_water.df = Results_MT_water.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.998))
Top5_MT_water.df
Top5_MT_particles.df = Results_MT_particles.df %>% filter(Mantel_Rvalue > quantile(Mantel_Rvalue, 0.975))
Top5_MT_particles.df

dim(Results_MG_water.df)
dim(Results_MG_particles.df)
dim(Results_MT_water.df)
dim(Results_MT_particles.df)

#Make a list for extraction from phyloseq object and downstream plots
Top5_water.ls = Top5_Fraction_mOTUs_water.df$Gene_KO
Top5_particles.ls = Top5_Fraction_mOTUs_particles.df$Gene_KO

#Extract only top 5 taxa
Top5_water.df = subset(taxa.df, taxapath %in% Top5_water.ls)
Top5_particles.df = subset(taxa.df, taxapath %in% Top5_particles.ls)


#Remove non-environment samples for water and particles
Top5_water.df = subset(Top5_water.df, Associatednumber %in% colnames(Microbiome_water.df))
Top5_particles.df = subset(Top5_particles.df, Associatednumber %in% colnames(Microbiome_particles.df))
                                    

# Make water plots
salinity.plt = ggplot(Top5_water.df, 
                      aes(x = salinity, 
                          y = Abundance*100, 
                          colour = taxapath))+
  geom_point()+
  geom_smooth()+
  My_Theme
salinity.plt

#Make particle plots
CSP.plt = ggplot(subset(Top5_particles.df, taxapath!= "PseudomonadotaGammaproteobacteriaXanthomonadalesSZUA-36JABDPF01__"), 
                 aes(x = as.numeric(CSP_um2perL), 
                     y = Abundance*100, 
                     colour = taxapath))+
  geom_point()+
  geom_smooth()+
  My_Theme
CSP.plt
SPM.plt = ggplot(subset(Top5_particles.df, taxapath == "PseudomonadotaGammaproteobacteriaXanthomonadalesSZUA-36JABDPF01__"), 
                 aes(x = as.numeric(spm_mg_l), 
                     y = Abundance*100, 
                     colour = taxapath))+
  geom_point()+
  geom_smooth()+
  My_Theme
SPM.plt

ggpubr::ggarrange(salinity.plt,
          CSP.plt, SPM.plt)

pdf("Figures/PP_mOTUs.pdf", width = 36, height = 12)
ggpubr::ggarrange(salinity.plt,
          CSP.plt, SPM.plt)
dev.off()
 

####Shared KOs for dCO2 and dCH4 between MG and MT####


Results.df = read.csv("E:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

Results.df = subset(Results.df, PhysicochemicalParameter!="station_km")
dim(Results.df)

#dCO2
dCO2_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water" & PhysicochemicalParameter == "dCO2_uM")
dCO2_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water" & PhysicochemicalParameter == "dCO2_uM")
#dCH4
dCH4_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water" & PhysicochemicalParameter == "dCH4_nM")
dCH4_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water" & PhysicochemicalParameter == "dCH4_nM")
                          

MG_MT_dCO2.df = subset(dCO2_MG_water.df, Gene_KO %in% dCO2_MT_water.df$Gene_KO)
MG_MT_dCH4.df = subset(dCH4_MG_water.df, Gene_KO %in% dCH4_MT_water.df$Gene_KO)




```
```{r Salinity and O2 KOs compared}
#Water PP
Results_water.df = subset(Results.df, environment == "Water")

KOs_Sal.ls = subset(Results_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_O2.ls = subset(Results_water.df, PhysicochemicalParameter == "O2_uM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_O2.ls = sort(unique(KOs_O2.ls$Gene_KO))

match(KOs_Sal.ls, KOs_O2.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_O2.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)


```
```{r Salinity and dCO2 KOs compared}

Results.df = read.csv("E:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

Results_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water")
Results_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water")

####Combined ####
#Water PP
Results_water.df = subset(Results.df, environment == "Water")

KOs_Sal.ls = subset(Results_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCO2.ls = subset(Results_water.df, PhysicochemicalParameter == "dCO2_uM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCO2.ls = sort(unique(KOs_dCO2.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCO2.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCO2.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)#

test = subset(Results.df, Gene_KO %in% common_elements & PhysicochemicalParameter == "Salinity_PSU" | Gene_KO %in% common_elements & PhysicochemicalParameter == "dCO2_uM")

test2 = spread(test[,-3], key = PhysicochemicalParameter, value = Mantel_Rvalue)

test2$CombinedMantelR = test2$dCO2_uM + test2$Salinity_PSU

#### Functional ####
#Water PP

KOs_Sal.ls = subset(Results_MG_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCO2.ls = subset(Results_MG_water.df, PhysicochemicalParameter == "dCO2_uM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCO2.ls = sort(unique(KOs_dCO2.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCO2.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCO2.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

#### Transcripts ####
#Water PP

KOs_Sal.ls = subset(Results_MT_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCO2.ls = subset(Results_MT_water.df, PhysicochemicalParameter == "dCO2_uM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCO2.ls = sort(unique(KOs_dCO2.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCO2.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCO2.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

```
```{r Salinity and dCH4 KOs compared}
Results.df = read.csv("E:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

Results_MG_water.df = subset(Results.df, data_type == "Metagenomes" & environment == "Water")
Results_MT_water.df = subset(Results.df, data_type == "Metatranscriptomes" & environment == "Water")

####Combined####

#Water PP
Results_water.df = subset(Results.df, environment == "Water")

KOs_Sal.ls = subset(Results_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCH4.ls = subset(Results_water.df, PhysicochemicalParameter == "dCH4_nM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCH4.ls = sort(unique(KOs_dCH4.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCH4.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCH4.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

test = subset(Results.df, Gene_KO %in% common_elements & PhysicochemicalParameter == "Salinity_PSU" | Gene_KO %in% common_elements & PhysicochemicalParameter == "dCH4_nM")

test2 = spread(test[,-3], key = PhysicochemicalParameter, value = Mantel_Rvalue)

test2$CombinedMantelR = test2$dCO2_uM + test2$Salinity_PSU

####Functional####

#Water PP

KOs_Sal.ls = subset(Results_MG_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCH4.ls = subset(Results_MG_water.df, PhysicochemicalParameter == "dCH4_nM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCH4.ls = sort(unique(KOs_dCH4.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCH4.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCH4.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

####Transcripts####

#Water PP

KOs_Sal.ls = subset(Results_MT_water.df, PhysicochemicalParameter == "Salinity_PSU")
KOs_dCH4.ls = subset(Results_MT_water.df, PhysicochemicalParameter == "dCH4_nM")

KOs_Sal.ls = sort(unique(KOs_Sal.ls$Gene_KO))
KOs_dCH4.ls = sort(unique(KOs_dCH4.ls$Gene_KO))

match(KOs_Sal.ls, KOs_dCH4.ls)

# Find the common elements
common_elements <- intersect(KOs_Sal.ls, KOs_dCH4.ls)

# Percentage of matches
num_matches <- length(common_elements) / length(KOs_Sal.ls)
num_matches

```
###Match to MAGs of origin


```{r CSP MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
CSP_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter == "CSP_um2perL")[,1])
#CSP_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_CSP = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CSP_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_CSP)
#View(amoAClean_geneabund_KO_CSP)

amoAClean_CO2CH4_tbl_long_CSP <- amoAClean_geneabund_KO_CSP %>%
  filter(KO %in% CSP_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_CSP$counts = amoAClean_CO2CH4_tbl_long_CSP$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_CSP$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_CSP$domain)
amoAClean_CO2CH4_tbl_long_CSP$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_CSP$phylum)
amoAClean_CO2CH4_tbl_long_CSP$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_CSP$class)
amoAClean_CO2CH4_tbl_long_CSP$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_CSP$order)
amoAClean_CO2CH4_tbl_long_CSP$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_CSP$family)
amoAClean_CO2CH4_tbl_long_CSP$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_CSP$genus)
amoAClean_CO2CH4_tbl_long_CSP$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_CSP$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_CSP$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_CSP$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$class, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$order, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$family, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_CSP$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_CSP$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_CSP$genome)

CSP_taxa_MG.df = amoAClean_CO2CH4_tbl_long_CSP %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(CSP_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CSP_MG.csv")

#CSP_taxa_MG.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CSP_MG.csv")

#Clean up for plot
CSP_taxa_MG.df$station_km = as.numeric(as.character(CSP_taxa_MG.df$station_km))


CSP_taxa_MG.df$Sample_date = factor(CSP_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

CSP_taxa_MG.sum = Rmisc::summarySE(CSP_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/CSP_MAGCorr_MG.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(CSP_taxa_MG.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
#  scale_color_manual(values = expanded_cbbPalette)+
 # scale_y_log10()+
  #My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(CSP_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = sort(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")))

test[order(-test$N), ]

unique(CSP_taxa_MG.df$fulltaxa)





#### Metatranscriptomes ####



#Extract relevant genes
CSP_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter == "CSP_um2perL")[,1])
#CSP_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_CSP = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CSP_genes_MT.ls) %>% # only extract the CO2CH4 gene
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_CSP)
#View(amoAClean_geneabund_KO_CSP)

amoAClean_CO2CH4_tbl_long_CSP <- amoAClean_geneabund_KO_CSP %>%
  filter(KO %in% CSP_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_CSP$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_CSP$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_CSP$data_type)
amoAClean_CO2CH4_tbl_long_CSP$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_CSP$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_CSP.df <- spread(amoAClean_CO2CH4_tbl_long_CSP[ , ! names(amoAClean_CO2CH4_tbl_long_CSP) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_CSP)
dim(CO2CH4_TG_CSP.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_CSP.df$TranscriptsPerGenome = CO2CH4_TG_CSP.df$Transcriptomes / CO2CH4_TG_CSP.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_CSP.df = CO2CH4_TG_CSP.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_CSP.lng = gather(CO2CH4_TG_CSP.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_CSP.lng = subset(CO2CH4_TG_CSP.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_CSP.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_CSP.lng = subset(CO2CH4_TG_CSP.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_CSP.lng = subset(CO2CH4_TG_CSP.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_CSP.lng$counts = as.numeric(as.character(CO2CH4_TG_CSP.lng$counts))
CO2CH4_TG_CSP.lng$Associatednumber = as.character(CO2CH4_TG_CSP.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_CSP.lng$counts = CO2CH4_TG_CSP.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_CSP.lng$domain = gsub("d__", "", CO2CH4_TG_CSP.lng$domain)
CO2CH4_TG_CSP.lng$phylum = gsub("p__", "", CO2CH4_TG_CSP.lng$phylum)
CO2CH4_TG_CSP.lng$class = gsub("c__", "", CO2CH4_TG_CSP.lng$class)
CO2CH4_TG_CSP.lng$order = gsub("o__", "", CO2CH4_TG_CSP.lng$order)
CO2CH4_TG_CSP.lng$family = gsub("f__", "", CO2CH4_TG_CSP.lng$family)
CO2CH4_TG_CSP.lng$genus = gsub("g__", "", CO2CH4_TG_CSP.lng$genus)
CO2CH4_TG_CSP.lng$species = gsub("s__", "", CO2CH4_TG_CSP.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_CSP.lng$fulltaxa = paste0(CO2CH4_TG_CSP.lng$domain, "__",
                                                CO2CH4_TG_CSP.lng$phylum, "__",
                                                CO2CH4_TG_CSP.lng$class, "__",
                                                CO2CH4_TG_CSP.lng$order, "__",
                                                CO2CH4_TG_CSP.lng$family, "__",
                                                CO2CH4_TG_CSP.lng$genus, "__",
                                                CO2CH4_TG_CSP.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_CSP.lng$fulltaxa)
unique(CO2CH4_TG_CSP.lng$genome)

CSP_taxa_MT.df = CO2CH4_TG_CSP.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(CSP_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CSP_TG.csv")

#CSP_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_CSP_TG.csv")

#Clean up for plot
CSP_taxa_MT.df$station_km = as.numeric(as.character(CSP_taxa_MT.df$station_km))


CSP_taxa_MT.df$Sample_date = factor(CSP_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

CSP_taxa_MT.sum = Rmisc::summarySE(CSP_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/CSP_MAGCorr_MT.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(CSP_taxa_MT.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  scale_y_log10()+
 # My_Theme 

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(CSP_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]


unique(CSP_taxa_MT.sum$fulltaxa)


```
```{r PTN MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
PTN_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter == "PTN_mgperL")[,1])
#PTN_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_PTN = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% PTN_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_PTN)
#View(amoAClean_geneabund_KO_PTN)

amoAClean_CO2CH4_tbl_long_PTN <- amoAClean_geneabund_KO_PTN %>%
  filter(KO %in% PTN_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_PTN$counts = amoAClean_CO2CH4_tbl_long_PTN$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_PTN$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_PTN$domain)
amoAClean_CO2CH4_tbl_long_PTN$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_PTN$phylum)
amoAClean_CO2CH4_tbl_long_PTN$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_PTN$class)
amoAClean_CO2CH4_tbl_long_PTN$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_PTN$order)
amoAClean_CO2CH4_tbl_long_PTN$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_PTN$family)
amoAClean_CO2CH4_tbl_long_PTN$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_PTN$genus)
amoAClean_CO2CH4_tbl_long_PTN$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_PTN$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_PTN$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_PTN$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$class, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$order, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$family, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_PTN$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_PTN$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_PTN$genome)

PTN_taxa_MG.df = amoAClean_CO2CH4_tbl_long_PTN %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(PTN_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_PTN_MG.csv")

#PTN_taxa_MG.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_PTN_MG.csv")

#Clean up for plot
PTN_taxa_MG.df$station_km = as.numeric(as.character(PTN_taxa_MG.df$station_km))


PTN_taxa_MG.df$Sample_date = factor(PTN_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

PTN_taxa_MG.sum = Rmisc::summarySE(PTN_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/PTN_MAGCorr_MG.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(PTN_taxa_MG.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
#  scale_color_manual(values = expanded_cbbPalette)+
 # scale_y_log10()+
  #My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(PTN_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = sort(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")))

test[order(-test$N), ]

unique(PTN_taxa_MG.df$fulltaxa)





#### Metatranscriptomes ####



#Extract relevant genes
PTN_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter == "PTN_mgperL")[,1])
#PTN_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_PTN = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% PTN_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_PTN)
#View(amoAClean_geneabund_KO_PTN)

amoAClean_CO2CH4_tbl_long_PTN <- amoAClean_geneabund_KO_PTN %>%
  filter(KO %in% PTN_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_PTN$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_PTN$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_PTN$data_type)
amoAClean_CO2CH4_tbl_long_PTN$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_PTN$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_PTN.df <- spread(amoAClean_CO2CH4_tbl_long_PTN[ , ! names(amoAClean_CO2CH4_tbl_long_PTN) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_PTN)
dim(CO2CH4_TG_PTN.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_PTN.df$TranscriptsPerGenome = CO2CH4_TG_PTN.df$Transcriptomes / CO2CH4_TG_PTN.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_PTN.df = CO2CH4_TG_PTN.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_PTN.lng = gather(CO2CH4_TG_PTN.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_PTN.lng = subset(CO2CH4_TG_PTN.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_PTN.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_PTN.lng = subset(CO2CH4_TG_PTN.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_PTN.lng = subset(CO2CH4_TG_PTN.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_PTN.lng$counts = as.numeric(as.character(CO2CH4_TG_PTN.lng$counts))
CO2CH4_TG_PTN.lng$Associatednumber = as.character(CO2CH4_TG_PTN.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_PTN.lng$counts = CO2CH4_TG_PTN.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_PTN.lng$domain = gsub("d__", "", CO2CH4_TG_PTN.lng$domain)
CO2CH4_TG_PTN.lng$phylum = gsub("p__", "", CO2CH4_TG_PTN.lng$phylum)
CO2CH4_TG_PTN.lng$class = gsub("c__", "", CO2CH4_TG_PTN.lng$class)
CO2CH4_TG_PTN.lng$order = gsub("o__", "", CO2CH4_TG_PTN.lng$order)
CO2CH4_TG_PTN.lng$family = gsub("f__", "", CO2CH4_TG_PTN.lng$family)
CO2CH4_TG_PTN.lng$genus = gsub("g__", "", CO2CH4_TG_PTN.lng$genus)
CO2CH4_TG_PTN.lng$species = gsub("s__", "", CO2CH4_TG_PTN.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_PTN.lng$fulltaxa = paste0(CO2CH4_TG_PTN.lng$domain, "__",
                                                CO2CH4_TG_PTN.lng$phylum, "__",
                                                CO2CH4_TG_PTN.lng$class, "__",
                                                CO2CH4_TG_PTN.lng$order, "__",
                                                CO2CH4_TG_PTN.lng$family, "__",
                                                CO2CH4_TG_PTN.lng$genus, "__",
                                                CO2CH4_TG_PTN.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_PTN.lng$fulltaxa)
unique(CO2CH4_TG_PTN.lng$genome)

PTN_taxa_MT.df = CO2CH4_TG_PTN.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(PTN_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_PTN_TG.csv")

#PTN_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_PTN_TG.csv")

#Clean up for plot
PTN_taxa_MT.df$station_km = as.numeric(as.character(PTN_taxa_MT.df$station_km))


PTN_taxa_MT.df$Sample_date = factor(PTN_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

PTN_taxa_MT.sum = Rmisc::summarySE(PTN_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/PTN_MAGCorr_MT.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(PTN_taxa_MT.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  scale_y_log10()+
 # My_Theme 

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(PTN_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]


#test = subset(PTN_taxa_MT.sum, KO == "K00281")

unique(PTN_taxa_MT.sum$fulltaxa)


```
```{r POC MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
POC_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter == "POC_mgperL")[,1])
#POC_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_POC = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% POC_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_POC)
#View(amoAClean_geneabund_KO_POC)

amoAClean_CO2CH4_tbl_long_POC <- amoAClean_geneabund_KO_POC %>%
  filter(KO %in% POC_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_POC$counts = amoAClean_CO2CH4_tbl_long_POC$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_POC$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_POC$domain)
amoAClean_CO2CH4_tbl_long_POC$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_POC$phylum)
amoAClean_CO2CH4_tbl_long_POC$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_POC$class)
amoAClean_CO2CH4_tbl_long_POC$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_POC$order)
amoAClean_CO2CH4_tbl_long_POC$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_POC$family)
amoAClean_CO2CH4_tbl_long_POC$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_POC$genus)
amoAClean_CO2CH4_tbl_long_POC$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_POC$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_POC$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_POC$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$class, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$order, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$family, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_POC$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_POC$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_POC$genome)

POC_taxa_MG.df = amoAClean_CO2CH4_tbl_long_POC %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(POC_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_POC_MG.csv")

#POC_taxa_MG.df = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_POC_MG.csv")

#Clean up for plot
POC_taxa_MG.df$station_km = as.numeric(as.character(POC_taxa_MG.df$station_km))


POC_taxa_MG.df$Sample_date = factor(POC_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

POC_taxa_MG.sum = Rmisc::summarySE(POC_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/POC_MAGCorr_MG.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(POC_taxa_MG.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
#  scale_color_manual(values = expanded_cbbPalette)+
 # scale_y_log10()+
  #My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(POC_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = sort(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")))

test[order(-test$N), ]

unique(POC_taxa_MG.df$fulltaxa)





#### Metatranscriptomes ####


#Extract relevant genes
POC_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter == "POC_mgperL")[,1])
#POC_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_POC = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% POC_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_POC)
#View(amoAClean_geneabund_KO_POC)

amoAClean_CO2CH4_tbl_long_POC <- amoAClean_geneabund_KO_POC %>%
  filter(KO %in% POC_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_POC$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_POC$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_POC$data_type)
amoAClean_CO2CH4_tbl_long_POC$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_POC$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_POC.df <- spread(amoAClean_CO2CH4_tbl_long_POC[ , ! names(amoAClean_CO2CH4_tbl_long_POC) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_POC)
dim(CO2CH4_TG_POC.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_POC.df$TranscriptsPerGenome = CO2CH4_TG_POC.df$Transcriptomes / CO2CH4_TG_POC.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_POC.df = CO2CH4_TG_POC.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_POC.lng = gather(CO2CH4_TG_POC.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_POC.lng = subset(CO2CH4_TG_POC.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_POC.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_POC.lng = subset(CO2CH4_TG_POC.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_POC.lng = subset(CO2CH4_TG_POC.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_POC.lng$counts = as.numeric(as.character(CO2CH4_TG_POC.lng$counts))
CO2CH4_TG_POC.lng$Associatednumber = as.character(CO2CH4_TG_POC.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_POC.lng$counts = CO2CH4_TG_POC.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_POC.lng$domain = gsub("d__", "", CO2CH4_TG_POC.lng$domain)
CO2CH4_TG_POC.lng$phylum = gsub("p__", "", CO2CH4_TG_POC.lng$phylum)
CO2CH4_TG_POC.lng$class = gsub("c__", "", CO2CH4_TG_POC.lng$class)
CO2CH4_TG_POC.lng$order = gsub("o__", "", CO2CH4_TG_POC.lng$order)
CO2CH4_TG_POC.lng$family = gsub("f__", "", CO2CH4_TG_POC.lng$family)
CO2CH4_TG_POC.lng$genus = gsub("g__", "", CO2CH4_TG_POC.lng$genus)
CO2CH4_TG_POC.lng$species = gsub("s__", "", CO2CH4_TG_POC.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_POC.lng$fulltaxa = paste0(CO2CH4_TG_POC.lng$domain, "__",
                                                CO2CH4_TG_POC.lng$phylum, "__",
                                                CO2CH4_TG_POC.lng$class, "__",
                                                CO2CH4_TG_POC.lng$order, "__",
                                                CO2CH4_TG_POC.lng$family, "__",
                                                CO2CH4_TG_POC.lng$genus, "__",
                                                CO2CH4_TG_POC.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_POC.lng$fulltaxa)
unique(CO2CH4_TG_POC.lng$genome)

POC_taxa_MT.df = CO2CH4_TG_POC.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(POC_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_POC_TG.csv")

#POC_taxa_MT.df = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_POC_TG.csv")

#Clean up for plot
POC_taxa_MT.df$station_km = as.numeric(as.character(POC_taxa_MT.df$station_km))


POC_taxa_MT.df$Sample_date = factor(POC_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

POC_taxa_MT.sum = Rmisc::summarySE(POC_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/POC_MAGCorr_MT.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(POC_taxa_MT.sum, aes(x = station_km, y = counts, colour = fulltaxa))+
 # geom_line(lwd = 1)+
  #facet_wrap(. ~ Sample_date + KO)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  scale_y_log10()+
 # My_Theme 

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(POC_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]

sort(unique(POC_taxa_MT.sum$fulltaxa))


```
```{r SPM MAG matching - MG + MT }

taxa = taxa %>%
  distinct()
 
#### Metagenomes ####

#Extract relevant genes
SPM_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter == "SPM_mgperL")[,1])
#SPM_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_SPM = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% SPM_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_SPM)
#View(amoAClean_geneabund_KO_SPM)

amoAClean_CO2CH4_tbl_long_SPM <- amoAClean_geneabund_KO_SPM %>%
  filter(KO %in% SPM_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 50, 0, 1)) %>% # 0.05% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for above than 0.1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")
dim(amoAClean_CO2CH4_tbl_long_SPM)

#Correct abundance
amoAClean_CO2CH4_tbl_long_SPM$counts = amoAClean_CO2CH4_tbl_long_SPM$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_SPM$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_SPM$domain)
amoAClean_CO2CH4_tbl_long_SPM$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_SPM$phylum)
amoAClean_CO2CH4_tbl_long_SPM$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_SPM$class)
amoAClean_CO2CH4_tbl_long_SPM$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_SPM$order)
amoAClean_CO2CH4_tbl_long_SPM$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_SPM$family)
amoAClean_CO2CH4_tbl_long_SPM$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_SPM$genus)
amoAClean_CO2CH4_tbl_long_SPM$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_SPM$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_SPM$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_SPM$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$class, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$order, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$family, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_SPM$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_SPM$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_SPM$genome)

SPM_taxa_MG.df = amoAClean_CO2CH4_tbl_long_SPM %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(SPM_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_SPM.csv")

#SPM_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_SPM.csv")

#Clean up for plot
SPM_taxa_MG.df$station_km = as.numeric(as.character(SPM_taxa_MG.df$station_km))


SPM_taxa_MG.df$Sample_date = factor(SPM_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

SPM_taxa_MG.sum = Rmisc::summarySE(SPM_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/SPM_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(SPM_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(SPM_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(SPM_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
SPM_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter == "SPM_mgperL")[,1])
#SPM_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_SPM = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% SPM_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_SPM)
#View(amoAClean_geneabund_KO_SPM)

amoAClean_CO2CH4_tbl_long_SPM <- amoAClean_geneabund_KO_SPM %>%
  filter(KO %in% SPM_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

amoAClean_CO2CH4_tbl_long_SPM$counts = amoAClean_CO2CH4_tbl_long_SPM$counts / 1000
unique(amoAClean_CO2CH4_tbl_long_SPM$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_SPM$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_SPM$data_type)
amoAClean_CO2CH4_tbl_long_SPM$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_SPM$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_SPM.df <- spread(amoAClean_CO2CH4_tbl_long_SPM[ , ! names(amoAClean_CO2CH4_tbl_long_SPM) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_SPM)
dim(CO2CH4_TG_SPM.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_SPM.df$TranscriptsPerGenome = CO2CH4_TG_SPM.df$Transcriptomes / CO2CH4_TG_SPM.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_SPM.df = CO2CH4_TG_SPM.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuSPMly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_SPM.lng = gather(CO2CH4_TG_SPM.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_SPM.lng = subset(CO2CH4_TG_SPM.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_SPM.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_SPM.lng = subset(CO2CH4_TG_SPM.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_SPM.lng = subset(CO2CH4_TG_SPM.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_SPM.lng$counts = as.numeric(as.character(CO2CH4_TG_SPM.lng$counts))
CO2CH4_TG_SPM.lng$Associatednumber = as.character(CO2CH4_TG_SPM.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_SPM.lng$counts = CO2CH4_TG_SPM.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_SPM.lng$domain = gsub("d__", "", CO2CH4_TG_SPM.lng$domain)
CO2CH4_TG_SPM.lng$phylum = gsub("p__", "", CO2CH4_TG_SPM.lng$phylum)
CO2CH4_TG_SPM.lng$class = gsub("c__", "", CO2CH4_TG_SPM.lng$class)
CO2CH4_TG_SPM.lng$order = gsub("o__", "", CO2CH4_TG_SPM.lng$order)
CO2CH4_TG_SPM.lng$family = gsub("f__", "", CO2CH4_TG_SPM.lng$family)
CO2CH4_TG_SPM.lng$genus = gsub("g__", "", CO2CH4_TG_SPM.lng$genus)
CO2CH4_TG_SPM.lng$species = gsub("s__", "", CO2CH4_TG_SPM.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_SPM.lng$fulltaxa = paste0(CO2CH4_TG_SPM.lng$domain, "__",
                                                CO2CH4_TG_SPM.lng$phylum, "__",
                                                CO2CH4_TG_SPM.lng$class, "__",
                                                CO2CH4_TG_SPM.lng$order, "__",
                                                CO2CH4_TG_SPM.lng$family, "__",
                                                CO2CH4_TG_SPM.lng$genus, "__",
                                                CO2CH4_TG_SPM.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_SPM.lng$fulltaxa)
unique(CO2CH4_TG_SPM.lng$genome)

SPM_taxa_MT.df = CO2CH4_TG_SPM.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(SPM_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_SPM_TG.csv")

#SPM_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_SPM_TG.csv")

#Clean up for plot
SPM_taxa_MT.df$station_km = as.numeric(as.character(SPM_taxa_MT.df$station_km))


SPM_taxa_MT.df$Sample_date = factor(SPM_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

SPM_taxa_MT.sum = Rmisc::summarySE(SPM_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/SPM_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(SPM_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(SPM_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(SPM_taxa_MT.sum$fulltaxa)

```
```{r Salinity MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
Salinity_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Salinity_PSU")[,1])
#Salinity_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_sal = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Salinity_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_sal)
#View(amoAClean_geneabund_KO_sal)

amoAClean_CO2CH4_tbl_long_sal <- amoAClean_geneabund_KO_sal %>%
  filter(KO %in% Salinity_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_sal$counts = amoAClean_CO2CH4_tbl_long_sal$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_sal$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_sal$domain)
amoAClean_CO2CH4_tbl_long_sal$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_sal$phylum)
amoAClean_CO2CH4_tbl_long_sal$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_sal$class)
amoAClean_CO2CH4_tbl_long_sal$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_sal$order)
amoAClean_CO2CH4_tbl_long_sal$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_sal$family)
amoAClean_CO2CH4_tbl_long_sal$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_sal$genus)
amoAClean_CO2CH4_tbl_long_sal$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_sal$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_sal$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_sal$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$class, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$order, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$family, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_sal$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_sal$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_sal$genome)

Sal_taxa.df = amoAClean_CO2CH4_tbl_long_sal %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Sal_taxa.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_sal.csv")

#Sal_taxa.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_sal.csv")

#Clean up for plot
Sal_taxa.df$station_km = as.numeric(as.character(Sal_taxa.df$station_km))


Sal_taxa.df$Sample_date = factor(Sal_taxa.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Sal_taxa.sum = Rmisc::summarySE(Sal_taxa.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Sal_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Sal_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Sal_taxa.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Sal_taxa.df$fulltaxa)



#### Metatranscriptomes ####



#Extract relevant genes
Salinity_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Salinity_PSU")[,1])
#Salinity_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_sal = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Salinity_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_sal)
#View(amoAClean_geneabund_KO_sal)

amoAClean_CO2CH4_tbl_long_sal <- amoAClean_geneabund_KO_sal %>%
  filter(KO %in% Salinity_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_sal$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_sal$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_sal$data_type)
amoAClean_CO2CH4_tbl_long_sal$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_sal$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_sal.df <- spread(amoAClean_CO2CH4_tbl_long_sal[ , ! names(amoAClean_CO2CH4_tbl_long_sal) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_sal)
dim(CO2CH4_TG_sal.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_sal.df$TranscriptsPerGenome = CO2CH4_TG_sal.df$Transcriptomes / CO2CH4_TG_sal.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_sal.df = CO2CH4_TG_sal.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_sal.lng = gather(CO2CH4_TG_sal.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_sal.lng = subset(CO2CH4_TG_sal.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_sal.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_sal.lng = subset(CO2CH4_TG_sal.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_sal.lng = subset(CO2CH4_TG_sal.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_sal.lng$counts = as.numeric(as.character(CO2CH4_TG_sal.lng$counts))
CO2CH4_TG_sal.lng$Associatednumber = as.character(CO2CH4_TG_sal.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_sal.lng$counts = CO2CH4_TG_sal.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_sal.lng$domain = gsub("d__", "", CO2CH4_TG_sal.lng$domain)
CO2CH4_TG_sal.lng$phylum = gsub("p__", "", CO2CH4_TG_sal.lng$phylum)
CO2CH4_TG_sal.lng$class = gsub("c__", "", CO2CH4_TG_sal.lng$class)
CO2CH4_TG_sal.lng$order = gsub("o__", "", CO2CH4_TG_sal.lng$order)
CO2CH4_TG_sal.lng$family = gsub("f__", "", CO2CH4_TG_sal.lng$family)
CO2CH4_TG_sal.lng$genus = gsub("g__", "", CO2CH4_TG_sal.lng$genus)
CO2CH4_TG_sal.lng$species = gsub("s__", "", CO2CH4_TG_sal.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_sal.lng$fulltaxa = paste0(CO2CH4_TG_sal.lng$domain, "__",
                                                CO2CH4_TG_sal.lng$phylum, "__",
                                                CO2CH4_TG_sal.lng$class, "__",
                                                CO2CH4_TG_sal.lng$order, "__",
                                                CO2CH4_TG_sal.lng$family, "__",
                                                CO2CH4_TG_sal.lng$genus, "__",
                                                CO2CH4_TG_sal.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_sal.lng$fulltaxa)
unique(CO2CH4_TG_sal.lng$genome)

Sal_taxa_MT.df = CO2CH4_TG_sal.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Sal_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_sal_TG.csv")

Sal_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_sal_TG.csv")

#Clean up for plot
Sal_taxa_MT.df$station_km = as.numeric(as.character(Sal_taxa_MT.df$station_km))


Sal_taxa_MT.df$Sample_date = factor(Sal_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Sal_taxa_MT.sum = Rmisc::summarySE(Sal_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Sal_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Sal_taxa_MT.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Sal_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]



unique(Sal_taxa_MT.sum$fulltaxa)



```
```{r Turbidity MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
Turbidity_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Turbidity_NTU")[,1])
#Turbidity_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Turb = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Turbidity_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Turb)
#View(amoAClean_geneabund_KO_Turb)

amoAClean_CO2CH4_tbl_long_Turb <- amoAClean_geneabund_KO_Turb %>%
  filter(KO %in% Turbidity_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_Turb$counts = amoAClean_CO2CH4_tbl_long_Turb$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_Turb$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_Turb$domain)
amoAClean_CO2CH4_tbl_long_Turb$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_Turb$phylum)
amoAClean_CO2CH4_tbl_long_Turb$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_Turb$class)
amoAClean_CO2CH4_tbl_long_Turb$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_Turb$order)
amoAClean_CO2CH4_tbl_long_Turb$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_Turb$family)
amoAClean_CO2CH4_tbl_long_Turb$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_Turb$genus)
amoAClean_CO2CH4_tbl_long_Turb$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_Turb$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_Turb$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_Turb$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$class, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$order, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$family, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Turb$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Turb$genome)

Turb_taxa.df = amoAClean_CO2CH4_tbl_long_Turb %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Turb_taxa.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Turb.csv")

Turb_taxa.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Turb.csv")

#Clean up for plot
Turb_taxa.df$station_km = as.numeric(as.character(Turb_taxa.df$station_km))


Turb_taxa.df$Sample_date = factor(Turb_taxa.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Turb_taxa_MG.sum = Rmisc::summarySE(Turb_taxa.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Turb_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Turb_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Turb_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Turb_taxa_MG.sum$fulltaxa)



#### Metatranscriptomes ####



#Extract relevant genes
Turbidity_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Turbidity_NTU")[,1])
#Turbidity_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Turb = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Turbidity_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Turb)
#View(amoAClean_geneabund_KO_Turb)

amoAClean_CO2CH4_tbl_long_Turb <- amoAClean_geneabund_KO_Turb %>%
  filter(KO %in% Turbidity_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_Turb$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Turb$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Turb$data_type)
amoAClean_CO2CH4_tbl_long_Turb$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Turb$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Turb.df <- spread(amoAClean_CO2CH4_tbl_long_Turb[ , ! names(amoAClean_CO2CH4_tbl_long_Turb) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Turb)
dim(CO2CH4_TG_Turb.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Turb.df$TranscriptsPerGenome = CO2CH4_TG_Turb.df$Transcriptomes / CO2CH4_TG_Turb.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Turb.df = CO2CH4_TG_Turb.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuTurbly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Turb.lng = gather(CO2CH4_TG_Turb.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_Turb.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Turb.lng$counts = as.numeric(as.character(CO2CH4_TG_Turb.lng$counts))
CO2CH4_TG_Turb.lng$Associatednumber = as.character(CO2CH4_TG_Turb.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_Turb.lng$counts = CO2CH4_TG_Turb.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_Turb.lng$domain = gsub("d__", "", CO2CH4_TG_Turb.lng$domain)
CO2CH4_TG_Turb.lng$phylum = gsub("p__", "", CO2CH4_TG_Turb.lng$phylum)
CO2CH4_TG_Turb.lng$class = gsub("c__", "", CO2CH4_TG_Turb.lng$class)
CO2CH4_TG_Turb.lng$order = gsub("o__", "", CO2CH4_TG_Turb.lng$order)
CO2CH4_TG_Turb.lng$family = gsub("f__", "", CO2CH4_TG_Turb.lng$family)
CO2CH4_TG_Turb.lng$genus = gsub("g__", "", CO2CH4_TG_Turb.lng$genus)
CO2CH4_TG_Turb.lng$species = gsub("s__", "", CO2CH4_TG_Turb.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_Turb.lng$fulltaxa = paste0(CO2CH4_TG_Turb.lng$domain, "__",
                                                CO2CH4_TG_Turb.lng$phylum, "__",
                                                CO2CH4_TG_Turb.lng$class, "__",
                                                CO2CH4_TG_Turb.lng$order, "__",
                                                CO2CH4_TG_Turb.lng$family, "__",
                                                CO2CH4_TG_Turb.lng$genus, "__",
                                                CO2CH4_TG_Turb.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_Turb.lng$fulltaxa)
unique(CO2CH4_TG_Turb.lng$genome)

Turb_taxa_MT.df = CO2CH4_TG_Turb.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Turb_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Turb_TG.csv")

#Turb_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Turb_TG.csv")

#Clean up for plot
Turb_taxa_MT.df$station_km = as.numeric(as.character(Turb_taxa_MT.df$station_km))


Turb_taxa_MT.df$Sample_date = factor(Turb_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Turb_taxa_MT.sum = Rmisc::summarySE(Turb_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Turb_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Turb_taxa_MT.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Turb_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]

unique(Turb_taxa_MT.sum$fulltaxa)


```
```{r O2 MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
O2_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "O2_uM")[,1])
#O2_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_O2 = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% O2_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_O2)
#View(amoAClean_geneabund_KO_O2)

amoAClean_CO2CH4_tbl_long_O2 <- amoAClean_geneabund_KO_O2 %>%
  filter(KO %in% O2_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_O2$counts = amoAClean_CO2CH4_tbl_long_O2$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_O2$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_O2$domain)
amoAClean_CO2CH4_tbl_long_O2$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_O2$phylum)
amoAClean_CO2CH4_tbl_long_O2$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_O2$class)
amoAClean_CO2CH4_tbl_long_O2$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_O2$order)
amoAClean_CO2CH4_tbl_long_O2$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_O2$family)
amoAClean_CO2CH4_tbl_long_O2$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_O2$genus)
amoAClean_CO2CH4_tbl_long_O2$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_O2$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_O2$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_O2$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$class, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$order, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$family, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_O2$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_O2$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_O2$genome)

O2_taxa_MG.df = amoAClean_CO2CH4_tbl_long_O2 %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(O2_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_O2.csv")

#O2_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_O2.csv")

#Clean up for plot
O2_taxa_MG.df$station_km = as.numeric(as.character(O2_taxa_MG.df$station_km))


O2_taxa_MG.df$Sample_date = factor(O2_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

O2_taxa_MG.sum = Rmisc::summarySE(O2_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/O2_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(O2_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(O2_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = sort(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")))

test[order(-test$N), ]

unique(O2_taxa_MG.df$fulltaxa)



#### Metatranscriptomes ####



#Extract relevant genes
O2_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "O2_uM")[,1])
#O2_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_O2 = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% O2_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_O2)
#View(amoAClean_geneabund_KO_O2)

amoAClean_CO2CH4_tbl_long_O2 <- amoAClean_geneabund_KO_O2 %>%
  filter(KO %in% O2_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_O2$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_O2$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_O2$data_type)
amoAClean_CO2CH4_tbl_long_O2$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_O2$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_O2.df <- spread(amoAClean_CO2CH4_tbl_long_O2[ , ! names(amoAClean_CO2CH4_tbl_long_O2) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_O2)
dim(CO2CH4_TG_O2.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_O2.df$TranscriptsPerGenome = CO2CH4_TG_O2.df$Transcriptomes / CO2CH4_TG_O2.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_O2.df = CO2CH4_TG_O2.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuO2ly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_O2.lng = gather(CO2CH4_TG_O2.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_O2.lng = subset(CO2CH4_TG_O2.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_O2.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_O2.lng = subset(CO2CH4_TG_O2.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_O2.lng = subset(CO2CH4_TG_O2.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_O2.lng$counts = as.numeric(as.character(CO2CH4_TG_O2.lng$counts))
CO2CH4_TG_O2.lng$Associatednumber = as.character(CO2CH4_TG_O2.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_O2.lng$counts = CO2CH4_TG_O2.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_O2.lng$domain = gsub("d__", "", CO2CH4_TG_O2.lng$domain)
CO2CH4_TG_O2.lng$phylum = gsub("p__", "", CO2CH4_TG_O2.lng$phylum)
CO2CH4_TG_O2.lng$class = gsub("c__", "", CO2CH4_TG_O2.lng$class)
CO2CH4_TG_O2.lng$order = gsub("o__", "", CO2CH4_TG_O2.lng$order)
CO2CH4_TG_O2.lng$family = gsub("f__", "", CO2CH4_TG_O2.lng$family)
CO2CH4_TG_O2.lng$genus = gsub("g__", "", CO2CH4_TG_O2.lng$genus)
CO2CH4_TG_O2.lng$species = gsub("s__", "", CO2CH4_TG_O2.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_O2.lng$fulltaxa = paste0(CO2CH4_TG_O2.lng$domain, "__",
                                                CO2CH4_TG_O2.lng$phylum, "__",
                                                CO2CH4_TG_O2.lng$class, "__",
                                                CO2CH4_TG_O2.lng$order, "__",
                                                CO2CH4_TG_O2.lng$family, "__",
                                                CO2CH4_TG_O2.lng$genus, "__",
                                                CO2CH4_TG_O2.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_O2.lng$fulltaxa)
unique(CO2CH4_TG_O2.lng$genome)

O2_taxa_MT.df = CO2CH4_TG_O2.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(O2_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_O2_TG.csv")

#O2_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_O2_TG.csv")

#Clean up for plot
O2_taxa_MT.df$station_km = as.numeric(as.character(O2_taxa_MT.df$station_km))


O2_taxa_MT.df$Sample_date = factor(O2_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

O2_taxa_MT.sum = Rmisc::summarySE(O2_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/O2_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(O2_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(O2_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO"))

test2[order(-test2$N), ]

unique(O2_taxa_MT.sum$fulltaxa)


```
```{r dCO2 MAG matching - MG + MT }

taxa = taxa %>%
  distinct()

#### Metagenomes ####

#Extract relevant genes
dCO2_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "dCO2_uM")[,1])
#dCO2_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_dCO2 = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% dCO2_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_dCO2)
#View(amoAClean_geneabund_KO_dCO2)

amoAClean_CO2CH4_tbl_long_dCO2 <- amoAClean_geneabund_KO_dCO2 %>%
  filter(KO %in% dCO2_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_dCO2$counts = amoAClean_CO2CH4_tbl_long_dCO2$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_dCO2$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_dCO2$domain)
amoAClean_CO2CH4_tbl_long_dCO2$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_dCO2$phylum)
amoAClean_CO2CH4_tbl_long_dCO2$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_dCO2$class)
amoAClean_CO2CH4_tbl_long_dCO2$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_dCO2$order)
amoAClean_CO2CH4_tbl_long_dCO2$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_dCO2$family)
amoAClean_CO2CH4_tbl_long_dCO2$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_dCO2$genus)
amoAClean_CO2CH4_tbl_long_dCO2$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_dCO2$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_dCO2$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_dCO2$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$class, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$order, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$family, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_dCO2$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_dCO2$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_dCO2$genome)

dCO2_taxa_MG.df = amoAClean_CO2CH4_tbl_long_dCO2 %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(dCO2_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_dCO2.csv")

#dCO2_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_dCO2.csv")

#Clean up for plot
dCO2_taxa_MG.df$station_km = as.numeric(as.character(dCO2_taxa_MG.df$station_km))


dCO2_taxa_MG.df$Sample_date = factor(dCO2_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

dCO2_taxa_MG.sum = Rmisc::summarySE(dCO2_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/dCO2_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(dCO2_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(dCO2_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(dCO2_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
dCO2_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "dCO2_uM")[,1])
#dCO2_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_dCO2 = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% dCO2_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_dCO2)
#View(amoAClean_geneabund_KO_dCO2)

amoAClean_CO2CH4_tbl_long_dCO2 <- amoAClean_geneabund_KO_dCO2 %>%
  filter(KO %in% dCO2_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_dCO2$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_dCO2$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_dCO2$data_type)
amoAClean_CO2CH4_tbl_long_dCO2$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_dCO2$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_dCO2.df <- spread(amoAClean_CO2CH4_tbl_long_dCO2[ , ! names(amoAClean_CO2CH4_tbl_long_dCO2) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_dCO2)
dim(CO2CH4_TG_dCO2.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_dCO2.df$TranscriptsPerGenome = CO2CH4_TG_dCO2.df$Transcriptomes / CO2CH4_TG_dCO2.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_dCO2.df = CO2CH4_TG_dCO2.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usudCO2ly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_dCO2.lng = gather(CO2CH4_TG_dCO2.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_dCO2.lng = subset(CO2CH4_TG_dCO2.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_dCO2.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_dCO2.lng = subset(CO2CH4_TG_dCO2.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_dCO2.lng = subset(CO2CH4_TG_dCO2.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_dCO2.lng$counts = as.numeric(as.character(CO2CH4_TG_dCO2.lng$counts))
CO2CH4_TG_dCO2.lng$Associatednumber = as.character(CO2CH4_TG_dCO2.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_dCO2.lng$counts = CO2CH4_TG_dCO2.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_dCO2.lng$domain = gsub("d__", "", CO2CH4_TG_dCO2.lng$domain)
CO2CH4_TG_dCO2.lng$phylum = gsub("p__", "", CO2CH4_TG_dCO2.lng$phylum)
CO2CH4_TG_dCO2.lng$class = gsub("c__", "", CO2CH4_TG_dCO2.lng$class)
CO2CH4_TG_dCO2.lng$order = gsub("o__", "", CO2CH4_TG_dCO2.lng$order)
CO2CH4_TG_dCO2.lng$family = gsub("f__", "", CO2CH4_TG_dCO2.lng$family)
CO2CH4_TG_dCO2.lng$genus = gsub("g__", "", CO2CH4_TG_dCO2.lng$genus)
CO2CH4_TG_dCO2.lng$species = gsub("s__", "", CO2CH4_TG_dCO2.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_dCO2.lng$fulltaxa = paste0(CO2CH4_TG_dCO2.lng$domain, "__",
                                                CO2CH4_TG_dCO2.lng$phylum, "__",
                                                CO2CH4_TG_dCO2.lng$class, "__",
                                                CO2CH4_TG_dCO2.lng$order, "__",
                                                CO2CH4_TG_dCO2.lng$family, "__",
                                                CO2CH4_TG_dCO2.lng$genus, "__",
                                                CO2CH4_TG_dCO2.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_dCO2.lng$fulltaxa)
unique(CO2CH4_TG_dCO2.lng$genome)

dCO2_taxa_MT.df = CO2CH4_TG_dCO2.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(dCO2_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_dCO2_TG.csv")

dCO2_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_dCO2_TG.csv")

#Clean up for plot
dCO2_taxa_MT.df$station_km = as.numeric(as.character(dCO2_taxa_MT.df$station_km))


dCO2_taxa_MT.df$Sample_date = factor(dCO2_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

dCO2_taxa_MT.sum = Rmisc::summarySE(dCO2_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/dCO2_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(dCO2_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(dCO2_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(dCO2_taxa_MT.sum$fulltaxa)

```
```{r Temperature MAG matching - MG + MT }

taxa = taxa %>%
  distinct()
 
#### Metagenomes ####

#Extract relevant genes
Temp_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Temperature_TBDHereon")[,1])
#Temp_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Temp = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Temp_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Temp)
#View(amoAClean_geneabund_KO_Temp)

amoAClean_CO2CH4_tbl_long_Temp <- amoAClean_geneabund_KO_Temp %>%
  filter(KO %in% Temp_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_Temp$counts = amoAClean_CO2CH4_tbl_long_Temp$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_Temp$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_Temp$domain)
amoAClean_CO2CH4_tbl_long_Temp$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_Temp$phylum)
amoAClean_CO2CH4_tbl_long_Temp$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_Temp$class)
amoAClean_CO2CH4_tbl_long_Temp$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_Temp$order)
amoAClean_CO2CH4_tbl_long_Temp$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_Temp$family)
amoAClean_CO2CH4_tbl_long_Temp$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_Temp$genus)
amoAClean_CO2CH4_tbl_long_Temp$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_Temp$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_Temp$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_Temp$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$class, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$order, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$family, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_Temp$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Temp$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Temp$genome)

Temp_taxa_MG.df = amoAClean_CO2CH4_tbl_long_Temp %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Temp_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Temp.csv")

#Temp_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Temp.csv")

#Clean up for plot
Temp_taxa_MG.df$station_km = as.numeric(as.character(Temp_taxa_MG.df$station_km))


Temp_taxa_MG.df$Sample_date = factor(Temp_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Temp_taxa_MG.sum = Rmisc::summarySE(Temp_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Temp_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Temp_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Temp_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Temp_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
Temp_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Temperature_TBDHereon")[,1])
#Temp_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Temp = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Temp_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Temp)
#View(amoAClean_geneabund_KO_Temp)

amoAClean_CO2CH4_tbl_long_Temp <- amoAClean_geneabund_KO_Temp %>%
  filter(KO %in% Temp_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_Temp$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Temp$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Temp$data_type)
amoAClean_CO2CH4_tbl_long_Temp$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Temp$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Temp.df <- spread(amoAClean_CO2CH4_tbl_long_Temp[ , ! names(amoAClean_CO2CH4_tbl_long_Temp) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Temp)
dim(CO2CH4_TG_Temp.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Temp.df$TranscriptsPerGenome = CO2CH4_TG_Temp.df$Transcriptomes / CO2CH4_TG_Temp.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Temp.df = CO2CH4_TG_Temp.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuTemply the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Temp.lng = gather(CO2CH4_TG_Temp.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_Temp.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Temp.lng = subset(CO2CH4_TG_Temp.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Temp.lng$counts = as.numeric(as.character(CO2CH4_TG_Temp.lng$counts))
CO2CH4_TG_Temp.lng$Associatednumber = as.character(CO2CH4_TG_Temp.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_Temp.lng$counts = CO2CH4_TG_Temp.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_Temp.lng$domain = gsub("d__", "", CO2CH4_TG_Temp.lng$domain)
CO2CH4_TG_Temp.lng$phylum = gsub("p__", "", CO2CH4_TG_Temp.lng$phylum)
CO2CH4_TG_Temp.lng$class = gsub("c__", "", CO2CH4_TG_Temp.lng$class)
CO2CH4_TG_Temp.lng$order = gsub("o__", "", CO2CH4_TG_Temp.lng$order)
CO2CH4_TG_Temp.lng$family = gsub("f__", "", CO2CH4_TG_Temp.lng$family)
CO2CH4_TG_Temp.lng$genus = gsub("g__", "", CO2CH4_TG_Temp.lng$genus)
CO2CH4_TG_Temp.lng$species = gsub("s__", "", CO2CH4_TG_Temp.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_Temp.lng$fulltaxa = paste0(CO2CH4_TG_Temp.lng$domain, "__",
                                                CO2CH4_TG_Temp.lng$phylum, "__",
                                                CO2CH4_TG_Temp.lng$class, "__",
                                                CO2CH4_TG_Temp.lng$order, "__",
                                                CO2CH4_TG_Temp.lng$family, "__",
                                                CO2CH4_TG_Temp.lng$genus, "__",
                                                CO2CH4_TG_Temp.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_Temp.lng$fulltaxa)
unique(CO2CH4_TG_Temp.lng$genome)

Temp_taxa_MT.df = CO2CH4_TG_Temp.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Temp_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Temp_TG.csv")

#Temp_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Temp_TG.csv")

#Clean up for plot
Temp_taxa_MT.df$station_km = as.numeric(as.character(Temp_taxa_MT.df$station_km))


Temp_taxa_MT.df$Sample_date = factor(Temp_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Temp_taxa_MT.sum = Rmisc::summarySE(Temp_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Temp_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Temp_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Temp_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(Temp_taxa_MT.sum$fulltaxa)

```
```{r Nitrate MAG matching - MG + MT }

taxa = taxa %>%
  distinct()
 
#### Metagenomes ####

#Extract relevant genes
Nitrate_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Nitrate_mg.L")[,1])
#Nitrate_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Nitrate = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Nitrate_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Nitrate)
#View(amoAClean_geneabund_KO_Nitrate)

amoAClean_CO2CH4_tbl_long_Nitrate <- amoAClean_geneabund_KO_Nitrate %>%
  filter(KO %in% Nitrate_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_Nitrate$counts = amoAClean_CO2CH4_tbl_long_Nitrate$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_Nitrate$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_Nitrate$domain)
amoAClean_CO2CH4_tbl_long_Nitrate$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_Nitrate$phylum)
amoAClean_CO2CH4_tbl_long_Nitrate$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_Nitrate$class)
amoAClean_CO2CH4_tbl_long_Nitrate$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_Nitrate$order)
amoAClean_CO2CH4_tbl_long_Nitrate$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_Nitrate$family)
amoAClean_CO2CH4_tbl_long_Nitrate$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_Nitrate$genus)
amoAClean_CO2CH4_tbl_long_Nitrate$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_Nitrate$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_Nitrate$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_Nitrate$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$class, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$order, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$family, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_Nitrate$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Nitrate$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Nitrate$genome)

Nitrate_taxa_MG.df = amoAClean_CO2CH4_tbl_long_Nitrate %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Nitrate_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Nitrate.csv")

#Nitrate_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Nitrate.csv")

#Clean up for plot
Nitrate_taxa_MG.df$station_km = as.numeric(as.character(Nitrate_taxa_MG.df$station_km))


Nitrate_taxa_MG.df$Sample_date = factor(Nitrate_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Nitrate_taxa_MG.sum = Rmisc::summarySE(Nitrate_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Nitrate_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Nitrate_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Nitrate_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Nitrate_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
Nitrate_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Nitrate_mg.L")[,1])
#Nitrate_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Nitrate = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Nitrate_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Nitrate)
#View(amoAClean_geneabund_KO_Nitrate)

amoAClean_CO2CH4_tbl_long_Nitrate <- amoAClean_geneabund_KO_Nitrate %>%
  filter(KO %in% Nitrate_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_Nitrate$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Nitrate$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Nitrate$data_type)
amoAClean_CO2CH4_tbl_long_Nitrate$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Nitrate$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Nitrate.df <- spread(amoAClean_CO2CH4_tbl_long_Nitrate[ , ! names(amoAClean_CO2CH4_tbl_long_Nitrate) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Nitrate)
dim(CO2CH4_TG_Nitrate.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Nitrate.df$TranscriptsPerGenome = CO2CH4_TG_Nitrate.df$Transcriptomes / CO2CH4_TG_Nitrate.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Nitrate.df = CO2CH4_TG_Nitrate.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuNitrately the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Nitrate.lng = gather(CO2CH4_TG_Nitrate.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Nitrate.lng = subset(CO2CH4_TG_Nitrate.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_Nitrate.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Nitrate.lng = subset(CO2CH4_TG_Nitrate.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Nitrate.lng = subset(CO2CH4_TG_Nitrate.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Nitrate.lng$counts = as.numeric(as.character(CO2CH4_TG_Nitrate.lng$counts))
CO2CH4_TG_Nitrate.lng$Associatednumber = as.character(CO2CH4_TG_Nitrate.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_Nitrate.lng$counts = CO2CH4_TG_Nitrate.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_Nitrate.lng$domain = gsub("d__", "", CO2CH4_TG_Nitrate.lng$domain)
CO2CH4_TG_Nitrate.lng$phylum = gsub("p__", "", CO2CH4_TG_Nitrate.lng$phylum)
CO2CH4_TG_Nitrate.lng$class = gsub("c__", "", CO2CH4_TG_Nitrate.lng$class)
CO2CH4_TG_Nitrate.lng$order = gsub("o__", "", CO2CH4_TG_Nitrate.lng$order)
CO2CH4_TG_Nitrate.lng$family = gsub("f__", "", CO2CH4_TG_Nitrate.lng$family)
CO2CH4_TG_Nitrate.lng$genus = gsub("g__", "", CO2CH4_TG_Nitrate.lng$genus)
CO2CH4_TG_Nitrate.lng$species = gsub("s__", "", CO2CH4_TG_Nitrate.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_Nitrate.lng$fulltaxa = paste0(CO2CH4_TG_Nitrate.lng$domain, "__",
                                                CO2CH4_TG_Nitrate.lng$phylum, "__",
                                                CO2CH4_TG_Nitrate.lng$class, "__",
                                                CO2CH4_TG_Nitrate.lng$order, "__",
                                                CO2CH4_TG_Nitrate.lng$family, "__",
                                                CO2CH4_TG_Nitrate.lng$genus, "__",
                                                CO2CH4_TG_Nitrate.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_Nitrate.lng$fulltaxa)
unique(CO2CH4_TG_Nitrate.lng$genome)

Nitrate_taxa_MT.df = CO2CH4_TG_Nitrate.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Nitrate_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Nitrate_TG.csv")

#Nitrate_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Nitrate_TG.csv")

#Clean up for plot
Nitrate_taxa_MT.df$station_km = as.numeric(as.character(Nitrate_taxa_MT.df$station_km))


Nitrate_taxa_MT.df$Sample_date = factor(Nitrate_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Nitrate_taxa_MT.sum = Rmisc::summarySE(Nitrate_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Nitrate_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Nitrate_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Nitrate_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(Nitrate_taxa_MT.sum$fulltaxa)

```
```{r Turbidity MAG matching - MG + MT }

taxa = taxa %>%
  distinct()
 
#### Metagenomes ####

#Extract relevant genes
Turb_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter == "Turbidity_NTU")[,1])
#Turb_genes_MG.ls = c("K00027", "K00029", "K00030", "K00122", "K00123", "K00126", "K00161", "K00162", "K00163", "K00164", "K00179", "K00180", "K00201", "K00228", "K00252", "K00281", "K00283", "K00365", "K00457", "K00471", "K00477", "K00595", "K00643", "K00647", "K00767", "K00788", "K01003", "K01428", "K01459", "K01484", "K01571", "K01575", "K01578", "K01579", "K01580", "K01584", "K01585", "K01586", "K01591", "K01593", "K01595", "K01596", "K01597", "K01607", "K01608", "K01609", "K01610", "K01613", "K01616", "K01653", "K01673", "K01674", "K01713", "K01725", "K01935", "K02548", "K02551", "K03119", "K03392", "K03518", "K03519", "K03520", "K03782", "K03928", "K04102", "K04517", "K04518", "K05886", "K05921", "K06016", "K06033", "K06034", "K08678", "K11381", "K12251", "K12253", "K13039", "K13485", "K13745", "K14446", "K15737", "K16066", "K16872", "K18076", "K18473", "K20036", "K20509", "K21615", "K21728", "K22024", "K22130", "K22616", "K23248")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Turb = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Turb_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Turb)
#View(amoAClean_geneabund_KO_Turb)

amoAClean_CO2CH4_tbl_long_Turb <- amoAClean_geneabund_KO_Turb %>%
  filter(KO %in% Turb_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_Turb$counts = amoAClean_CO2CH4_tbl_long_Turb$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_Turb$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_Turb$domain)
amoAClean_CO2CH4_tbl_long_Turb$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_Turb$phylum)
amoAClean_CO2CH4_tbl_long_Turb$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_Turb$class)
amoAClean_CO2CH4_tbl_long_Turb$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_Turb$order)
amoAClean_CO2CH4_tbl_long_Turb$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_Turb$family)
amoAClean_CO2CH4_tbl_long_Turb$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_Turb$genus)
amoAClean_CO2CH4_tbl_long_Turb$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_Turb$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_Turb$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_Turb$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$class, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$order, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$family, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_Turb$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_Turb$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_Turb$genome)

Turb_taxa_MG.df = amoAClean_CO2CH4_tbl_long_Turb %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Turb_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Turb.csv")

#Turb_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_Turb.csv")

#Clean up for plot
Turb_taxa_MG.df$station_km = as.numeric(as.character(Turb_taxa_MG.df$station_km))


Turb_taxa_MG.df$Sample_date = factor(Turb_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Turb_taxa_MG.sum = Rmisc::summarySE(Turb_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Turb_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Turb_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Turb_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(Turb_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
Turb_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter == "Turbidity_NTU")[,1])
#Turb_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_Turb = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% Turb_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_Turb)
#View(amoAClean_geneabund_KO_Turb)

amoAClean_CO2CH4_tbl_long_Turb <- amoAClean_geneabund_KO_Turb %>%
  filter(KO %in% Turb_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_Turb$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_Turb$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_Turb$data_type)
amoAClean_CO2CH4_tbl_long_Turb$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_Turb$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_Turb.df <- spread(amoAClean_CO2CH4_tbl_long_Turb[ , ! names(amoAClean_CO2CH4_tbl_long_Turb) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_Turb)
dim(CO2CH4_TG_Turb.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_Turb.df$TranscriptsPerGenome = CO2CH4_TG_Turb.df$Transcriptomes / CO2CH4_TG_Turb.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_Turb.df = CO2CH4_TG_Turb.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuTurbly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_Turb.lng = gather(CO2CH4_TG_Turb.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_Turb.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_Turb.lng = subset(CO2CH4_TG_Turb.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_Turb.lng$counts = as.numeric(as.character(CO2CH4_TG_Turb.lng$counts))
CO2CH4_TG_Turb.lng$Associatednumber = as.character(CO2CH4_TG_Turb.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_Turb.lng$counts = CO2CH4_TG_Turb.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_Turb.lng$domain = gsub("d__", "", CO2CH4_TG_Turb.lng$domain)
CO2CH4_TG_Turb.lng$phylum = gsub("p__", "", CO2CH4_TG_Turb.lng$phylum)
CO2CH4_TG_Turb.lng$class = gsub("c__", "", CO2CH4_TG_Turb.lng$class)
CO2CH4_TG_Turb.lng$order = gsub("o__", "", CO2CH4_TG_Turb.lng$order)
CO2CH4_TG_Turb.lng$family = gsub("f__", "", CO2CH4_TG_Turb.lng$family)
CO2CH4_TG_Turb.lng$genus = gsub("g__", "", CO2CH4_TG_Turb.lng$genus)
CO2CH4_TG_Turb.lng$species = gsub("s__", "", CO2CH4_TG_Turb.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_Turb.lng$fulltaxa = paste0(CO2CH4_TG_Turb.lng$domain, "__",
                                                CO2CH4_TG_Turb.lng$phylum, "__",
                                                CO2CH4_TG_Turb.lng$class, "__",
                                                CO2CH4_TG_Turb.lng$order, "__",
                                                CO2CH4_TG_Turb.lng$family, "__",
                                                CO2CH4_TG_Turb.lng$genus, "__",
                                                CO2CH4_TG_Turb.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_Turb.lng$fulltaxa)
unique(CO2CH4_TG_Turb.lng$genome)

Turb_taxa_MT.df = CO2CH4_TG_Turb.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(Turb_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Turb_TG.csv")

#Turb_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_Turb_TG.csv")

#Clean up for plot
Turb_taxa_MT.df$station_km = as.numeric(as.character(Turb_taxa_MT.df$station_km))


Turb_taxa_MT.df$Sample_date = factor(Turb_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Turb_taxa_MT.sum = Rmisc::summarySE(Turb_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/Turb_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(Turb_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(Turb_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(Turb_taxa_MT.sum$fulltaxa)

```

```{r All_Water water MAG matching - MG + MT}
Results.df = read.csv("F:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

#### Metagenomes ####

#Extract relevant genes
All_Water_genes_MG.ls = sort(subset(Results_MG_water.df, PhysicochemicalParameter!= "All_Water_uM")[,1])


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_All_Water = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% All_Water_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_All_Water)
#View(amoAClean_geneabund_KO_All_Water)

amoAClean_CO2CH4_tbl_long_All_Water <- amoAClean_geneabund_KO_All_Water %>%
  filter(KO %in% All_Water_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_All_Water$counts = amoAClean_CO2CH4_tbl_long_All_Water$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_All_Water$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_All_Water$domain)
amoAClean_CO2CH4_tbl_long_All_Water$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_All_Water$phylum)
amoAClean_CO2CH4_tbl_long_All_Water$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_All_Water$class)
amoAClean_CO2CH4_tbl_long_All_Water$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_All_Water$order)
amoAClean_CO2CH4_tbl_long_All_Water$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_All_Water$family)
amoAClean_CO2CH4_tbl_long_All_Water$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_All_Water$genus)
amoAClean_CO2CH4_tbl_long_All_Water$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_All_Water$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_All_Water$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_All_Water$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$class, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$order, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$family, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_All_Water$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_All_Water$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_All_Water$genome)

All_Water_taxa_MG.df = amoAClean_CO2CH4_tbl_long_All_Water %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(All_Water_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_All_Water.csv")

#All_Water_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_All_Water.csv")

#Clean up for plot
All_Water_taxa_MG.df$station_km = as.numeric(as.character(All_Water_taxa_MG.df$station_km))


All_Water_taxa_MG.df$Sample_date = factor(All_Water_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

All_Water_taxa_MG.sum = Rmisc::summarySE(All_Water_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/All_Water_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(All_Water_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(All_Water_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(All_Water_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
All_Water_genes_MT.ls = sort(subset(Results_MT_water.df, PhysicochemicalParameter!= "All_Water_uM")[,1])
#All_Water_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_All_Water = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% All_Water_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_All_Water)
#View(amoAClean_geneabund_KO_All_Water)

amoAClean_CO2CH4_tbl_long_All_Water <- amoAClean_geneabund_KO_All_Water %>%
  filter(KO %in% All_Water_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_All_Water$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_All_Water$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_All_Water$data_type)
amoAClean_CO2CH4_tbl_long_All_Water$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_All_Water$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_All_Water.df <- spread(amoAClean_CO2CH4_tbl_long_All_Water[ , ! names(amoAClean_CO2CH4_tbl_long_All_Water) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_All_Water)
dim(CO2CH4_TG_All_Water.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_All_Water.df$TranscriptsPerGenome = CO2CH4_TG_All_Water.df$Transcriptomes / CO2CH4_TG_All_Water.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_All_Water.df = CO2CH4_TG_All_Water.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuAll_Waterly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_All_Water.lng = gather(CO2CH4_TG_All_Water.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_All_Water.lng = subset(CO2CH4_TG_All_Water.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_All_Water.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_All_Water.lng = subset(CO2CH4_TG_All_Water.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_All_Water.lng = subset(CO2CH4_TG_All_Water.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_All_Water.lng$counts = as.numeric(as.character(CO2CH4_TG_All_Water.lng$counts))
CO2CH4_TG_All_Water.lng$Associatednumber = as.character(CO2CH4_TG_All_Water.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_All_Water.lng$counts = CO2CH4_TG_All_Water.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_All_Water.lng$domain = gsub("d__", "", CO2CH4_TG_All_Water.lng$domain)
CO2CH4_TG_All_Water.lng$phylum = gsub("p__", "", CO2CH4_TG_All_Water.lng$phylum)
CO2CH4_TG_All_Water.lng$class = gsub("c__", "", CO2CH4_TG_All_Water.lng$class)
CO2CH4_TG_All_Water.lng$order = gsub("o__", "", CO2CH4_TG_All_Water.lng$order)
CO2CH4_TG_All_Water.lng$family = gsub("f__", "", CO2CH4_TG_All_Water.lng$family)
CO2CH4_TG_All_Water.lng$genus = gsub("g__", "", CO2CH4_TG_All_Water.lng$genus)
CO2CH4_TG_All_Water.lng$species = gsub("s__", "", CO2CH4_TG_All_Water.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_All_Water.lng$fulltaxa = paste0(CO2CH4_TG_All_Water.lng$domain, "__",
                                                CO2CH4_TG_All_Water.lng$phylum, "__",
                                                CO2CH4_TG_All_Water.lng$class, "__",
                                                CO2CH4_TG_All_Water.lng$order, "__",
                                                CO2CH4_TG_All_Water.lng$family, "__",
                                                CO2CH4_TG_All_Water.lng$genus, "__",
                                                CO2CH4_TG_All_Water.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_All_Water.lng$fulltaxa)
unique(CO2CH4_TG_All_Water.lng$genome)

All_Water_taxa_MT.df = CO2CH4_TG_All_Water.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(All_Water_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_All_Water_TG.csv")

All_Water_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_All_Water_TG.csv")

#Clean up for plot
All_Water_taxa_MT.df$station_km = as.numeric(as.character(All_Water_taxa_MT.df$station_km))


All_Water_taxa_MT.df$Sample_date = factor(All_Water_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

All_Water_taxa_MT.sum = Rmisc::summarySE(All_Water_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/All_Water_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(All_Water_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(All_Water_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(All_Water_taxa_MT.sum$fulltaxa)

```
```{r All_particles water MAG matching - MG + MT}

Results.df = read.csv("F:/Functional_R_analysis/Mantel_IndGenes_IndPP.csv", row.names = 1)

#### Metagenomes ####

#Extract relevant genes
All_particles_genes_MG.ls = sort(subset(Results_MG_particles.df, PhysicochemicalParameter!= "All_particles_uM")[,1])


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_All_particles = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% All_particles_genes_MG.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_All_particles)
#View(amoAClean_geneabund_KO_All_particles)

amoAClean_CO2CH4_tbl_long_All_particles <- amoAClean_geneabund_KO_All_particles %>%
  filter(KO %in% All_particles_genes_MG.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type!="Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 100, 0, 1)) %>% # 0.1% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

#Correct abundance
amoAClean_CO2CH4_tbl_long_All_particles$counts = amoAClean_CO2CH4_tbl_long_All_particles$counts / 1000

#Remove phylogenetic level info
amoAClean_CO2CH4_tbl_long_All_particles$domain = gsub("d__", "", amoAClean_CO2CH4_tbl_long_All_particles$domain)
amoAClean_CO2CH4_tbl_long_All_particles$phylum = gsub("p__", "", amoAClean_CO2CH4_tbl_long_All_particles$phylum)
amoAClean_CO2CH4_tbl_long_All_particles$class = gsub("c__", "", amoAClean_CO2CH4_tbl_long_All_particles$class)
amoAClean_CO2CH4_tbl_long_All_particles$order = gsub("o__", "", amoAClean_CO2CH4_tbl_long_All_particles$order)
amoAClean_CO2CH4_tbl_long_All_particles$family = gsub("f__", "", amoAClean_CO2CH4_tbl_long_All_particles$family)
amoAClean_CO2CH4_tbl_long_All_particles$genus = gsub("g__", "", amoAClean_CO2CH4_tbl_long_All_particles$genus)
amoAClean_CO2CH4_tbl_long_All_particles$species = gsub("s__", "", amoAClean_CO2CH4_tbl_long_All_particles$species)

#Add full taxa info as a single column
amoAClean_CO2CH4_tbl_long_All_particles$fulltaxa = paste0(amoAClean_CO2CH4_tbl_long_All_particles$domain, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$phylum, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$class, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$order, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$family, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$genus, "__",
                                                amoAClean_CO2CH4_tbl_long_All_particles$species, "__")


#Check how many unique genera
unique(amoAClean_CO2CH4_tbl_long_All_particles$fulltaxa)
unique(amoAClean_CO2CH4_tbl_long_All_particles$genome)

All_particles_taxa_MG.df = amoAClean_CO2CH4_tbl_long_All_particles %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(All_particles_taxa_MG.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_All_particles.csv")

#All_particles_taxa_MG.df = read.csv("F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_MG_All_particles.csv")

#Clean up for plot
All_particles_taxa_MG.df$station_km = as.numeric(as.character(All_particles_taxa_MG.df$station_km))


All_particles_taxa_MG.df$Sample_date = factor(All_particles_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

All_particles_taxa_MG.sum = Rmisc::summarySE(All_particles_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/All_particles_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(All_particles_taxa_MG.sum, aes(x = station_km, y = counts, colour = KO))+
#  geom_line()+
 # facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(All_particles_taxa_MG.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test[order(-test$N), ]

unique(All_particles_taxa_MG.df$fulltaxa)


#### Metatranscriptomes ####



#Extract relevant genes
All_particles_genes_MT.ls = sort(subset(Results_MT_particles.df, PhysicochemicalParameter!= "All_particles_uM")[,1])
#All_particles_genes_MG.ls = c("K00477", "K18933", "K24291")


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO_All_particles = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% All_particles_genes_MT.ls) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO_All_particles)
#View(amoAClean_geneabund_KO_All_particles)

amoAClean_CO2CH4_tbl_long_All_particles <- amoAClean_geneabund_KO_All_particles %>%
  filter(KO %in% All_particles_genes_MT.ls) %>% # only extract the CO2CH4 gene
  pivot_longer(cols = -c(KO, genome), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type!="Free_living") %>% # select only aquatic samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## XXX samples
  mutate(abundance = if_else(counts < 10, 0, 1)) %>% # 0.01% abundance
  group_by(KO, genome) %>% #group for occurrence
  mutate(occurrence = sum(abundance)/nsamples) %>% #calculate occurrence
  ungroup() %>%
  filter(occurrence > 0.1) %>% # filter for less than 1% occurrence
  distinct() %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-one")

unique(amoAClean_CO2CH4_tbl_long_All_particles$KO)

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_All_particles$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_All_particles$data_type)
amoAClean_CO2CH4_tbl_long_All_particles$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_All_particles$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG_All_particles.df <- spread(amoAClean_CO2CH4_tbl_long_All_particles[ , ! names(amoAClean_CO2CH4_tbl_long_All_particles) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_All_particles)
dim(CO2CH4_TG_All_particles.df)




#Calculate Transcripts per gene copy
CO2CH4_TG_All_particles.df$TranscriptsPerGenome = CO2CH4_TG_All_particles.df$Transcriptomes / CO2CH4_TG_All_particles.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG_All_particles.df = CO2CH4_TG_All_particles.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuAll_particlesly the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG_All_particles.lng = gather(CO2CH4_TG_All_particles.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG_All_particles.lng = subset(CO2CH4_TG_All_particles.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, domain, phylum, class, order, family, genus, species)
dim(CO2CH4_TG_All_particles.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG_All_particles.lng = subset(CO2CH4_TG_All_particles.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG_All_particles.lng = subset(CO2CH4_TG_All_particles.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG_All_particles.lng$counts = as.numeric(as.character(CO2CH4_TG_All_particles.lng$counts))
CO2CH4_TG_All_particles.lng$Associatednumber = as.character(CO2CH4_TG_All_particles.lng$Associatednumber)


#Correct abundance
CO2CH4_TG_All_particles.lng$counts = CO2CH4_TG_All_particles.lng$counts / 1000

#Remove phylogenetic level info
CO2CH4_TG_All_particles.lng$domain = gsub("d__", "", CO2CH4_TG_All_particles.lng$domain)
CO2CH4_TG_All_particles.lng$phylum = gsub("p__", "", CO2CH4_TG_All_particles.lng$phylum)
CO2CH4_TG_All_particles.lng$class = gsub("c__", "", CO2CH4_TG_All_particles.lng$class)
CO2CH4_TG_All_particles.lng$order = gsub("o__", "", CO2CH4_TG_All_particles.lng$order)
CO2CH4_TG_All_particles.lng$family = gsub("f__", "", CO2CH4_TG_All_particles.lng$family)
CO2CH4_TG_All_particles.lng$genus = gsub("g__", "", CO2CH4_TG_All_particles.lng$genus)
CO2CH4_TG_All_particles.lng$species = gsub("s__", "", CO2CH4_TG_All_particles.lng$species)

#Add full taxa info as a single column
CO2CH4_TG_All_particles.lng$fulltaxa = paste0(CO2CH4_TG_All_particles.lng$domain, "__",
                                                CO2CH4_TG_All_particles.lng$phylum, "__",
                                                CO2CH4_TG_All_particles.lng$class, "__",
                                                CO2CH4_TG_All_particles.lng$order, "__",
                                                CO2CH4_TG_All_particles.lng$family, "__",
                                                CO2CH4_TG_All_particles.lng$genus, "__",
                                                CO2CH4_TG_All_particles.lng$species, "__")


#Check how many unique genera
unique(CO2CH4_TG_All_particles.lng$fulltaxa)
unique(CO2CH4_TG_All_particles.lng$genome)

All_particles_taxa_MT.df = CO2CH4_TG_All_particles.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Keep for records
write.csv(All_particles_taxa_MT.df, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_All_particles_TG.csv")

All_particles_taxa_MT.df = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_All_particles_TG.csv")

#Clean up for plot
All_particles_taxa_MT.df$station_km = as.numeric(as.character(All_particles_taxa_MT.df$station_km))


All_particles_taxa_MT.df$Sample_date = factor(All_particles_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

All_particles_taxa_MT.sum = Rmisc::summarySE(All_particles_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#png("F:/Functional_R_analysis/Figures/All_particles_MAGCorr.png", units = "in", width = 20, height = 20, res = 80)

#ggplot(All_particles_taxa.sum, aes(x = station_km, y = counts, colour = KO))+
 # geom_line()+
  #facet_wrap(. ~ Sample_date + fulltaxa)+
  #scale_color_manual(values = expanded_cbbPalette)+
#  My_Theme

#dev.off()

#How many taxa does each KO have?
test = Rmisc::summarySE(All_particles_taxa_MT.sum, measurevar = "counts", groupvars = c("fulltaxa", "KO"))
#test2 = data.table::setorder(Rmisc::summarySE(test, measurevar = "counts", groupvars = c("KO")), cols = N)

test2[order(-test2$N), ]

unique(All_particles_taxa_MT.sum$fulltaxa)

```

####Extract KO correlated MAG taxa names for mOTU matching
```{r}

dim(Results_MG_water.df)
dim(Results_MG_particles.df)
dim(Results_MT_water.df)
dim(Results_MT_particles.df)

#### CSP ####

dim(CSP_taxa_MG.sum)
dim(CSP_taxa_MT.sum)

MG_MT_taxa.df = subset(CSP_taxa_MT.sum, fulltaxa %in% CSP_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_CSP.csv")


#### PTN ####

dim(PTN_taxa_MG.sum)
dim(PTN_taxa_MT.sum)

MG_MT_taxa.df = subset(PTN_taxa_MT.sum, fulltaxa %in% PTN_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_PTN.csv")


#### POC ####

dim(POC_taxa_MG.sum)
dim(POC_taxa_MT.sum)

MG_MT_taxa.df = subset(POC_taxa_MT.sum, fulltaxa %in% POC_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_POC.csv")


#### SPM ####

dim(SPM_taxa_MG.sum)
dim(SPM_taxa_MT.sum)

MG_MT_taxa.df = subset(SPM_taxa_MT.sum, fulltaxa %in% SPM_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_SPM.csv")


#### Salinity ####

dim(Sal_taxa.sum)
dim(Sal_taxa_MT.sum)

MG_MT_taxa.df = subset(Sal_taxa_MT.sum, fulltaxa %in% Sal_taxa.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_Sal.csv")


#### O2 ####

dim(O2_taxa_MG.sum)
dim(O2_taxa_MT.sum)

MG_MT_taxa.df = subset(O2_taxa_MT.sum, fulltaxa %in% O2_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_O2.csv")



#### dCO2 ####

dim(dCO2_taxa_MG.sum)
dim(dCO2_taxa_MT.sum)

MG_MT_taxa.df = subset(dCO2_taxa_MT.sum, fulltaxa %in% dCO2_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_dCO2.csv")

 
#### Temperature ####

dim(Temp_taxa_MG.sum)
dim(Temp_taxa_MT.sum)

MG_MT_taxa.df = subset(Temp_taxa_MT.sum, fulltaxa %in% Temp_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_Temp.csv")


#### Turbidity ####

dim(Turb_taxa_MG.sum)
dim(Turb_taxa_MT.sum)

MG_MT_taxa.df = subset(Turb_taxa_MT.sum, fulltaxa %in% Turb_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_Turb.csv")


#### Nitrate ####

dim(Nitrate_taxa_MG.sum)
dim(Nitrate_taxa_MT.sum)

MG_MT_taxa.df = subset(Nitrate_taxa_MT.sum, fulltaxa %in% Nitrate_taxa_MG.sum$fulltaxa)

unique(MG_MT_taxa.df$fulltaxa)
write.csv(MG_MT_taxa.df, "F:/Functional_R_analysis/MG_MT_taxa_Nitrate.csv")


```


#Comparisons PP vs microbiome - mantel - Figure 2 component

##Distances for metatranscriptomes
```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(stringr::str_detect(genus,"Nitros") & stringr::str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  dplyr::select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long_MT <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  dplyr::select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Associatednumber > 115) %>% # remove samples that have no metagenome samples
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long_MT$counts = amoAClean_CO2CH4_tbl_long_MT$counts / 1000


#View(amoAClean_CO2CH4_tbl_long_MT)
dim(amoAClean_CO2CH4_tbl_long_MT)

#write.csv(amoAClean_CO2CH4_tbl_long_MT, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_V3_TG.csv")

#amoAClean_CO2CH4_tbl_long_MT = read.csv( "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_V3_TG.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long_MT$Station = factor(amoAClean_CO2CH4_tbl_long_MT$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long_MT$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long_MT$Sample_date)

amoAClean_CO2CH4_tbl_long_MT$Sample_date = factor(amoAClean_CO2CH4_tbl_long_MT$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_MT$data_type)
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_MT$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)




#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes


#Convert from wide to long format
CO2CH4_TG.lng = gather(CO2CH4_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

####Calculate distances between samples####

MT_matrix_mantel <- CO2CH4_TG.df %>%
  filter(KO!="K10945" & KO!="K10946") %>%
  filter(TranscriptsPerGenome!="IncompleteMetagenome") %>% # Remove genes that had transcripts but not metagenome counts
  dplyr::select(Associatednumber, KO, TranscriptsPerGenome) %>% # select only relevant columns
  mutate(TranscriptsPerGenome = as.numeric(TranscriptsPerGenome)) %>% # convert the column to numeric
  pivot_wider(names_from = KO, values_from = TranscriptsPerGenome, values_fn = mean) %>% # long to wide
  magrittr::set_rownames(NULL) %>% #remove row names
  tibble::column_to_rownames('Associatednumber') %>% #change row name to sample number
  mutate_if(is.numeric, ~replace(., is.na(.), 0)) # replace NAs with 0
  

MT_matrix_mantel.dist = vegdist(MT_matrix_mantel, method = "bray")# Run distance calculation


#View(as.data.frame(as.matrix(MT_matrix_mantel.dist)))
dim(as.matrix(MT_matrix_mantel.dist))


```
##Distances for metagenomes
```{r}

####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  dplyr::select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long_MG <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  dplyr::select(!c(EC_Number, Pathway)) %>%
  left_join(metadata, by = c("sampleid" = "sampleid")) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  distinct()
amoAClean_CO2CH4_tbl_long_MG$counts = amoAClean_CO2CH4_tbl_long_MG$counts / 1000

#View(amoAClean_CO2CH4_tbl_long_MG)
dim(amoAClean_CO2CH4_tbl_long_MG)

#Reorder factors
amoAClean_CO2CH4_tbl_long_MG$Station = factor(amoAClean_CO2CH4_tbl_long_MG$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long_MG$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long_MG$Sample_date)

amoAClean_CO2CH4_tbl_long_MG$Sample_date = factor(amoAClean_CO2CH4_tbl_long_MG$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_MG$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_MG$data_type)

dim(amoAClean_CO2CH4_tbl_long_MG)



####Calculate distances between samples####


MG_matrix_mantel <- amoAClean_CO2CH4_tbl_long_MG %>%
  filter(KO!="K10945" & KO!="K10946") %>%
  dplyr::select(Associatednumber, KO, counts) %>%
  pivot_wider(names_from = KO, values_from = counts, values_fn = mean) %>%
  magrittr::set_rownames(NULL) %>%
  tibble::column_to_rownames('Associatednumber')


MG_matrix_mantel.dist = vegdist(MG_matrix_mantel, method = "bray")


#View(as.data.frame(as.matrix(MG_matrix_mantel.dist)))
dim(as.matrix(MG_matrix_mantel.dist))

  
```
##Distances for mOTUs
```{r }

motus_final_taxa_metadata <- readRDS(file="D:/Functional_R_analysis/motus_final_taxa_metadata.RDS")

#How many hits/reads per sample?
motus_final_taxa_metadata %>%
  filter(data_type == "METAG") %>%
  dplyr::group_by(sampleid) %>%
  summarise(total = sum(counts)) %>%
  arrange(total, decreasing = T) %>%
  print(n = 180)
#How many hits/reads per sample? - so few reads it's not worth running...
motus_final_taxa_metadata %>%
  filter(data_type == "METAT") %>%
  dplyr::group_by(sampleid) %>%
  summarise(total = sum(counts)) %>%
  arrange(total, decreasing = T) %>%
  print(n = 180)



##Lets check out experimental scheme

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date))


Stupidworkaround.df = read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", sep = ";")
dim(motus_final_taxa_metadata)

i=1
x=1
for (i in 1:length(Stupidworkaround.df$BioSample)) {
  for (x in 1:length(motus_final_taxa_metadata$BioSample)) {
  if(grepl(Stupidworkaround.df$BioSample[i], motus_final_taxa_metadata$BioSample[x]) == T) {
    
    motus_final_taxa_metadata$Associatednumber[x] = Stupidworkaround.df$Associatednumber[i]
    
    print(paste0("Matching ", motus_final_taxa_metadata$BioSample[x], " with ", Stupidworkaround.df$BioSample[i]))
    
  }
  }
}


##First we want to covert our data back to an OTU table 
motus_MG_df <- motus_final_taxa_metadata %>%
  filter(data_type == "METAG") %>%
  dplyr::select(mOTU, Associatednumber, counts) %>%
  transform(counts = as.numeric(counts)) %>%
  pivot_wider(names_from="mOTU", values_from="counts", values_fill = 0) %>% 
  column_to_rownames("Associatednumber") %>%
  as.data.frame()

motus_MT_df <- motus_final_taxa_metadata %>%
  filter(data_type == "METAT") %>%
  dplyr::select(mOTU, Associatednumber, counts) %>%
  transform(counts = as.numeric(counts)) %>%
  pivot_wider(names_from="mOTU", values_from="counts", values_fill = 0) %>% 
  column_to_rownames("Associatednumber") %>%
  as.data.frame()

motus_MG_df_v0 = motus_MG_df
motus_MT_df_v0 = motus_MT_df




#Calculate distance
motus_MG_matrix_mantel.dist = avgdist(motus_MG_df, sample = 2000, iterations = 100, dmethod = "bray", distfun = vegdist) # only for motus
motus_MT_matrix_mantel.dist = avgdist(motus_MT_df, sample = 2000, iterations = 100, dmethod = "bray", distfun = vegdist) # only for motus


```


##Set up physicochemical characteristics
```{r}

#Read in new PP dataframe as a clean data frame
Physicochem.df = readxl::read_xlsx("D:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Make relevant columns numeric
#Physicochem.df = Physicochem.df %>% mutate_at(c('SPM_mgperL', 'POC_mgperL'), as.numeric)
Physicochem.df$SPM_mgperL = as.numeric(Physicochem.df$SPM_mgperL)
Physicochem.df$POC_mgperL = as.numeric(Physicochem.df$POC_mgperL)
Physicochem.df$PTC_mgperL = as.numeric(Physicochem.df$PTC_mgperL)
Physicochem.df$PTN_mgperL = as.numeric(Physicochem.df$PTN_mgperL)
Physicochem.df$PTH_mgperL = as.numeric(Physicochem.df$PTH_mgperL)
Physicochem.df$TEP_um2perL = as.numeric(Physicochem.df$TEP_um2perL)
Physicochem.df$CSP_um2perL = as.numeric(Physicochem.df$CSP_um2perL)
Physicochem.df$ParticleArea_um2perL = as.numeric(Physicochem.df$ParticleArea_um2perL)


#Add PA PP to Free-living rows 

#Extract sample numbers for FL - MG
FL_samples.df = Physicochem.df %>%
  filter(Sample_type == "Free_living")
PA_PP.ls = c("SPM_mgperL", "POC_mgperL", "PTC_mgperL", "PTN_mgperL", "PTH_mgperL", "TEP_um2perL", "CSP_um2perL", "ParticleArea_um2perL")
count = 1
i=92
x="TEP_um2perL"
for (i in 1:length(Physicochem.df$Associatednumber)) {
  if (grepl(Physicochem.df$Sample_type[i], "Free_living") == T ) {
    #Bug hunting
    #print(paste0("Match ",count, " found"))
    PA_sub.df = subset(Physicochem.df, Sample_type!="Free_living" & 
                         station_km == Physicochem.df$station_km[i] & 
                         Sample_date == Physicochem.df$Sample_date[i])
    for (x in PA_PP.ls) {
      
      print(x)
      #Bug hunting
      #print(paste0("Matching ", x))
      mean.tmp = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
      #Bug hunt
      print(paste0("Getting ", mean.tmp))
      Physicochem.df[i,x] = mean(unlist(PA_sub.df[x]), na.rm = TRUE)
    }
    count = count + 1
  }
}

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DOC_uM.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

colnames(PP_totest.df)
#Extract relevant columns
PP_totest.df = Physicochem.df  %>% 
  dplyr::select(all_of(PP_totest.ls))

#Make sure rownames have been preserved
rownames(PP_totest.df)
dim(PP_totest.df)


#Apply row numbers from sample IDs
rownames(PP_totest.df) = PP_totest.df$Associatednumber
PP_totest.df$Associatednumber = NULL


#Add density data - calculated from dry-weight and area
PP_totest.df$Density_gpercm3 = (as.numeric(PP_totest.df$SPM_mgperL) / (as.numeric(PP_totest.df$ParticleArea_um2perL))) * 10^5

#Flip so columns are samples for dissimilarity assessment
PP_totest.df = t(PP_totest.df)

#Get sample names for microbiome comparison
PP_totest.ls = rownames(PP_totest.df)



```
##Calculate dissimilarity with mantel tests
###Whole community - Attic
```{r}

####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_matrix_mantel.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_matrix_mantel.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>% # read in data as a data frame
  select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
mantel(MG_matrix_mantel_sub.dist, MT_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.1273
#      Significance: 0.048
#Significantly similar






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_matrix_mantel.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_matrix_mantel.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>% # read in data as a data frame
  select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
mantel(MG_matrix_mantel_sub.dist, motus_MG_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.3968
#      Significance: 0.001
#This means that they are very similar






####MT - motus ####



#Extract sample numbers
MT_samples = data.frame(MT_samples = sort(as.numeric(colnames(as.matrix(MT_matrix_mantel.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MT_matrix_mantel.dist)))))


#Compare and put into dataframe
MT_samples$motu_match = match(MT_samples$MT_sample, motus_samples$motus_samples)
motus_samples$MT_match = match(motus_samples$motus_samples, MT_samples$MT_samples)


#Extract only matching samples
MT_motu_matches = subset(MT_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>% # read in data as a data frame
  select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
mantel(MT_matrix_mantel_sub.dist, motus_MT_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.1753
#      Significance: 0.073
#This means that they are very similar



####MG vs Individual PP ####
#Run loop for motus vs individual physicochemical parameters
Results_MG.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)
i=1
x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_matrix_mantel.dist)))))


    #Compare and put into dataframe
    PP_samples$MG_match = match(PP_samples$PP_sample, MG_samples$MG_sample)
    MG_samples$PP_match = match(MG_samples$MG_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_matches = subset(PP_samples, MG_match!="NA")


    #Subset distance matrices by matching samples
    MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>% # read in data as a data frame
      select(paste0(PP_MG_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      select(paste0(PP_MG_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG.df = rbind(Results_MG.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }


#Check results and clean up dataframe
Results_MG.df = Results_MG.df[-1,]
Results_MG.df

#Check if each PP was included
unique(Results_MG.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_sign.df = subset(Results_MG.df, pvalue < 0.05)
dim(Results_MG_sign.df)
Results_MG_sign.df



####motu_MG vs Individual PP ####

#Run loop for motus vs individual physicochemical parameters
Results_motus_MG.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)
i=1
x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_samples = data.frame(motus_MG_sample = sort(as.numeric(colnames(as.matrix(motus_MG_matrix_mantel.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MG_match = match(PP_samples$PP_sample, motus_MG_samples$motus_MG_sample)
    motus_MG_samples$PP_match = match(motus_MG_samples$motus_MG_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_matches = subset(PP_samples, motus_MG_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_matrix_mantel_sub.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>% # read in data as a data frame
      select(paste0(PP_motus_MG_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      select(paste0(PP_motus_MG_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG.df = rbind(Results_motus_MG.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  


#Check results and clean up dataframe
Results_motus_MG.df = Results_motus_MG.df[-1,]
Results_motus_MG.df

#Check if each PP was included
unique(Results_motus_MG.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_sign.df = subset(Results_motus_MG.df, pvalue < 0.05)
dim(Results_motus_MG.df)
Results_motus_MG_sign.df



####MT vs Individual PP ####
#Run loop for MTs vs individual physicochemical parameters
Results_MT.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)
i=1
x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_matrix_mantel.dist)))))


    #Compare and put into dataframe
    PP_samples$MT_match = match(PP_samples$PP_sample, MT_samples$MT_sample)
    MT_samples$PP_match = match(MT_samples$MT_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_matches = subset(PP_samples, MT_match!="NA")


    #Subset distance matrices by matching samples
    MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>% # read in data as a data frame
      select(paste0(PP_MT_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      select(paste0(PP_MT_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT.df = rbind(Results_MT.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT.df = Results_MT.df[-1,]
Results_MT.df

#Check if each PP was included
unique(Results_MT.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_sign.df = subset(Results_MT.df, pvalue < 0.05)
dim(Results_MT_sign.df)
Results_MT_sign.df




####motu_MT vs Individual PP ####

#Run loop for motus vs individual physicochemical parameters
Results_motus_MT.df = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)
i=1
x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = dist(t(PP.tmp))
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MT_samples = data.frame(motus_MT_sample = sort(as.numeric(colnames(as.matrix(motus_MT_matrix_mantel.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MT_match = match(PP_samples$PP_sample, motus_MT_samples$motus_MT_sample)
    motus_MT_samples$PP_match = match(motus_MT_samples$motus_MT_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MT_matches = subset(PP_samples, motus_MT_match!="NA")


    #Subset distance matrices by matching samples
    motus_MT_matrix_mantel_sub.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>% # read in data as a data frame
      select(paste0(PP_motus_MT_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      select(paste0(PP_motus_MT_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MT_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MT_matrix_mantel_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_TranscriptsPerGene",
                             "Community_type" = "Whole",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MT.df = rbind(Results_motus_MT.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  


#Check results and clean up dataframe
Results_motus_MT.df = Results_motus_MT.df[-1,]
Results_motus_MT.df

#Check if each PP was included
unique(Results_motus_MT.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MT_sign.df = subset(Results_motus_MT.df, pvalue < 0.05)
dim(Results_motus_MT_sign.df)
Results_motus_MT_sign.df


```

###Free_living
```{r}

####Subset to only Free_living ####

#Extract sample numbers for FL - MG
FL_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MG_matrix_mantel.dist))))
#Extract only FL samples
MG_FL.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(FL_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% FL_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for FL - mOTUs MG
FL_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MG_matrix_mantel.dist))))
#Extract only FL samples
motus_MG_FL.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(FL_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% FL_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid


#Extract sample numbers for FL - MT
FL_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MT_matrix_mantel.dist))))
#Extract only FL samples
MT_FL.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(FL_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% FL_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for FL - mOTUs MT
FL_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MT_matrix_mantel.dist))))
#Extract only FL samples
motus_MT_FL.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(FL_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% FL_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid






####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_FL.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_FL.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_FL_sub.dist = as.data.frame(as.matrix(MG_FL.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_FL_sub.dist = as.data.frame(as.matrix(MT_FL.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_FL_sub.dist, MT_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.7475
#      Significance: 0.001






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_FL.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_FL.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_FL_sub.dist = as.data.frame(as.matrix(MG_FL.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_FL_sub.dist = as.data.frame(as.matrix(motus_MG_FL.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_FL_sub.dist, motus_MG_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.822
#      Significance: 0.001  






####MT - motus ####



#Extract sample numbers
MT_samples = data.frame(MT_samples = sort(as.numeric(colnames(as.matrix(MT_FL.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MT_FL.dist)))))


#Compare and put into dataframe
MT_samples$motu_match = match(MT_samples$MT_sample, motus_samples$motus_samples)
motus_samples$MT_match = match(motus_samples$motus_samples, MT_samples$MT_samples)


#Extract only matching samples
MT_motu_matches = subset(MT_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MT_FL_sub.dist = as.data.frame(as.matrix(MT_FL.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MT_FL_sub.dist = as.data.frame(as.matrix(motus_MT_FL.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_motu_matches$MT_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_motu_matches$MT_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MT_FL_sub.dist, motus_MT_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.4907 
#      Significance: 0.021 





####MG vs Individual PP ####
#Run loop for MG_FLs vs individual physicochemical parameters
Results_MG_FL.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   dplyr::mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_FL_samples = data.frame(MG_FL_sample = sort(as.numeric(colnames(as.matrix(MG_FL.dist)))))


    #Compare and put into dataframe
    PP_samples$MG_FL_match = match(PP_samples$PP_sample, MG_FL_samples$MG_FL_sample)
    MG_FL_samples$PP_match = match(MG_FL_samples$MG_FL_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_FL_matches = subset(PP_samples, MG_FL_match!="NA")


    #Subset distance matrices by matching samples
    MG_FL_sub.dist = as.data.frame(as.matrix(MG_FL.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MG_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MG_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_FL.df = rbind(Results_MG_FL.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MG_FL.df = Results_MG_FL.df[-1,]
Results_MG_FL.df

#Check if each PP was included
unique(Results_MG_FL.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_FL_sign.df = subset(Results_MG_FL.df, pvalue < 0.05)
dim(Results_MG_FL_sign.df)
Results_MG_FL_sign.df





####motus_MG vs Individual PP ####
#Run loop for motus_MG_FLs vs individual physicochemical parameters
Results_motus_MG_FL.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_FL_samples = data.frame(motus_MG_FL_sample = sort(as.numeric(colnames(as.matrix(motus_MG_FL.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MG_FL_match = match(PP_samples$PP_sample, motus_MG_FL_samples$motus_MG_FL_sample)
    motus_MG_FL_samples$PP_match = match(motus_MG_FL_samples$motus_MG_FL_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_FL_matches = subset(PP_samples, motus_MG_FL_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_FL_sub.dist = as.data.frame(as.matrix(motus_MG_FL.dist)) %>% # read in data as a data frame
     dplyr::select(paste0(PP_motus_MG_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG_FL.df = rbind(Results_motus_MG_FL.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MG_FL.df = Results_motus_MG_FL.df[-1,]
Results_motus_MG_FL.df

#Check if each PP was included
unique(Results_motus_MG_FL.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_FL_sign.df = subset(Results_motus_MG_FL.df, pvalue < 0.05)
dim(Results_motus_MG_FL_sign.df)
Results_motus_MG_FL_sign.df





####MT vs Individual PP ####
#Run loop for MT_FLs vs individual physicochemical parameters
Results_MT_FL.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_FL_samples = data.frame(MT_FL_sample = sort(as.numeric(colnames(as.matrix(MT_FL.dist)))))


    #Compare and put into dataframe
    PP_samples$MT_FL_match = match(PP_samples$PP_sample, MT_FL_samples$MT_FL_sample)
    MT_FL_samples$PP_match = match(MT_FL_samples$MT_FL_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_FL_matches = subset(PP_samples, MT_FL_match!="NA")


    #Subset distance matrices by matching samples
    MT_FL_sub.dist = as.data.frame(as.matrix(MT_FL.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MT_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MT_FL_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_FL_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_FL_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Free-living",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_FL.df = rbind(Results_MT_FL.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT_FL.df = Results_MT_FL.df[-1,]
Results_MT_FL.df

#Check if each PP was included
unique(Results_MT_FL.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_FL_sign.df = subset(Results_MT_FL.df, pvalue < 0.05)
dim(Results_MT_FL_sign.df)
Results_MT_FL_sign.df






```

###Particle associated
```{r}

####Remove Free_living ####

#Extract sample numbers for PA - MG
PA_samples.ls = Physicochem.df %>%
  filter(Sample_type!= "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MG_matrix_mantel.dist))))
#Extract only PA samples
MG_PA.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(PA_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% PA_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for PA - mOTUs MG
PA_samples.ls = Physicochem.df %>%
  filter(Sample_type!= "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MG_matrix_mantel.dist))))
#Extract only PA samples
motus_MG_PA.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(PA_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% PA_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid


#Extract sample numbers for PA - MT
PA_samples.ls = Physicochem.df %>%
  filter(Sample_type!= "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MT_matrix_mantel.dist))))
#Extract only PA samples
MT_PA.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(PA_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% PA_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for PA - mOTUs MT
PA_samples.ls = Physicochem.df %>%
  filter(Sample_type!= "Free_living") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MT_matrix_mantel.dist))))
#Extract only PA samples
motus_MT_PA.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(PA_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% PA_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid






####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_PA.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_PA.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_PA_sub.dist = as.data.frame(as.matrix(MG_PA.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_PA_sub.dist = as.data.frame(as.matrix(MT_PA.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_PA_sub.dist, MT_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.281
#      Significance: 0.001 






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_PA.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_PA.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_PA_sub.dist = as.data.frame(as.matrix(MG_PA.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_PA_sub.dist = as.data.frame(as.matrix(motus_MG_PA.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_PA_sub.dist, motus_MG_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.7401 
#      Significance: 0.001









####MG vs Individual PP ####
#Run loop for MG_PAs vs individual physicochemical parameters
Results_MG_PA.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=24
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_PA_samples = data.frame(MG_PA_sample = sort(as.numeric(colnames(as.matrix(MG_PA.dist)))))


    #Compare and put into dataframe
    PP_samples$MG_PA_match = match(PP_samples$PP_sample, MG_PA_samples$MG_PA_sample)
    MG_PA_samples$PP_match = match(MG_PA_samples$MG_PA_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_PA_matches = subset(PP_samples, MG_PA_match!="NA")


    #Subset distance matrices by matching samples
    MG_PA_sub.dist = as.data.frame(as.matrix(MG_PA.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MG_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MG_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    #dim(MG_PA_sub.dist)
    #dim(PP_sub.tmp)
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_PA.df = rbind(Results_MG_PA.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MG_PA.df = Results_MG_PA.df[-1,]
Results_MG_PA.df

#Check if each PP was included
unique(Results_MG_PA.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_PA_sign.df = subset(Results_MG_PA.df, pvalue < 0.05)
dim(Results_MG_PA_sign.df)
Results_MG_PA_sign.df





####motus_MG vs Individual PP ####
#Run loop for motus_MG_PAs vs individual physicochemical parameters
Results_motus_MG_PA.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_PA_samples = data.frame(motus_MG_PA_sample = sort(as.numeric(colnames(as.matrix(motus_MG_PA.dist)))))


    #Compare and put into dataframe
    PP_samples$motus_MG_PA_match = match(PP_samples$PP_sample, motus_MG_PA_samples$motus_MG_PA_sample)
    motus_MG_PA_samples$PP_match = match(motus_MG_PA_samples$motus_MG_PA_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_PA_matches = subset(PP_samples, motus_MG_PA_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_PA_sub.dist = as.data.frame(as.matrix(motus_MG_PA.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG_PA.df = rbind(Results_motus_MG_PA.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MG_PA.df = Results_motus_MG_PA.df[-1,]
Results_motus_MG_PA.df

#Check if each PP was included
unique(Results_motus_MG_PA.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_PA_sign.df = subset(Results_motus_MG_PA.df, pvalue < 0.05)
dim(Results_motus_MG_PA_sign.df)
Results_motus_MG_PA_sign.df





####MT vs Individual PP ####
#Run loop for MT_PAs vs individual physicochemical parameters
Results_MT_PA.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_PA_samples = data.frame(MT_PA_sample = sort(as.numeric(colnames(as.matrix(MT_PA.dist)))))


    #Compare and put into dataframe
    PP_samples$MT_PA_match = match(PP_samples$PP_sample, MT_PA_samples$MT_PA_sample)
    MT_PA_samples$PP_match = match(MT_PA_samples$MT_PA_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_PA_matches = subset(PP_samples, MT_PA_match!="NA")


    #Subset distance matrices by matching samples
    MT_PA_sub.dist = as.data.frame(as.matrix(MT_PA.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MT_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MT_PA_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_PA_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_PA_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Particle_Associated",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_PA.df = rbind(Results_MT_PA.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT_PA.df = Results_MT_PA.df[-1,]
Results_MT_PA.df

#Check if each PP was included
unique(Results_MT_PA.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_PA_sign.df = subset(Results_MT_PA.df, pvalue < 0.05)
dim(Results_MT_PA_sign.df)
Results_MT_PA_sign.df








```

###Suspended
```{r}

####Select Suspended (Light) fraction ####

#Extract sample numbers for Susp - MG
Susp_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Light_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MG_matrix_mantel.dist))))
#Extract only Susp samples
MG_Susp.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Susp_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Susp_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for Susp - mOTUs MG
Susp_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Light_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MG_matrix_mantel.dist))))
#Extract only Susp samples
motus_MG_Susp.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Susp_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Susp_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid


#Extract sample numbers for Susp - MT
Susp_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Light_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MT_matrix_mantel.dist))))
#Extract only Susp samples
MT_Susp.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Susp_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Susp_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for Susp - mOTUs MT
Susp_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Light_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MT_matrix_mantel.dist))))
#Extract only Susp samples
motus_MT_Susp.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Susp_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Susp_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid






####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_Susp.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_Susp.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_Susp_sub.dist = as.data.frame(as.matrix(MG_Susp.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_Susp_sub.dist = as.data.frame(as.matrix(MT_Susp.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_Susp_sub.dist, MT_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.3711
#      Significance: 0.001






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_Susp.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_Susp.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_Susp_sub.dist = as.data.frame(as.matrix(MG_Susp.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_Susp_sub.dist = as.data.frame(as.matrix(motus_MG_Susp.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_Susp_sub.dist, motus_MG_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.7275 
#      Significance: 0.001






####MG vs Individual PP ####
#Run loop for MG_Susps vs individual physicochemical Susprameters
Results_MG_Susp.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_Susp_samples = data.frame(MG_Susp_sample = sort(as.numeric(colnames(as.matrix(MG_Susp.dist)))))


    #ComSuspre and put into dataframe
    PP_samples$MG_Susp_match = match(PP_samples$PP_sample, MG_Susp_samples$MG_Susp_sample)
    MG_Susp_samples$PP_match = match(MG_Susp_samples$MG_Susp_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_Susp_matches = subset(PP_samples, MG_Susp_match!="NA")


    #Subset distance matrices by matching samples
    MG_Susp_sub.dist = as.data.frame(as.matrix(MG_Susp.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MG_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MG_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_Susp.df = rbind(Results_MG_Susp.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Susprameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MG_Susp.df = Results_MG_Susp.df[-1,]
Results_MG_Susp.df

#Check if each PP was included
unique(Results_MG_Susp.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_Susp_sign.df = subset(Results_MG_Susp.df, pvalue < 0.05)
dim(Results_MG_Susp_sign.df)
Results_MG_Susp_sign.df





####motus_MG vs Individual PP ####
#Run loop for motus_MG_Susps vs individual physicochemical Susprameters
Results_motus_MG_Susp.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_Susp_samples = data.frame(motus_MG_Susp_sample = sort(as.numeric(colnames(as.matrix(motus_MG_Susp.dist)))))


    #ComSuspre and put into dataframe
    PP_samples$motus_MG_Susp_match = match(PP_samples$PP_sample, motus_MG_Susp_samples$motus_MG_Susp_sample)
    motus_MG_Susp_samples$PP_match = match(motus_MG_Susp_samples$motus_MG_Susp_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_Susp_matches = subset(PP_samples, motus_MG_Susp_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_Susp_sub.dist = as.data.frame(as.matrix(motus_MG_Susp.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG_Susp.df = rbind(Results_motus_MG_Susp.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Susprameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MG_Susp.df = Results_motus_MG_Susp.df[-1,]
Results_motus_MG_Susp.df

#Check if each PP was included
unique(Results_motus_MG_Susp.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_Susp_sign.df = subset(Results_motus_MG_Susp.df, pvalue < 0.05)
dim(Results_motus_MG_Susp_sign.df)
Results_motus_MG_Susp_sign.df





####MT vs Individual PP ####
#Run loop for MT_Susps vs individual physicochemical Susprameters
Results_MT_Susp.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_Susp_samples = data.frame(MT_Susp_sample = sort(as.numeric(colnames(as.matrix(MT_Susp.dist)))))


    #ComSuspre and put into dataframe
    PP_samples$MT_Susp_match = match(PP_samples$PP_sample, MT_Susp_samples$MT_Susp_sample)
    MT_Susp_samples$PP_match = match(MT_Susp_samples$MT_Susp_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_Susp_matches = subset(PP_samples, MT_Susp_match!="NA")


    #Subset distance matrices by matching samples
    MT_Susp_sub.dist = as.data.frame(as.matrix(MT_Susp.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MT_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MT_Susp_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_Susp_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_Susp_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Suspended",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_Susp.df = rbind(Results_MT_Susp.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Susprameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT_Susp.df = Results_MT_Susp.df[-1,]
Results_MT_Susp.df

#Check if each PP was included
unique(Results_MT_Susp.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_Susp_sign.df = subset(Results_MT_Susp.df, pvalue < 0.05)
dim(Results_MT_Susp_sign.df)
Results_MT_Susp_sign.df







```

###Sinking
```{r}

####Select Sinking (Light) fraction ####

#Extract sample numbers for Sink - MG
Sink_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Heavy_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MG_matrix_mantel.dist))))
#Extract only Sink samples
MG_Sink.dist = as.data.frame(as.matrix(MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Sink_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Sink_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for Sink - mOTUs MG
Sink_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Heavy_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MG_matrix_mantel.dist))))
#Extract only Sink samples
motus_MG_Sink.dist = as.data.frame(as.matrix(motus_MG_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Sink_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Sink_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid


#Extract sample numbers for Sink - MT
Sink_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Heavy_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(MT_matrix_mantel.dist))))
#Extract only Sink samples
MT_Sink.dist = as.data.frame(as.matrix(MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Sink_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Sink_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

#Extract sample numbers for Sink - mOTUs MT
Sink_samples.ls = Physicochem.df %>%
  filter(Sample_type == "Heavy_fraction") %>%
  dplyr::select(Associatednumber) %>%
  filter(Associatednumber %in% colnames(as.data.frame(as.matrix(motus_MT_matrix_mantel.dist))))
#Extract only Sink samples
motus_MT_Sink.dist = as.data.frame(as.matrix(motus_MT_matrix_mantel.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(Sink_samples.ls$Associatednumber)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% Sink_samples.ls$Associatednumber) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid






####MG - MT ####

#Extract sample numbers
MG_samples = data.frame(MG_sample = sort(as.numeric(colnames(as.matrix(MG_Sink.dist)))))
MT_samples = data.frame(MT_sample = sort(as.numeric(colnames(as.matrix(MT_Sink.dist)))))


#Compare and put into dataframe
MG_samples$MT_match = match(MG_samples$MG_sample, MT_samples$MT_sample)
MT_samples$MG_match = match(MT_samples$MT_sample, MG_samples$MG_sample)


#Extract only matching samples
MT_MG_matches = subset(MG_samples, MT_match!="NA")


#Subset distance matrices by actually matching samples
MG_Sink_sub.dist = as.data.frame(as.matrix(MG_Sink.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

MT_Sink_sub.dist = as.data.frame(as.matrix(MT_Sink.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MT_MG_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MT_MG_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_Sink_sub.dist, MT_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.2481
#      Significance: 0.001 






####MG - motus ####


#Extract sample numbers
MG_samples = data.frame(MG_samples = sort(as.numeric(colnames(as.matrix(MG_Sink.dist)))))
motus_samples = data.frame(motus_samples = sort(as.numeric(colnames(as.matrix(motus_MG_Sink.dist)))))


#Compare and put into dataframe
MG_samples$motu_match = match(MG_samples$MG_sample, motus_samples$motus_samples)
motus_samples$MG_match = match(motus_samples$motus_samples, MG_samples$MG_samples)


#Extract only matching samples
MG_motu_matches = subset(MG_samples, motu_match!="NA")


#Subset distance matrices by actually matching samples
MG_Sink_sub.dist = as.data.frame(as.matrix(MG_Sink.dist)) %>% # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid

motus_MG_Sink_sub.dist = as.data.frame(as.matrix(motus_MG_Sink.dist)) %>%  # read in data as a data frame
  dplyr::select(paste0(MG_motu_matches$MG_sample)) %>% # keep only matching column
  tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
  filter(rowsampleid %in% MG_motu_matches$MG_sample) %>% # filter for only matching samples
  tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid



#Whole microbial vs each other
vegan::mantel(MG_Sink_sub.dist, motus_MG_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
#Mantel statistic r: 0.739
#      Significance: 0.001






####MG vs Individual PP ####

#Run loop for MG_Sinks vs individual physicochemical Sinkrameters
Results_MG_Sink.df = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MG_Sink_samples = data.frame(MG_Sink_sample = sort(as.numeric(colnames(as.matrix(MG_Sink.dist)))))


    #Compare and put into dataframe
    PP_samples$MG_Sink_match = match(PP_samples$PP_sample, MG_Sink_samples$MG_Sink_sample)
    MG_Sink_samples$PP_match = match(MG_Sink_samples$MG_Sink_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MG_Sink_matches = subset(PP_samples, MG_Sink_match!="NA")


    #Subset distance matrices by matching samples
    MG_Sink_sub.dist = as.data.frame(as.matrix(MG_Sink.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MG_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MG_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MG_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MG_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MG_Sink.df = rbind(Results_MG_Sink.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MG_Sink.df = Results_MG_Sink.df[-1,]
Results_MG_Sink.df

#Check if each PP was included
unique(Results_MG_Sink.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MG_Sink_sign.df = subset(Results_MG_Sink.df, pvalue < 0.05)
dim(Results_MG_Sink_sign.df)
Results_MG_Sink_sign.df





####motus_MG vs Individual PP ####
#Run loop for motus_MG_Sinks vs individual physicochemical Sinkrameters
Results_motus_MG_Sink.df = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=1
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    motus_MG_Sink_samples = data.frame(motus_MG_Sink_sample = sort(as.numeric(colnames(as.matrix(motus_MG_Sink.dist)))))


    #ComSinkre and put into dataframe
    PP_samples$motus_MG_Sink_match = match(PP_samples$PP_sample, motus_MG_Sink_samples$motus_MG_Sink_sample)
    motus_MG_Sink_samples$PP_match = match(motus_MG_Sink_samples$motus_MG_Sink_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_motus_MG_Sink_matches = subset(PP_samples, motus_MG_Sink_match!="NA")


    #Subset distance matrices by matching samples
    motus_MG_Sink_sub.dist = as.data.frame(as.matrix(motus_MG_Sink.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_motus_MG_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_motus_MG_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, motus_MG_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTU_Metagenomes",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_motus_MG_Sink.df = rbind(Results_motus_MG_Sink.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Sinkrameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_motus_MG_Sink.df = Results_motus_MG_Sink.df[-1,]
Results_motus_MG_Sink.df

#Check if each PP was included
unique(Results_motus_MG_Sink.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_motus_MG_Sink_sign.df = subset(Results_motus_MG_Sink.df, pvalue < 0.05)
dim(Results_motus_MG_Sink_sign.df)
Results_motus_MG_Sink_sign.df





####MT vs Individual PP ####
#Run loop for MT_Sinks vs individual physicochemical Sinkrameters
Results_MT_Sink.df = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = "DELETEME",
                             "Mantel_Rvalue" = 9999,
                             "pvalue" = 9999)
PP_loop.df = PP_totest.df[-1,]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)

x=17
for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    
    #Remove all columns that have NAs
    PP.tmp <- as.data.frame(PP_loop.df[x,][,colSums(is.na(PP_loop.df[x,]))<nrow(PP_loop.df[x,])])
    
    
    #Make PP dissimilarity matrix
    PP.dist = vegdist(t(PP.tmp))
    
    
    #Make sure to only include samples that are present in both PP and microbiome dissimialrity matrices
    
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(colnames(as.matrix(PP.dist)))))
    MT_Sink_samples = data.frame(MT_Sink_sample = sort(as.numeric(colnames(as.matrix(MT_Sink.dist)))))


    #ComSinkre and put into dataframe
    PP_samples$MT_Sink_match = match(PP_samples$PP_sample, MT_Sink_samples$MT_Sink_sample)
    MT_Sink_samples$PP_match = match(MT_Sink_samples$MT_Sink_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_MT_Sink_matches = subset(PP_samples, MT_Sink_match!="NA")


    #Subset distance matrices by matching samples
    MT_Sink_sub.dist = as.data.frame(as.matrix(MT_Sink.dist)) %>% # read in data as a data frame
      dplyr::select(paste0(PP_MT_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = as.data.frame(as.matrix(PP.dist)) %>%  # read in data as a data frame
      dplyr::select(paste0(PP_MT_Sink_matches$PP_sample)) %>% # keep only matching column
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_MT_Sink_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    
    #Run mantel test
    test.tmp = vegan::mantel(PP_sub.tmp, MT_Sink_sub.dist, method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Community_type" = "Sinking",
                             "PhysicochemicalParameter" = PP.name,
                             "pvalue" = test.tmp$signif,
                             "Mantel_Rvalue" = test.tmp$statistic)
    
    #Combine results with previous dataframe
    Results_MT_Sink.df = rbind(Results_MT_Sink.df, Results.tmp)
    
    print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical Sinkrameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  }
  
  
  


#Check results and clean up dataframe
Results_MT_Sink.df = Results_MT_Sink.df[-1,]
Results_MT_Sink.df

#Check if each PP was included
unique(Results_MT_Sink.df$PhysicochemicalParameter)

#Subset to only significant gene hits
Results_MT_Sink_sign.df = subset(Results_MT_Sink.df, pvalue < 0.05)
dim(Results_MT_Sink_sign.df)
Results_MT_Sink_sign.df






```




##Make plots

```{r}
####Combine all results above into one dataframe and extract significant ones ####
Mantel_IndPP_Comm.df = rbind(#Results_MG.df, Results_motus_MG.df, Results_MT.df, Results_motus_MT.df,
                             Results_MG_FL.df, Results_motus_MG_FL.df, Results_MT_FL.df,# Results_motus_MT_FL.df,
                             #Results_MG_PA.df, Results_motus_MG_PA.df, Results_MT_PA.df, #Results_motus_MT_PA.df,
                             Results_MG_Susp.df, Results_motus_MG_Susp.df, Results_MT_Susp.df,# Results_motus_MT_Susp.df,
                             Results_MG_Sink.df, Results_motus_MG_Sink.df, Results_MT_Sink.df #Results_motus_MT_Sink.df
                             )
#Remove DELETEME rows
Mantel_IndPP_Comm.df = subset(Mantel_IndPP_Comm.df, PhysicochemicalParameter!="DELETEME")

#Mantel_IndPP_Comm.df = subset(Mantel_IndPP_Comm.df, PhysicochemicalParameter!="PTH_mg.L")
#Mantel_IndPP_Comm.df = subset(Mantel_IndPP_Comm.df, PhysicochemicalParameter!="Sat_O2_Perc")

#Keep as backup (and read in in case of catastrophy)
write.csv(Mantel_IndPP_Comm.df, "D:/Functional_R_analysis/Mantel_IndPP_Comm.csv")
#Mantel_IndPP_Comm.df = read.csv("D:/Functional_R_analysis/Mantel_IndPP_Comm.csv")

#Subset to only significant results
Mantel_IndPP_Comm_sign.df = subset(Mantel_IndPP_Comm.df, pvalue < 0.05)


####Make pretty for plotting ####

#Make groups for better information when plotting
Mantel_IndPP_Comm.df$Groups = c(paste0(Mantel_IndPP_Comm.df$Data_type, " - ", Mantel_IndPP_Comm.df$Community_type))

#Reorder for easy interpretation
Mantel_IndPP_Comm.df$Groups = factor(Mantel_IndPP_Comm.df$Groups,
                                          levels = c(
                                            "mOTU_TranscriptsPerGene - Sinking",
                                            "mOTU_TranscriptsPerGene - Suspended",
                                            "mOTU_TranscriptsPerGene - Particle_Associated",
                                            "mOTU_TranscriptsPerGene - Free-living",
                                            "mOTU_Metagenomes - Sinking",
                                            "mOTU_Metagenomes - Suspended",
                                            "mOTU_Metagenomes - Particle_Associated",
                                            "mOTU_Metagenomes - Free-living",
                                            "TranscriptsPerGene - Sinking",
                                            "TranscriptsPerGene - Suspended",
                                            "TranscriptsPerGene - Particle_Associated",
                                            "TranscriptsPerGene - Free-living",
                                            "Metagenomes - Sinking",
                                            "Metagenomes - Suspended",
                                            "Metagenomes - Particle_Associated",
                                            "Metagenomes - Free-living"
                                            ))
#Mantel_IndPP_Comm.df$Groups = factor(Mantel_IndPP_Comm.df$Groups,
 #                                         levels = c(
  #                                          "mOTU_TranscriptsPerGene - Sinking",
   #                                         "mOTU_Metagenomes - Sinking",
    #                                        "TranscriptsPerGene - Sinking",
     #                                       "Metagenomes - Sinking",
      #                                      "mOTU_TranscriptsPerGene - Suspended",
       #                                     "mOTU_Metagenomes - Suspended",
        #                                    "TranscriptsPerGene - Suspended",
         #                                   "Metagenomes - Suspended",
          #                                  "mOTU_TranscriptsPerGene - Particle_Associated",
           #                                 "mOTU_Metagenomes - Particle_Associated",
            #                                "TranscriptsPerGene - Particle_Associated",
             #                               "Metagenomes - Particle_Associated",
              #                              "mOTU_TranscriptsPerGene - Free-living",
               #                             "mOTU_Metagenomes - Free-living",
                #                            "TranscriptsPerGene - Free-living",
                 #                           "Metagenomes - Free-living",
                  #                          "mOTU_TranscriptsPerGene - Whole",
                   #                         "mOTU_Metagenomes - Whole",
                    #                        "TranscriptsPerGene - Whole",
                     #                       "Metagenomes - Whole"
                      #                      ))
#Change variable names for nice plots
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("station_km", "Elbe km", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Salinity_PSU", "Salinity (PSU)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Temperature_TBDHereon", "Temperature (Â°C)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("dCO2_uM", "dCO2 (ÂµM)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("dCH4_nM", "dCH4 (nM)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)

Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("O2_uM", "dO2 (ÂµM)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Turbidity_NTU", "Turbidity (NTU)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("PTC_mgperL", "PTC (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("SPM_mgperL", "Dry-weight (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("POC_mgperL", "POC (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("DOC_mg.L", "DOC (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("DIC_mg.L", "DIC (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)

Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("PTN_mgperL", "PTN (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("TN_mg.L", "DTN (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Ammonium_mg.L", "NH4+ (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Nitrite_mg.L", "NO2- (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Nitrate_mg.L", "NO3- (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Silicate_mg.L", "Si (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("TotalDissolvedPhosphate_mg.L", "DP (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("SRP_mgperL", "SRP (mg L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("TEP_um2perL", "TEP (Âµm2 L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("CSP_um2perL", "CSP (Âµm2 L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("Density_gpercm3", "Density (g cm-3)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)
Mantel_IndPP_Comm.df$PhysicochemicalParameter = gsub("ParticleArea_um2perL", "Particle area (um2 L-1)", Mantel_IndPP_Comm.df$PhysicochemicalParameter)

#Reorder for easy interpretation
Mantel_IndPP_Comm.df$PhysicochemicalParameter = factor(Mantel_IndPP_Comm.df$PhysicochemicalParameter,
                                          levels = c(
                                            "CSP (Âµm2 L-1)",
                                            "TEP (Âµm2 L-1)",
                                            "Si (mg L-1)",
                                            "SRP (mg L-1)",
                                            "DP (mg L-1)",
                                            "pH",
                                            "NO3- (mg L-1)",
                                            "NO2- (mg L-1)",
                                            "NH4+ (mg L-1)",
                                            "DTN (mg L-1)",
                                            "PTN (mg L-1)",
                                            "dO2 (ÂµM)",
                                            "dCH4 (nM)",
                                            "dCO2 (ÂµM)",
                                            "DIC (mg L-1)",
                                            "DOC (mg L-1)",
                                            "POC (mg L-1)",
                                            "PTC (mg L-1)",
                                            "Density (g cm-3)",
                                            "Particle area (um2 L-1)",
                                            "Dry-weight (mg L-1)",
                                            "Turbidity (NTU)",
                                            "Temperature (Â°C)",
                                            "Salinity (PSU)",
                                            "Elbe km"
                                            ))


#Remove PA
Mantel_IndPP_Comm.df = subset(Mantel_IndPP_Comm.df, Community_type!="Particle_Associated")

####Make actual plot ####

Comm_PP_rhovalue.plt = ggplot(Mantel_IndPP_Comm.df, aes(x = PhysicochemicalParameter, y = Groups, fill = ifelse(pvalue <= 0.05, Mantel_Rvalue, 0)))+
  geom_tile()+
  geom_text(aes(label = ifelse(pvalue > 0.05, "", 
                               ifelse(pvalue > 0.01, "*", 
                                      ifelse(pvalue > 0.001, "**", 
                                             ifelse(pvalue <= 0.001, "***", ""))))),
            size = 20 / .pt,
            colour = "black")+
  scale_fill_gradient2("Mantel Correlation", low = "navy", mid = "white", high = "red", midpoint = 0)+ 
  scale_x_discrete(
    expand = expansion(mult = c(0,0)), guide = guide_axis(angle = 90),
    position = "top",
    limits = rev
  )+
  scale_y_discrete(
    expand = expansion(mult = c(0,0)),
    position = "right"
  )+
  xlab("Physicochemical parameters") + 
  ylab("Community")+
  My_Theme
Comm_PP_rhovalue.plt


pdf("D:/Functional_R_analysis/Figures/Comm_PP_heatmap_pearson_Fix.pdf", width = 17, height = 8)
Comm_PP_rhovalue.plt 
dev.off()

#For posterities sake
#write.csv(Mantel_IndPP_Comm.df, "D:/Functional_R_analysis/Figure2_PPvsMicrob.csv")
Mantel_IndPP_Comm.df = read.csv("F:/Functional_R_analysis/Figure2_PPvsMicrob.csv")



```
## Attic - Mantel MG vs MT vs mOTU
```{r}

####Generate MG dataframe ####
#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")
dim(distinct(CarbonGenelist.df))
#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#Correct abundance
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000

#write.csv(amoAClean_CO2CH4_tbl_long, "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")

#amoAClean_CO2CH4_tbl_long = read.csv( "amoAClean_CO2CH4_OccurrenceFiltered_V2.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)

#Subset to split metagenomes and metatranscriptomes and remove superflous columns
amoAClean_CO2CH4_tbl_long_MG = subset(amoAClean_CO2CH4_tbl_long, data_type == "Metagenomes") %>%
  select(counts, KO, Associatednumber)

dim(amoAClean_CO2CH4_tbl_long_MG)
amoAClean_CO2CH4_tbl_long_MG = unique(amoAClean_CO2CH4_tbl_long_MG)
dim(amoAClean_CO2CH4_tbl_long_MG)



#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MG <- data.frame(spread(amoAClean_CO2CH4_tbl_long_MG,
                       key = Associatednumber, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MG)
#View(amoAClean_CO2CH4_wide_MG)

#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MG) = amoAClean_CO2CH4_wide_MG$KO
amoAClean_CO2CH4_wide_MG$KO = NULL

#So I don't need to waste time rerunning this every time
write.csv(amoAClean_CO2CH4_wide_MG, "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv")
#amoAClean_CO2CH4_wide_MG = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)

#Remove x from column names
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))

####Generate MT dataframe ####


#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

#Correct abundance
amoAClean_geneabund_KO[c(2:264)] = amoAClean_geneabund_KO[c(2:264)] / 1000


amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)



#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)




#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
CO2CH4_TG.df = CO2CH4_TG.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was ususally the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
CO2CH4_TG.lng = gather(CO2CH4_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(CO2CH4_TG.lng)

#Remove data_types and columns that are no longer relevant 
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber)
dim(CO2CH4_TG.lng)


#Remove samples for which we have no metatranscriptomes
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, Associatednumber > 116)

#Remove samples for which sequencing failed
CO2CH4_TG.lng = subset(CO2CH4_TG.lng, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
CO2CH4_TG.lng$counts = as.numeric(as.character(CO2CH4_TG.lng$counts))
CO2CH4_TG.lng$Associatednumber = as.character(CO2CH4_TG.lng$Associatednumber)

#Long to wide
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
amoAClean_CO2CH4_wide_MT <- data.frame(spread(unique(CO2CH4_TG.lng),
                       key = Associatednumber, #Column that will contain new column names
                       value = counts)) # Value that will fill new columns
#Ensure that it worked
dim(amoAClean_CO2CH4_wide_MT)
#View(amoAClean_CO2CH4_wide_MT)

#Bug check
max(amoAClean_CO2CH4_wide_MT$X117) # should be ~673.5397

#Apply row names from gene KOs
rownames(amoAClean_CO2CH4_wide_MT) = amoAClean_CO2CH4_wide_MT$KO
amoAClean_CO2CH4_wide_MT$KO = NULL


#So I don't need to waste time rerunning this every time
write.csv(amoAClean_CO2CH4_wide_MT, "F:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv")
#amoAClean_CO2CH4_wide_MT = read.csv("E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove x from column names
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))


####Import mOTU dataframe####

Microbiome_wide_mOTU = read.csv("E:/Functional_R_analysis/mOTU_SamplesSpecies.csv", row.names = 1)

####Match samples between functional potential and mOTUs and run dissimilarities####

#Read in dataframes
amoAClean_CO2CH4_wide_MG = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)
Microbiome_wide_mOTU = read.csv("E:/Functional_R_analysis/mOTU_SamplesSpecies.csv", row.names = 1)
amoAClean_CO2CH4_wide_MT = read.csv("E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove any potential x's from column names for both dataframes
colnames(Microbiome_wide_mOTU) = gsub("X", "", colnames(Microbiome_wide_mOTU))
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))

#Get an idea of how many samples MG and mOTUs have
dim(Microbiome_wide_mOTU)
dim(amoAClean_CO2CH4_wide_MG)

#Extract only matched samples for dissimilarity, otherwise mantel doesn't work
Microbiome_wide_mOTU = Microbiome_wide_mOTU[names(Microbiome_wide_mOTU) %in% colnames(amoAClean_CO2CH4_wide_MG)]
amoAClean_CO2CH4_wide_MG = amoAClean_CO2CH4_wide_MG[names(amoAClean_CO2CH4_wide_MG) %in% colnames(Microbiome_wide_mOTU)]

#Sanity check to see if it worked
dim(Microbiome_wide_mOTU)
dim(amoAClean_CO2CH4_wide_MG)


#Set seed for reproducibility
set.seed(2)

#Run dissimilarity comparison between samples
##Microbial
Microbiome_wide_mOTU.diss = vegan::vegdist(t(Microbiome_wide_mOTU), method = "bray", na.rm = T)
amoAClean_CO2CH4_wide_MG.diss = vegan::vegdist(t(amoAClean_CO2CH4_wide_MG), method = "bray", na.rm = T)

#Run mantel test
vegan::mantel(Microbiome_wide_mOTU.diss, amoAClean_CO2CH4_wide_MG.diss) 







####Match samples between transcripts and mOTUs and run dissimilarities####

#Read in dataframes
amoAClean_CO2CH4_wide_MG = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)
Microbiome_wide_mOTU = read.csv("E:/Functional_R_analysis/mOTU_SamplesSpecies.csv", row.names = 1)
amoAClean_CO2CH4_wide_MT = read.csv("E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove any potential x's from column names for both dataframes
colnames(Microbiome_wide_mOTU) = gsub("X", "", colnames(Microbiome_wide_mOTU))
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))

#Get an idea of how many samples MG and mOTUs have
dim(Microbiome_wide_mOTU)
dim(amoAClean_CO2CH4_wide_MT)

#Extract only matched samples for dissimilarity, otherwise mantel doesn't work
Microbiome_wide_mOTU = Microbiome_wide_mOTU[names(Microbiome_wide_mOTU) %in% colnames(amoAClean_CO2CH4_wide_MT)]
amoAClean_CO2CH4_wide_MT = amoAClean_CO2CH4_wide_MT[names(amoAClean_CO2CH4_wide_MT) %in% colnames(Microbiome_wide_mOTU)]

#Sanity check to see if it worked
dim(Microbiome_wide_mOTU)
dim(amoAClean_CO2CH4_wide_MT)


#Set seed for reproducibility
set.seed(2)

#Run dissimilarity comparison between samples
##Microbial
Microbiome_wide_mOTU.diss = vegan::vegdist(t(Microbiome_wide_mOTU), method = "bray", na.rm = T)
amoAClean_CO2CH4_wide_MT.diss = vegan::vegdist(t(amoAClean_CO2CH4_wide_MT), method = "bray", na.rm = T)

#Run mantel test
vegan::mantel(Microbiome_wide_mOTU.diss, amoAClean_CO2CH4_wide_MT.diss)





####Match samples between transcripts and metagenomes and run dissimilarities####

#Read in dataframes
amoAClean_CO2CH4_wide_MG = read.csv( "E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MG.csv", row.names = 1)
Microbiome_wide_mOTU = read.csv("E:/Functional_R_analysis/mOTU_SamplesSpecies.csv", row.names = 1)
amoAClean_CO2CH4_wide_MT = read.csv("E:/Functional_R_analysis/amoAClean_CO2CH4_wide_MT.csv", row.names = 1)

#Remove any potential x's from column names for both dataframes
colnames(Microbiome_wide_mOTU) = gsub("X", "", colnames(Microbiome_wide_mOTU))
colnames(amoAClean_CO2CH4_wide_MG) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MG))
colnames(amoAClean_CO2CH4_wide_MT) = gsub("X", "", colnames(amoAClean_CO2CH4_wide_MT))

#Get an idea of how many samples MG and mOTUs have
dim(amoAClean_CO2CH4_wide_MG)
dim(amoAClean_CO2CH4_wide_MT)

#Extract only matched samples for dissimilarity, otherwise mantel doesn't work
amoAClean_CO2CH4_wide_MG = amoAClean_CO2CH4_wide_MG[names(amoAClean_CO2CH4_wide_MG) %in% colnames(amoAClean_CO2CH4_wide_MT)]
amoAClean_CO2CH4_wide_MT = amoAClean_CO2CH4_wide_MT[names(amoAClean_CO2CH4_wide_MT) %in% colnames(amoAClean_CO2CH4_wide_MG)]

#Sanity check to see if it worked
dim(amoAClean_CO2CH4_wide_MG)
dim(amoAClean_CO2CH4_wide_MT)


#Set seed for reproducibility
set.seed(2)

#Run dissimilarity comparison between samples
##Microbial
amoAClean_CO2CH4_wide_MG.diss = vegan::vegdist(t(amoAClean_CO2CH4_wide_MG), method = "bray", na.rm = T)
amoAClean_CO2CH4_wide_MT.diss = vegan::vegdist(t(amoAClean_CO2CH4_wide_MT), method = "bray", na.rm = T)

#Run mantel test
vegan::mantel(amoAClean_CO2CH4_wide_MG.diss, amoAClean_CO2CH4_wide_MT.diss)

```
#Methanotrophy - Figure 3 + S6

##Prep metadata
```{r}
#Import metadata
metadata <- read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT


metadata2 <- read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
rownames(metadata)<-metadata$sampleid
```
###Set up Salinity plot
```{r}

#Read in new PP dataframe as a clean data frame
Physicochem.df = readxl::read_xlsx("D:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM."]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

#Extract relevant columns
Salinity.df = Physicochem.df  %>% 
  dplyr::select(all_of(PP_totest.ls)) %>%
  dplyr::select(Sample_date, station_km, Salinity_PSU) %>%
  distinct()
dim(Salinity.df)

#Convert relevant columns to numeric
Salinity.df[,c(2:3)] = as.data.frame(sapply(Salinity.df[,c(2:3)], as.numeric))

Salinity.df$Sample_date = factor(Salinity.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))



```
##Prep count data
```{r}

#load metasdata from clean backup
metadata = metadata_v0

#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
#sort(unique(amoAMatches.ls$gene_cluster))


#### Metagenomes ####


MethTroph_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  filter(KO %in% "K10944") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  dplyr::select(gene_cluster, DESCRIPTION, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(-c(KO), sum, na.rm = TRUE)) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(MethTroph_geneabund_KO)
unique(MethTroph_geneabund_KO$DESCRIPTION) # Should be 1


MethTroph_geneabund_KO_long <- MethTroph_geneabund_KO %>%
  pivot_longer(-c(, DESCRIPTION), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  #mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information for amoA
  #mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  
  filter(DESCRIPTION == "pmoA; methane monooxygenase subunit A") %>%
  #dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct() %>%
  dplyr::filter(SName!="amoA")
MethTroph_geneabund_KO_long

#Correct abundance
MethTroph_geneabund_KO_long$counts = MethTroph_geneabund_KO_long$counts / 1000

#Clean up for plot
MethTroph_geneabund_KO_long$station_km = as.numeric(as.character(MethTroph_geneabund_KO_long$station_km))


MethTroph_geneabund_KO_long$Sample_date = factor(MethTroph_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

MethTroph_MG.df = MethTroph_geneabund_KO_long

#Add together the different fractions
MethTroph_pmoA_MG.sum <- MethTroph_MG.df %>%
  group_by(Sample_date, station_km) %>%
  summarise(
    mean_pmoA = mean(counts, na.rm = TRUE),
    pmoA_sd = sd(counts),
    pmoA_se = se(counts),
  ) %>%
  mutate(data_type = "GenesPerGenome")
MethTroph_pmoA_MG.sum





####Metatranscriptomes ####

MethTroph_geneabund_KO = annot %>%
  filter(KO %in% "K10944") %>% # only extract the CO2CH4 gene
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  
  dplyr::select(gene_cluster, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(MethTroph_geneabund_KO)


test = MethTroph_geneabund_KO %>%
  select(gene_cluster, DESCRIPTION, 
         GROS22.2_SAMEA112714791_METAG.genecount.profile, GROS22.2_SAMEA112714791_METAT.genecount.profile, 
         GROS22.2_SAMEA112714792_METAG.genecount.profile, GROS22.2_SAMEA112714792_METAT.genecount.profile)

MethTroph_geneabund_KO_long <- MethTroph_geneabund_KO %>%
  pivot_longer(!DESCRIPTION, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  
  #mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information fpr amoA
  #mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  
  filter(DESCRIPTION == "pmoA; methane monooxygenase subunit A") %>% # filter to only pmoA genes
  #dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ungroup() %>% 
  distinct()

#Correct abundance
MethTroph_geneabund_KO_long$counts = MethTroph_geneabund_KO_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(MethTroph_geneabund_KO_long)


#Reorder factors
MethTroph_geneabund_KO_long$Station = factor(MethTroph_geneabund_KO_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

MethTroph_geneabund_KO_long$Sample_date = gsub("-", " ",MethTroph_geneabund_KO_long$Sample_date)

MethTroph_geneabund_KO_long$Sample_date = factor(MethTroph_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
MethTroph_geneabund_KO_long$data_type = gsub("METAT", "Transcriptomes", MethTroph_geneabund_KO_long$data_type)
MethTroph_geneabund_KO_long$data_type = gsub("METAG", "Metagenomes", MethTroph_geneabund_KO_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
MethTroph_TG.df <- spread(MethTroph_geneabund_KO_long[ , ! names(MethTroph_geneabund_KO_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(MethTroph_geneabund_KO_long)
dim(MethTroph_TG.df)

#Calculate Transcripts per gene copy
MethTroph_TG.df$TranscriptsPerGenome = MethTroph_TG.df$Transcriptomes / MethTroph_TG.df$Metagenomes


#Remove samples for which we have no metatranscriptomes
MethTroph_TG.df = subset(MethTroph_TG.df, Associatednumber > 116)
MethTroph_TG.df = subset(MethTroph_TG.df, TranscriptsPerGenome < 999999999)

#Remove samples for which sequencing failed
MethTroph_TG.df = subset(MethTroph_TG.df, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))

#Make sure data is set up properly
MethTroph_TG.df$TranscriptsPerGenome = as.numeric(as.character(MethTroph_TG.df$TranscriptsPerGenome))
MethTroph_TG.df$Transcriptomes = NULL
MethTroph_TG.df$Metagenomes = NULL
MethTroph_TG.df$Associatednumber = as.character(MethTroph_TG.df$Associatednumber)

MethTroph_TG.df$Sample_date = factor(MethTroph_TG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))
#Add together the different fractions
MethTroph_pmoA_MT.sum <- MethTroph_TG.df %>%
  group_by(Sample_date, station_km) %>%
  summarise(
    mean_pmoA = mean(TranscriptsPerGenome, na.rm = TRUE),
    pmoA_sd = sd(TranscriptsPerGenome),
    pmoA_se = se(TranscriptsPerGenome),
  ) %>%
  mutate(data_type = "TranscriptsperGene")
MethTroph_pmoA_MT.sum




#### Plotting simple figure - removed fractions - Attic ####



#Make pretty
MethTroph_pmoA_MG.sum$Sample_date = factor(MethTroph_pmoA_MG.sum$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))
MethTroph_pmoA_MT.sum$Sample_date = factor(MethTroph_pmoA_MT.sum$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))



#Plot
MethTroph_MG.plt = ggplot(MethTroph_pmoA_MG.sum, aes(y = mean_pmoA, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_smooth()+
  geom_point()+
  geom_errorbar(aes(ymin = mean_pmoA - pmoA_sd, ymax = mean_pmoA + pmoA_sd, colour = Sample_date),
                width = 3) + 
  facet_grid(data_type ~ .)+
  scale_y_log10("pmoA abundance")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MethTroph_MG.plt

MethTroph_MT.plt = ggplot(MethTroph_pmoA_MT.sum, aes(y = mean_pmoA, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_smooth()+
  geom_point()+
  geom_errorbar(aes(ymin = mean_pmoA - pmoA_sd, ymax = mean_pmoA + pmoA_sd, colour = Sample_date),
                width = 3) + 
  facet_grid(data_type ~ .)+
  scale_y_log10("pmoA abundance")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MethTroph_MT.plt


MethTroph_pmoA_MG.sum %>%
  #dplyr::group_by(Sample_type) %>%
  ungroup() %>%
  dplyr::summarise(mean_val = mean(mean_pmoA))
MethTroph_pmoA_MT.sum %>%
  #dplyr::group_by(Sample_type) %>%
  ungroup() %>%
  dplyr::summarise(mean_val = mean(mean_pmoA))


#Combine plots with ggarrange

MethTroph.plt = ggarrange(MethTroph_MG.plt,
                     MethTroph_MT.plt,
                     common.legend = T,
                     ncol = 2,
                     legend = "right")

MethTroph.plt


pdf("D:/Functional_R_analysis/Figures/Figure3_pmoA.pdf", width = 9, height = 4)
MethTroph.plt
dev.off()


#### Statistics and means ####
#Subset to only pmoA
pmoA_TG.df = subset(MethTroph_TG.df, SName == "pmoA")

#Calculate meana nd median
Mean_MG = MethTroph_geneabund_KO_long %>%
  group_by(SName, Sample_type) %>%
  summarise(average = mean(counts), median = median(counts))
Mean_MG
Mean_MT = pmoA_TG.df %>%
  group_by(SName, Sample_type) %>%
  summarise(average = mean(TranscriptsPerGenome), median = median(TranscriptsPerGenome))
Mean_MT

#Also consider distributions
Rmisc::summarySE(MethTroph_geneabund_KO_long, measurevar = "counts", groupvars = c("SName", "Sample_type"))
Rmisc::summarySE(MethTroph_TG.df, measurevar = "TranscriptsPerGenome", groupvars = c("SName", "Sample_type"))

#Significant differences between sample types
pairwise.wilcox.test(MethTroph_geneabund_KO_long$counts, MethTroph_geneabund_KO_long$Sample_type)
pairwise.wilcox.test(pmoA_TG.df$TranscriptsPerGenome, pmoA_TG.df$Sample_type)

#Significant correlation with Elbe km
cor.test(MethTroph_geneabund_KO_long$counts, MethTroph_geneabund_KO_long$station_km, method = "s")
cor.test(pmoA_TG.df$TranscriptsPerGenome, pmoA_TG.df$station_km, method = "s")

#Add salinity to the dataframes
Salinity_pmoa_MG.df = MethTroph_geneabund_KO_long %>%
  left_join(Salinity.df, by = c("Sample_date" = "Sample_date", "station_km" = "station_km"))
#Add salinity to the dataframes
Salinity_pmoa_MT.df = pmoA_TG.df %>%
  left_join(Salinity.df, by = c("Sample_date" = "Sample_date", "station_km" = "station_km"))

#Significant correlation with Elbe km
cor.test(Salinity_pmoa_MG.df$counts, Salinity_pmoa_MG.df$Salinity_PSU, method = "s")
cor.test(Salinity_pmoa_MT.df$TranscriptsPerGenome, Salinity_pmoa_MT.df$Salinity_PSU, method = "s")

```

##Plot Figure 3 - - Figure 4 pmoA with separated fractions
```{r}

#Rename suspended and sinking to PA for particle associated, and free_living to FL
MethTroph_MG.df$Sample_type = gsub("Heavy_fraction", "PA", MethTroph_MG.df$Sample_type)
MethTroph_MG.df$Sample_type = gsub("Light_fraction", "PA", MethTroph_MG.df$Sample_type)
MethTroph_MG.df$Sample_type = gsub("Free_living", "FL", MethTroph_MG.df$Sample_type)
MethTroph_TG.df$Sample_type = gsub("Heavy_fraction", "PA", MethTroph_TG.df$Sample_type)
MethTroph_TG.df$Sample_type = gsub("Light_fraction", "PA", MethTroph_TG.df$Sample_type)
MethTroph_TG.df$Sample_type = gsub("Free_living", "FL", MethTroph_TG.df$Sample_type)


MethTroph_MG_FLvsSuspvsSink.df = Rmisc::summarySE(MethTroph_MG.df, measurevar = "counts", groupvars = c("Sample_date", "Sample_type", "station_km"))
MethTroph_MT_FLvsSuspvsSink.df = Rmisc::summarySE(MethTroph_TG.df, measurevar = "TranscriptsPerGenome", groupvars = c("Sample_date", "Sample_type", "station_km"))

MethTroph_MT_FLvsSuspvsSink.df$data_type = "TranscriptsPerGene"

MethTroph_MG_FLvsSuspvsSink.df$Sample_date = factor(MethTroph_MG_FLvsSuspvsSink.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))
MethTroph_MT_FLvsSuspvsSink.df$Sample_date = factor(MethTroph_MT_FLvsSuspvsSink.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))

MethTroph_MG_complex.plt = ggplot(MethTroph_MG_FLvsSuspvsSink.df, aes(y = counts, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_smooth(method="loess",se=FALSE)+
  geom_point()+
  geom_errorbar(aes(ymin = counts - se, 
                    ymax = counts + se, 
                    colour = Sample_date),
                width = 3) + 
  scale_y_log10("pmoA abundance \n(per genome)")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  #ggh4x::facet_grid2(. ~ Sample_type, scales = "free_y", independent = "y")+
  facet_grid(. ~ Sample_type) +
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MethTroph_MG_complex.plt

MethTroph_MT_complex.plt = ggplot(MethTroph_MT_FLvsSuspvsSink.df, aes(y = TranscriptsPerGenome, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_smooth(method="loess",se=FALSE)+
  geom_point()+
  geom_errorbar(aes(ymin = TranscriptsPerGenome - se, 
                    ymax = TranscriptsPerGenome + se, 
                    colour = Sample_date),
                width = 3) + 
  scale_y_log10("pmoA abundance \n(per gene)")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  #ggh4x::facet_grid2(. ~ Sample_type, scales = "free_y", independent = "y")+
  facet_grid(. ~ Sample_type) +
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MethTroph_MT_complex.plt

MethTroph_complex.plt = ggarrange(MethTroph_MG_complex.plt,
                     MethTroph_MT_complex.plt,
                     common.legend = T,
                     ncol = 1,
                     legend = "right")

MethTroph_complex.plt


pdf("D:/Functional_R_analysis/Figures/Figure4_pmoA_Split.pdf", width = 11, height = 8)
MethTroph_complex.plt
dev.off()

MethTroph_MT_FLvsSuspvsSink.df %>%
  group_by(Sample_type) %>%
  summarise(mean_val = mean(TranscriptsPerGenome))

Fraction.mdl = aov(TranscriptsPerGenome ~ Sample_type, MethTroph_TG.df)
summary(Fraction.mdl)
rstatix::eta_squared(Fraction.mdl)
#rho = -0.48988
#p = 9.082e-12


cor.test(MethTroph_MG.df$counts, MethTroph_MG.df$station_km)
#cor = 0.6195
#p = 2.277e-08

cor.test(MethTroph_TG.df$TranscriptsPerGenome, MethTroph_TG.df$station_km)
#cor = 0.6195
#p = 2.277e-08


cor.test(MethTroph_MG.df$counts, MethTroph_MG.df$dCH4_nM)
#cor = 0.2204
#p = 0.11

cor.test(MethTroph_TG.df$TranscriptsPerGenome, MethTroph_TG.df$dCH4_nM)
#cor = 0.1935
#p = 0.11


```
##pmoA containing taxa abundance
```{r}
####Calculate abundances####

#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#Import mOTU ID lists that lets us link them to MAGs, and combine them
mag_nmOTUs.df = read.csv("D:/Functional_R_analysis/mag_2_new_motus", header = F, sep = "\t") %>%
  separate_rows(V2, sep = ";") %>%
  dplyr::rename(mOTU_ID = V1) %>%
  dplyr::rename(MAG_ID = V2)

mag_emOTUs.df = read.csv("D:/Functional_R_analysis/mag_2_existing_motus", header = F, sep = "\t") %>%
  separate_rows(V2, sep = ";") %>%
  dplyr::select(V1, V2) %>%
  dplyr::rename(mOTU_ID = V2) %>%
  dplyr::rename(MAG_ID = V1)

mOTUs2MAGs = rbind(mag_nmOTUs.df, mag_emOTUs.df) %>%
  filter(mOTU_ID!="NotEnoughMGs")


#Import modified dataframe
motus_final_taxa_metadata <- readRDS(file="D:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS")

#Make relative abundance from total counts
TotalmOTUCount.df = motus_final_taxa_metadata %>%
  group_by(sampleid) %>%
  summarise(totalcount = sum(counts)) %>%
  arrange(totalcount, decreasing = F) %>%
  filter(!str_detect(sampleid,"METAT"))
TotalmOTUCount.df  


amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
#sort(unique(amoAMatches.ls$KO))
sort(unique(amoAMatches.ls$genus))

#Create df after linking MAGs to mOTUs
MethTroph_mOTU = annot %>%
  rownames_to_column("gene_cluster") %>%
  filter(KO %in% "K10944") %>%
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  #mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering to exclude amoA
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to pmoA as we excluded amoA gene_clusters
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>%
  select(genome, DESCRIPTION) %>%
  left_join(mOTUs2MAGs, by=c("genome" = "MAG_ID")) %>%
  na.omit() %>%
  left_join(motus_final_taxa_metadata, by = c("mOTU_ID" = "mOTU"), relationship = "many-to-many") %>%
  filter(!str_detect(genus,"Nitros"))

sort(unique(MethTroph_mOTU$genus))

MethTroph_mOTU$date = gsub("Mai", "May", MethTroph_mOTU$date)  

MethTroph_mOTU$date = factor(MethTroph_mOTU$date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#MethTroph_mOTU.sum = Rmisc::summarySE(MethTroph_mOTU, measurevar = "counts", groupvars = c("phylum", "class", "order", "family", "genus", "species",
                     #                                                                      "station_km", "date", "sample_type",
                      #                                                                     "salinity"))
#MethTroph_mOTU.sum$taxac = paste0(MethTroph_mOTU.sum$phylum, ";", 
 #                                MethTroph_mOTU.sum$class, ";", 
  #                               MethTroph_mOTU.sum$order, ";", 
   #                              MethTroph_mOTU.sum$family, ";", 
    #                             MethTroph_mOTU.sum$genus, ";", 
     #                            MethTroph_mOTU.sum$species)
#Keep for records
#write.csv(MethTroph_geneabund_KO_long.sum, "D:/Functional_R_analysis/pmoA_MG.csv")

#test = read.csv("D:/Functional_R_analysis/pmoA_MG.csv")

####Plot abundances ####

#Adjust sample type for FL vs PA
MethTroph_mOTU$sample_type = gsub("Free_living", "FL", MethTroph_mOTU$sample_type)
MethTroph_mOTU$sample_type = gsub("Heavy_fraction", "PA", MethTroph_mOTU$sample_type)
MethTroph_mOTU$sample_type = gsub("Light_fraction", "PA", MethTroph_mOTU$sample_type)

pmoATaxaAbund.sum = MethTroph_mOTU %>%
  left_join(TotalmOTUCount.df, by = c("sampleid" = "sampleid")) %>%
  Rmisc::summarySE(., measurevar = "counts", groupvars = c("phylum", "class", "order", "family", "genus", "species",
                                                           "sample_type", "date", "totalcount",
                                                            "salinity", d)) %>%
  mutate(rel_ab = counts / totalcount) # to make abundance relative
                                                                      
pmoATaxaAbund.sum$taxac = paste0(pmoATaxaAbund.sum$phylum, ";", 
                                 pmoATaxaAbund.sum$class, ";", 
                                 pmoATaxaAbund.sum$order, ";", 
                                 pmoATaxaAbund.sum$family, ";", 
                                 pmoATaxaAbund.sum$genus, ";", 
                                 pmoATaxaAbund.sum$species)

#Remake summary dataframe with relative abundance
pmoATaxaAbund.sum = Rmisc::summarySE(pmoATaxaAbund.sum, 
                                     measurevar = "rel_ab", 
                                     groupvars = c("phylum", "class", "order", "family", "genus",
                                                   "sample_type", "date",
                                                   "salinity"))
#Establish groups
pmoATaxaAbund.sum$groups = paste0(pmoATaxaAbund.sum$sample_type, "_", pmoATaxaAbund.sum$date)
  
MethTroph_mOTU.plt = ggplot(pmoATaxaAbund.sum, aes(x = salinity, 
                                                   y = rel_ab*100, 
                                                   colour = date, 
                                                   shape = sample_type, 
                                                   group = groups)) +
  geom_line() +
  geom_point(size = 5) +
  ggh4x::facet_wrap2(vars(genus))+
  scale_shape_discrete(name = "Fractions", breaks = c("FL", "PA"), labels = c("Free-living", "Particle-associated"))+
  scale_x_reverse("Salinity (PSU)")+
  scale_color_manual("Date", values = Date_colour_list)+
  #scale_shape_manual("Genera", values = Shape_list)+
  ylab("Relatve abundance of pmoA \nassociated taxa (%)")+
  My_Theme
MethTroph_mOTU.plt


pdf("D:/Functional_R_analysis/Figures/pmoATaxa.pdf", width = 10, height = 6)
MethTroph_mOTU.plt
dev.off()

Rel_ab.sum = pmoATaxaAbund.sum %>%
  group_by(date, genus, sample_type, salinity) %>%
  summarise(mean_val = mean(rel_ab, na.rm = T))

Rel_ab.sum

Rel_ab.sum = pmoATaxaAbund.sum %>%
  group_by(date, family, salinity) %>%
  summarise(mean_val = mean(rel_ab, na.rm = T))

Rel_ab.sum


####Salinity correlations ####
cor.test(pmoATaxaAbund.sum$rel_ab, pmoATaxaAbund.sum$salinity, method = "s")
#Significantly decreased abundance in response to salinity

cor.test(pmoATaxaAbund.sum$rel_ab, pmoATaxaAbund.sum$, method = "s")
#Significantly decreased abundance in response to dCH4

Results_salcor.df = data.frame("Taxa" = "DELETEME",
                               "rho" = 9999,
                               "p.value" = 9999)

taxa.var = unique(MethTroph_mOTU.sum$taxac)[1]
for (taxa.var in unique(MethTroph_mOTU.sum$taxac)) {
  
  tmp.df = subset(MethTroph_mOTU.sum, taxac == taxa.var)
  
  tmp.cor = cor.test(tmp.df$counts, tmp.df$salinity, method = "s")
  
  tmp.res = data.frame("Taxa" = taxa.var,
                       "rho" = tmp.cor$estimate,
                       "p.value" = tmp.cor$p.value)
  
  
  Results_salcor.df = rbind(Results_salcor.df, tmp.res)
  
}
rm(tmp.df, tmp.cor, tmp.res, taxa.var)
Results_salcor.df = Results_salcor.df[-1,]

```

##Correct by bacterial abundance
```{r}

####Set up bacterial abundance df ####
#Import dataframes
SYBR_sum.df = read.csv("D:/Functional_R_analysis/AllSYBR_Summary.csv", header = T, fileEncoding = "UTF-8-BOM")
SYBR_sum.df = subset(SYBR_sum.df, !Date=="11.2021")
#SYBR.df = read.csv("C:/Users/hunefeldt/OneDrive/Desktop/R_analysis/ParticleAnalysis/Data/All_IndividualParticles_SYBR.csv", header = T, fileEncoding = "UTF-8-BOM")

SYBR_sum.df$Count = SYBR_sum.df$Count * 10122.6872775 * 1000



dim(SYBR_sum.df)
SYBR_sum.df = na.omit(SYBR_sum.df)
dim(SYBR_sum.df)
#Remove unneeded data
SYBR_FL.df = subset(SYBR_sum.df, Condition=="0point2")
SYBR_PAO.df = subset(SYBR_sum.df, Condition=="Particle")



#Calculate mean FLO and PAO
SYBR_FL.sum = Rmisc::summarySE(SYBR_FL.df, 
                               measurevar = "Count",
                               groupvars = c("Station",
                                             "Date"))
SYBR_FL_Ave.sum = Rmisc::summarySE(SYBR_FL.df, 
                               measurevar = "Average_Size",
                               groupvars = c("Station",
                                             "Date"))
SYBR_FL.sum$Average_Size = SYBR_FL_Ave.sum$Average_Size

SYBR_PAO.sum = Rmisc::summarySE(SYBR_PAO.df, 
                               measurevar = "Count",
                               groupvars = c("Station",
                                             "Date"))


#Subtract PAO from 0.2Âµm filter for corrected free-living abundance
SYBR_FL.sum$Corr_FL = 0
for (i in 1:length(SYBR_FL.sum$Station)) {
  
  #Make sure variables match
  DateID=SYBR_FL.sum$Date[i]
  StationID=SYBR_FL.sum$Station[i]
  #StainID=SYBR_FL.sum$Condition[i]
  #FractionID=SYBR_FL.sum$Fraction[i]
  
  #Print IDs for bug checking
  print(paste0(DateID, " ", StationID))
  
  #Subset particle information based on IDs
  SYBR_PAO.tmp = subset(SYBR_PAO.sum, 
                           Date==DateID &
                             Station==StationID# &
                             #Condition==ConditionID & 
                             #Fraction==FractionID &
                             #ImageNumber==ImageID
                     )$Count
  
  
  #Subtract PAO from Total 
  SYBR_FL.sum$Corr_FL[i] = SYBR_FL.sum$Count[i] - SYBR_PAO.tmp
  
}

#Check to make sure it's worked well
SYBR_FL.sum



#Rename stations for pretty plots
SYBR_FL.sum$Station = gsub("Station2$", "Muhlenberger Loch", SYBR_FL.sum$Station)
SYBR_FL.sum$Station = gsub("Station3$", "Twielenfleth", SYBR_FL.sum$Station)
SYBR_FL.sum$Station = gsub("Station4$", "Schwarztonnensand", SYBR_FL.sum$Station)
SYBR_FL.sum$Station = gsub("Station5$", "Brunsbuttel", SYBR_FL.sum$Station)
SYBR_FL.sum$Station = gsub("Station6$", "Meedem Grund", SYBR_FL.sum$Station)


SYBR_FL.sum$Station = factor(SYBR_FL.sum$Station,
                             levels = c("Meedem Grund", 
                                        "Brunsbuttel",
                                        "Schwarztonnensand",
                                        "Twielenfleth",
                                        "Muhlenberger Loch"))



mean(SYBR_PAO.sum$Count)
mean(SYBR_FL.sum$Corr_FL)


mean(SYBR_FL.sum$Corr_FL) / mean(SYBR_PAO.sum$Count)


#Generate PAO df
SYBR_PAO.sum = Rmisc::summarySE(SYBR_PAO.df, 
                               measurevar = "Count",
                               groupvars = c("Station",
                                             "Date",
                                             "Fraction"))


#Make sure FL df matches
SYBR_FL.sum = SYBR_FL.sum %>% # load in df
  select(Station, Date, Corr_FL) %>% # only get relevant columns
  mutate(Fraction = "Free-living") %>%
  rename(Count = Corr_FL)

#Make sure PAO df matches and combine FL and PAO df
SYBR_PAO.sum = SYBR_PAO.sum %>% # load in df
  select(Station, Date, Fraction, Count) # select only relevant columns




#Make complete summary df
SYBR.sum = rbind(SYBR_FL.sum, SYBR_PAO.sum) %>%
  rename(bact.ab = Count)


#Rename stations to match other dataframes
SYBR.sum$Station = gsub("Station2$", "Muhlenberger Loch", SYBR.sum$Station)
SYBR.sum$Station = gsub("Station3$", "Twielenfleth", SYBR.sum$Station)
SYBR.sum$Station = gsub("Station4$", "Schwarztonnensand", SYBR.sum$Station)
SYBR.sum$Station = gsub("Station5$", "Brunsbuttel", SYBR.sum$Station)
SYBR.sum$Station = gsub("Station6$", "Meedem Grund", SYBR.sum$Station)

SYBR.sum$Fraction = gsub("Heavy", "Sinking", SYBR.sum$Fraction)
SYBR.sum$Fraction = gsub("Light", "Suspended", SYBR.sum$Fraction)


#Get distance from Hamburg/Elbe distance for spearman tests
SYBR.sum$station_km = SYBR.sum$Station
SYBR.sum$station_km = gsub("Muhlenberger Loch", 633, SYBR.sum$station_km)
SYBR.sum$station_km = gsub("Twielenfleth", 651, SYBR.sum$station_km)
SYBR.sum$station_km = gsub("Schwarztonnensand", 665, SYBR.sum$station_km)
SYBR.sum$station_km = gsub("Brunsbuttel", 692, SYBR.sum$station_km)
SYBR.sum$station_km = gsub("Meedem Grund", 713, SYBR.sum$station_km)
SYBR.sum$station_km = as.numeric(SYBR.sum$station_km)

#Replace date with more informative and matching version
SYBR.sum$Date = gsub("2021.05", "May 21", SYBR.sum$Date)
SYBR.sum$Date = gsub("2021.07", "Jul 21", SYBR.sum$Date)
SYBR.sum$Date = gsub("2022.02", "Feb 22", SYBR.sum$Date)
SYBR.sum$Date = gsub("2022.05", "May 22", SYBR.sum$Date)
SYBR.sum$Date = gsub("2022.06", "Jun 22", SYBR.sum$Date)
SYBR.sum$Date = gsub("2022.11", "Nov 22", SYBR.sum$Date)

####Combine with pmoA abundance df and plot ####

# Create a named vector for replacements
replacements <- c("Heavy_fraction" = "Sinking", 
                  "Light_fraction" = "Suspended", 
                  "Free_living" = "Free-living")

#Merge bacterial abundance summary and pmoA transcirption abundance dataframes
pmoA_bactab.df = MethTroph_MT_FLvsSuspvsSink.df %>%
  rename(Fraction = Sample_type) %>%
  rename(Date = Sample_date) %>%
  mutate(Fraction = str_replace_all(Fraction, replacements)) %>%
  mutate(station_km = as.numeric(station_km)) %>%
  select(-data_type) %>%
  left_join(SYBR.sum)

#Calculate bacterial abundance normalisation
pmoA_bactab.df$pmoA.norm = pmoA_bactab.df$TranscriptsPerGenome / pmoA_bactab.df$bact.ab
pmoA_bactab.df$pmoA.norm_sd = pmoA_bactab.df$sd / pmoA_bactab.df$bact.ab
pmoA_bactab.df$pmoA.norm_se = pmoA_bactab.df$se / pmoA_bactab.df$bact.ab
pmoA_bactab.df$pmoA.norm_ci = pmoA_bactab.df$ci / pmoA_bactab.df$bact.ab



pmoA_bactab.plt = ggplot(pmoA_bactab.df, aes(y = pmoA.norm, x = station_km, colour = Date, group = Date)) +
  geom_smooth()+
  geom_point()+
  geom_errorbar(aes(ymin = pmoA.norm - pmoA.norm_sd, ymax = pmoA.norm + pmoA.norm_sd, colour = Date),
                width = 3) + 
  ggh4x::facet_grid2(. ~ Fraction, scales = "free_y", independent = "y")+
  scale_y_log10("pmoA abundance (per gene and \nand bacterial abundance normalised)")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
pmoA_bactab.plt


pdf("D:/Functional_R_analysis/Figures/FigureS6_pmoA_bactab.pdf", width = 11, height = 4)
pmoA_bactab.plt
dev.off()



```
#TEP from annotation file
##Set up TEP df
```{r}

#Read in new PP dataframe as a clean data frame
Physicochem.df = readxl::read_xlsx("D:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DOC_uM.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

#Extract relevant columns
PP_totest.df = Physicochem.df  %>% select(all_of(PP_totest.ls))
colnames(PP_totest.df)

#Make sure rownames have been preserved
rownames(PP_totest.df)
dim(PP_totest.df)

#Extract water specific parameters
PP_water.df = PP_totest.df %>%
  subset(Sample_type == "Free_living") %>%
  select(-SPM_mgperL, -TEP_um2perL, -CSP_um2perL, -PTC_mgperL , -POC_mgperL, -PTN_mgperL, -Sample_type) %>%
  distinct()
#Extract particle specific parameters
PP_particle.df = PP_totest.df %>%
  subset(Sample_type!="Free_living") %>%
  select(Associatednumber, PTC_mgperL, POC_mgperL, PTN_mgperL, SPM_mgperL, TEP_um2perL, CSP_um2perL, -Sample_type) %>%
  distinct()

#remove NAs and convert columns to numeric
#PP_water.df = na.omit(PP_water.df)
PP_water.df = as.data.frame(sapply(PP_water.df, as.numeric))

#Apply row numbers from sample IDs
rownames(PP_water.df) = PP_water.df$Associatednumber
PP_water.df$Associatednumber = NULL
rownames(PP_particle.df) = PP_particle.df$Associatednumber
PP_particle.df$Associatednumber = NULL

#Flip so columns are samples for dissimilarity assessment
#PP_water.df = t(PP_water.df)
#PP_particle.df = t(PP_particle.df)




#Extract relevant columns
TEP.df = PP_totest.df  %>% 
  #dplyr::select(all_of(PP_totest.ls)) %>%
  dplyr::select(Associatednumber, Sample_date, station_km, TEP_um2perL) %>%
  distinct()
dim(TEP.df)

#Convert relevant columns to numeric
TEP.df[,c(1,3:4)] = as.data.frame(sapply(TEP.df[,c(1,3:4)], as.character))
TEP.df[,c(1,3:4)] = as.data.frame(sapply(TEP.df[,c(1,3:4)], as.numeric))

TEP.df$Sample_date = gsub("May-21", "May 21", TEP.df$Sample_date)
TEP.df$Sample_date = gsub("Jul-21", "Jul 21", TEP.df$Sample_date)
TEP.df$Sample_date = gsub("Feb-22", "Feb 22", TEP.df$Sample_date)
TEP.df$Sample_date = gsub("May-22", "May 22", TEP.df$Sample_date)
TEP.df$Sample_date = gsub("Jun-22", "Jun 22", TEP.df$Sample_date)
TEP.df$Sample_date = gsub("Nov-22", "Nov 22", TEP.df$Sample_date)

TEP.df$Sample_date = factor(TEP.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))



```
##TEP correlated taxa abundance
```{r}


#Import modified dataframe
motus_final_taxa_metadata <- readRDS(file="D:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS") %>%
  filter(!(str_detect(sampleid, regex("_METAT", ignore_case = TRUE)))) %>% # remove metat mOTUs
  select(mOTU, counts, Associatednumber) %>% # select only relevant columns
  pivot_wider(names_from = mOTU, values_from = counts) # make into wide format
#Make all columns numeric for downstream applications
motus_final_taxa_metadata <- as.data.frame(sapply(motus_final_taxa_metadata,as.numeric))

#Make relative abundance from total counts
TotalmOTUCount.df = readRDS(file="D:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS") %>%
  group_by(sampleid) %>%
  summarise(totalcount = sum(counts)) %>%
  arrange(totalcount, decreasing = F) %>%
  filter(!str_detect(sampleid,"METAT"))
TotalmOTUCount.df  


#Subset to only have matching sample numbers
TEP_mOTU.df = subset(TEP.df, Associatednumber %in% motus_final_taxa_metadata$Associatednumber)


#Run loop for individual genes vs individual physicochemical parameters
Results_TEP_IndTaxa.df = data.frame("Taxa_id" = "DELETEME",
                     "PhysicochemicalParameter" = "DELETEME",
                     "pvalue" = 99999,
                     "rho" = 99999)
i=2
x=7
for (i in 2:length(colnames(motus_final_taxa_metadata))) {
 
    #Extracting names
    M.name = colnames(motus_final_taxa_metadata)[i]
    
    #Run spearman test
    test.tmp = cor.test(motus_final_taxa_metadata[,i], TEP_mOTU.df[,4], method = "s", na.action = na.omit)
    
    #Make df for results
    Results.tmp = data.frame("Taxa_id" = M.name,
                             "PhysicochemicalParameter" = "TEP",
                             "pvalue" = test.tmp$p.value,
                             "rho" = test.tmp$estimate)
    
    #Combine results with previous dataframe
    Results_TEP_IndTaxa.df = rbind(Results_TEP_IndTaxa.df, Results.tmp)
    
    
  }
  
  

#Check results and clean up dataframe
Results_TEP_IndTaxa.df = Results_TEP_IndTaxa.df[-1,]
Results_TEP_IndTaxa.df

#Subset to only significant gene hits
ResultsSign_TEP_IndTaxa.df = subset(Results_TEP_IndTaxa.df, pvalue < 0.05)
dim(ResultsSign_TEP_IndTaxa.df)



#Match mOTU ID with genera and metadata
TEPCorrmOTU.df = readRDS(file="D:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS") %>%
  filter(!(str_detect(sampleid, regex("_METAT", ignore_case = TRUE)))) %>% # remove metat mOTUs
  filter(mOTU %in% ResultsSign_TEP_IndTaxa.df$Taxa_id)





sort(unique(TEPCorrmOTU.df$genus))

TEPCorrmOTU.df$date = gsub("Mai", "May", TEPCorrmOTU.df$date)  

TEPCorrmOTU.df$date = factor(TEPCorrmOTU.df$date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Separate into FL vs PA, rather than the three fractions
TEPCorrmOTU.df$sample_type = gsub("Heavy_fraction", "PA", TEPCorrmOTU.df$sample_type)
TEPCorrmOTU.df$sample_type = gsub("Light_fraction", "PA", TEPCorrmOTU.df$sample_type)
TEPCorrmOTU.df$sample_type = gsub("Free_living", "PA", TEPCorrmOTU.df$sample_type)

TEPCorrmOTU.sum = Rmisc::summarySE(TEPCorrmOTU.df, measurevar = "counts", groupvars = c("phylum", "class", "order", "family", "genus", "species", "mOTU",
                                                                                           "station_km", "date", "sample_type", "sampleid",
                                                                                           "salinity"))
TEPCorrmOTU.sum$taxac = paste0(TEPCorrmOTU.sum$phylum, ";", 
                                 TEPCorrmOTU.sum$class, ";", 
                                 TEPCorrmOTU.sum$order, ";", 
                                 TEPCorrmOTU.sum$family, ";", 
                                 TEPCorrmOTU.sum$genus, ";", 
                                 TEPCorrmOTU.sum$species)
#Keep for records
#write.csv(TEPCorrmOTU.sum, "D:/Functional_R_analysis/TEP_mOTU.csv")

#TEPCorrmOTU.sum = read.csv("D:/Functional_R_analysis/TEP_mOTU.csv")

####Plot abundances ####


TEPTaxaAbund.sum = TEPCorrmOTU.sum %>%
  left_join(TotalmOTUCount.df, by = c("sampleid" = "sampleid")) %>%
  Rmisc::summarySE(., measurevar = "counts", groupvars = c("phylum", "class", "order", "family", "genus", "species", "taxac", "mOTU",
                                                           "station_km", "date", "sample_type", "sampleid", "totalcount",
                                                            "salinity")) %>%
  mutate(rel_ab = counts / totalcount)
                                                                      
TEPTaxaAbund.sum$taxac = paste0(TEPTaxaAbund.sum$phylum, ";", 
                                 TEPTaxaAbund.sum$class, ";", 
                                 TEPTaxaAbund.sum$order, ";", 
                                 TEPTaxaAbund.sum$family, ";", 
                                 TEPTaxaAbund.sum$genus, ";", 
                                 TEPTaxaAbund.sum$species)


TEPTaxaAbund.sum = Rmisc::summarySE(TEPTaxaAbund.sum, measurevar = "rel_ab", groupvars = c("taxac", "mOTU",
                                                                                           "station_km", "date", "sample_type",
                                                                                           "salinity"))

test = TEPTaxaAbund.sum %>%
  mutate(mOTU = str_replace_all(mOTU, "_", " "))


  
test$date = factor(test$date,
                   levels = c("May 21",
                              "Jul 21",
                              "Feb 22",
                              "May 22",
                              "Jun 22",
                              "Nov 22"))

#Add grouping to dataframe
test$groups = paste0(test$sample_type, "_", test$date)

TEP_mOTU.plt = ggplot(test, aes(x = salinity, 
                                y = rel_ab*100, 
                                shape = sample_type, 
                                colour = date, 
                                group = groups)) +
  geom_smooth(se = FALSE) +
  geom_point(size = 5) +
  ggh4x::facet_wrap2(vars(mOTU))+
  scale_x_reverse("Salinity (PSU)")+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_shape_manual("Fraction", values = c(17))+
  ylab("Relatve abundance of TEP \nassociated mOTUs (%)")+
  My_Theme + 
  theme(strip.background = element_blank())
TEP_mOTU.plt 


pdf("D:/Functional_R_analysis/Figures/FigureSXX_TEPTaxa.pdf", width = 50, height = 30)
TEP_mOTU.plt
dev.off()

Rel_ab.sum = TEPTaxaAbund.sum %>%
  group_by(mOTU) %>%
  summarise(mean_val = (mean(rel_ab, na.rm = T)*100),
            median_val = (median(rel_ab, na.rm = T)*100))

Rel_ab.sum




####Salinity correlations ####

TEPTaxaAbund.sum = TEPCorrmOTU.sum %>%
  left_join(TotalmOTUCount.df, by = c("sampleid" = "sampleid")) %>%
  Rmisc::summarySE(., measurevar = "counts", groupvars = c("phylum", "class", "order", "family", "genus", "species", "taxac", "mOTU",
                                                           "station_km", "date", "sample_type", "sampleid", "totalcount",
                                                            "salinity")) %>%
  mutate(rel_ab = counts / totalcount)
                                                                      
TEPTaxaAbund.sum$taxac = paste0(TEPTaxaAbund.sum$phylum, ";", 
                                 TEPTaxaAbund.sum$class, ";", 
                                 TEPTaxaAbund.sum$order, ";", 
                                 TEPTaxaAbund.sum$family, ";", 
                                 TEPTaxaAbund.sum$genus, ";", 
                                 TEPTaxaAbund.sum$species)


cor.test(TEPTaxaAbund.sum$rel_ab, TEPTaxaAbund.sum$salinity, method = "s")
#Significantly increased abundance in response to salinity

Results_salcor.df = data.frame("Taxa" = "DELETEME",
                               "rho" = 9999,
                               "p.value" = 9999)

taxa.var = unique(TEPTaxaAbund.sum$taxac)[1]
for (taxa.var in unique(TEPTaxaAbund.sum$taxac)) {
  
  tmp.df = subset(TEPTaxaAbund.sum, taxac == taxa.var)
  
  tmp.cor = cor.test(tmp.df$counts, tmp.df$salinity, method = "s")
  
  tmp.res = data.frame("Taxa" = taxa.var,
                       "rho" = tmp.cor$estimate,
                       "p.value" = tmp.cor$p.value)
  
  
  Results_salcor.df = rbind(Results_salcor.df, tmp.res)
  
}
rm(tmp.df, tmp.cor, tmp.res, taxa.var)
Results_salcor.df = Results_salcor.df[-1,] %>%
  filter(p.value < 0.05)
Results_salcor.df
```
##TEP taxa correlated gene correlations
```{r}

#### Isolate relevant taxa for gene analysis ####

#Import mOTU ID lists that lets us link them to MAGs, and combine them
mag_nmOTUs.df = read.csv("D:/Functional_R_analysis/mag_2_new_motus", header = F, sep = "\t") %>%
  separate_rows(V2, sep = ";") %>%
  dplyr::rename(mOTU_ID = V1) %>%
  dplyr::rename(MAG_ID = V2)

mag_emOTUs.df = read.csv("D:/Functional_R_analysis/mag_2_existing_motus", header = F, sep = "\t") %>%
  separate_rows(V2, sep = ";") %>%
  dplyr::select(V1, V2) %>%
  dplyr::rename(mOTU_ID = V2) %>%
  dplyr::rename(MAG_ID = V1)

mOTUs2MAGs = rbind(mag_nmOTUs.df, mag_emOTUs.df) %>%
  filter(mOTU_ID!="NotEnoughMGs")


#TEP correlated taxa
TEPCorrmOTU.sum$mOTU

TEP_MAGs.ls = TEPCorrmOTU.sum %>%
  select(mOTU) %>%
  distinct() %>%
  left_join(mOTUs2MAGs, by = c("mOTU" = "mOTU_ID")) %>%
  select("MAG_ID") %>%
  distinct() %>%
  as.list()
TEP_MAGs.ls

####Use annot file ####


amoAClean_geneabund_KO = annot %>%
  drop_na(CAZY) %>% # remove all genes not in the CAZY database
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  dplyr::select(gene_cluster, CAZY, genome) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(CAZY, genome) %>% #aggregate the data by the CAZY ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

#Make new column were it's TEP vs others
TEP_YN_genomes = amoAClean_geneabund_KO %>%
  pivot_longer(!c(CAZY, genome), names_to = "sample", values_to = "abundance") %>%
  mutate(abundance = abundance/1000) %>%
  filter(!str_detect(CAZY, "NA---NA")) %>%
  mutate(TEP_flag = ifelse(genome %in% TEP_MAGs.ls[[1]], "Y", "N"))

test = TEP_YN_genomes %>%
  group_by(CAZY, genome, TEP_flag) %>%
  summarise(avg_value_above0 = mean(abundance[abundance > 0], na.rm = TRUE))
 

TEP.mdl = aov(avg_value_above0 ~ TEP_flag * CAZY, test)
summary(TEP.mdl)
rstatix::eta_squared(TEP.mdl)
#eta2 (combined) = 0.0032
#p < 0.001

posthoc_results <- TukeyHSD(TEP.mdl, which = "TEP_flag:CAZY")
print(posthoc_results)
tmp = posthoc_results$`TEP_flag:CAZY` %>%
  as.data.frame()%>%
  rownames_to_column(var = "comparison") %>%
  separate(col = comparison, sep = "-N:", into = c("Y_group", "N_group")) %>%
  filter(str_detect(Y_group, "^Y:") & str_detect(N_group, "^cazy:")) %>%
  mutate(Y_group = str_remove(Y_group, "^Y:")) %>%
  filter(Y_group == N_group & `p adj` < 0.05)
tmp


```


#Volcano plots - suspended vs sinking
##Transcripts per gene volcano plot

```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  ##mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO, DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!c(KO, DESCRIPTION), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21" & Station != 'BunthausSpitze' & Sample_type!="Free_living") %>% #remove sample from BunthausSpitze and Nov 21, and FL sample type
  ungroup() %>%
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "F:/Functional_R_analysis/moAClean_CO2CH4_OccurrenceFiltered_V2_TG.csv")

#amoAClean_CO2CH4_tbl_long = read.csv( "E:/Functional_R_analysis/moAClean_CO2CH4_OccurrenceFiltered_V2_TG.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)







####Run Statistical Fraction test####

#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Remove samples for which we have no metatranscriptomes
CO2CH4_TG.df = subset(CO2CH4_TG.df, Associatednumber > 116)
CO2CH4_TG.df = subset(CO2CH4_TG.df, TranscriptsPerGenome < 999999999)

#Remove samples for which sequencing failed
CO2CH4_TG.df = subset(CO2CH4_TG.df, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
dim(CO2CH4_TG.df)

#Convert from wide to long format
#CO2CH4_TG.lng = gather(CO2CH4_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
#dim(CO2CH4_TG.lng)


#Extract list of genes
uniquegenes.ls = unique(CO2CH4_TG.lng$KO)
uniquegenes.ls

#Make results table for LH
Results_LH.df = data.frame(Gene = "DELETEME",
                       Susp.TranscriptsPerGenome = 9999,
                       Sink.TranscriptsPerGenome = 9999,
                       Sample_type.W = 9999,
                       Sample_type.r = 9999,
                       Sample_type.cliffdelta = 9999,
                       Sample_type.p = 9999)

i="K22213"
i="K15737"
#Get significant differences between metagenomes and metatranscriptomes and then Suspended and Sinking particles
for (i in uniquegenes.ls) {
  print(paste0("Working on ", i, ". Number ", which(uniquegenes.ls == i), " out of ", length(uniquegenes.ls)))
  
  #Subset to only one KO entry
  tmp.sbst = subset(CO2CH4_TG.df, KO == i & Sample_date!="Nov 21")
  
  #Remove samples with missing metagenome information
  tmp.sbst$TranscriptsPerGenome = as.numeric(tmp.sbst$TranscriptsPerGenome)
  
  #Add more info - remove NA's and Infinite numbers
  tmp.sbst = tmp.sbst %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0))%>%
    filter(Sample_type!="Free_living")
  
  
  
  #Run significance test between FL and PA 
  
  #Separate into suspended and sinking
  tmp.L = subset(tmp.sbst, Sample_type == "Light_fraction")
  tmp.H = subset(tmp.sbst, Sample_type == "Heavy_fraction")
  
  if (length(unique(tmp.sbst$Sample_type)) > 1) {
    
  #Run significance test between FL and PA 
  tmp.w = wilcox.test(formula = tmp.sbst$TranscriptsPerGenome ~ tmp.sbst$Sample_type, conf.int = TRUE)

  #Bug hunting
  #print(paste0("We have ", length(unique(tmp.sbst)), " samples"))
  
  # Calculate effect size (r)
  W <- tmp.w$statistic
  n1 <- length(tmp.L$Associatednumber)
  n2 <- length(tmp.H$Associatednumber)
  
  # Ensure n1 and n2 are greater than or equal to 3 before calculating Cliff's delta
if (n1 >= 3 & n2 >= 3) {
  r <- W / (n1 * n2)
  cliff_delta <- effsize::cliff.delta(tmp.L$TranscriptsPerGenome, tmp.H$TranscriptsPerGenome)
  cliff_delta_val = cliff_delta$estimate
} else {
  r <- NA  # Assign NA or another placeholder value
  cliff_delta_val <- NA
  warning("Not enough values in one of the groups for Cliff's delta calculation.")
}
  
  
  #Make temporary dataframe with results
  tmp.res = data.frame(Gene = paste0(i),
                       Susp.TranscriptsPerGenome = mean(tmp.L$TranscriptsPerGenome, na.rm = T),
                       Sink.TranscriptsPerGenome = mean(tmp.H$TranscriptsPerGenome, na.rm = T),
                       Sample_type.W = tmp.w$statistic,
                       Sample_type.r = r,
                       Sample_type.cliffdelta = cliff_delta_val,
                       Sample_type.p = tmp.w$p.value)
  
  
  Results_LH.df = rbind(Results_LH.df, tmp.res)
  }
  
}
#Check results and clean up dataframe
Results_LH.df = Results_LH.df[-1,]
Results_LH.df

#Subset to only significant gene hits
Results_SignLH.df = subset(Results_LH.df, Sample_type.p < 0.05)
dim(Results_SignLH.df)

Results_SignLH_MT.df = Results_SignLH.df

#For record keeping
#write.csv(Results_SignLH.df, "F:/Functional_R_analysis/Significant_LHdiff_MT.csv")


#### Make plot ####
#Results_SignLH_MT.df = read.csv("D:/Functional_R_analysis/Significant_LHdiff_MT.csv", row.names = 1)

#Subset to top 25 and check it worked
Top25_Fraction.df = Results_SignLH_MT.df #%>% filter(Sample_type.r > quantile(Sample_type.r, 0.7))
dim(Top25_Fraction.df)

Top25_Fraction.df

#Add calculation for better context
Top25_Fraction.df$Diff = Top25_Fraction.df$Susp.TranscriptsPerGenome / Top25_Fraction.df$Sink.TranscriptsPerGenome

test = Top25_Fraction.df %>%
  left_join(annot, by = c("Gene" = "KO"), relationship = "many-to-many") %>% # add gene information
  distinct() %>% #remove duplicate rows
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) #separate description


dim(test)
dim(Top25_Fraction.df)

# Plot preferences
Top25_Fraction_MT.plt = ggplot(test, aes(x=Diff, y=Sample_type.r, colour=Sample_type.p, label = SName)) + 
  geom_point(size = 3) +
  scale_colour_gradient2("p-value", low= "green", mid = "black", high = "red", na.value = "black", midpoint = 0.03, limits = c(0.01, 0.05))+
  ggrepel::geom_label_repel(aes(fill = "KILLME")) +
  scale_fill_manual(values = "white")+
  ggtitle("CO2/CH4 particle transcripts per gene differences")+
  ylab("Wilcoxon R value")+
  xlab("Suspended / Sinking Transcripts per Gene")+
  #geom_vline(xintercept = 1)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+ 
  guides(fill="none")
# visualise
Top25_Fraction_MT.plt

#Save plots
pdf("F:/Functional_R_analysis/Figures/CO2CH4_MT_IndivGenes.pdf", width = 5, height = 4)
Top25_Fraction_MT.plt
dev.off()

#png("E:/Functional_R_analysis/Figures/CO2CH4_MT_IndivGenes.png", width = 8, height = 7, units = "in", res = 120)
#Top25_Fraction_MT.plt
#dev.off()

saveRDS(Top25_Fraction_MT.plt, "F:/Functional_R_analysis/Figures/CO2CH4_MT_IndivGenes.RDS")
 
```

##Metagenomes volcano plot


```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO, DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!c(KO, DESCRIPTION), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG' & Sample_type!="Free_living") %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)

dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "F:/Functional_R_analysis/amoAClean_CO2CH4_OccurrenceFiltered_V2_MG.csv")
#amoAClean_CO2CH4_tbl_long = read.csv("F:/Functional_R_analysis/moAClean_CO2CH4_OccurrenceFiltered_V2_MG.csv")

####Run Statistical Fraction test####


#Extract list of genes
uniquegenes.ls = unique(amoAClean_CO2CH4_tbl_long$KO)
uniquegenes.ls

#Make results table for LH
Results_LH.df = data.frame(Gene = "DELETEME",
                       Susp.Metagenomes = 9999,
                       Sink.Metagenomes = 9999,
                       Sample_type.W = 9999,
                       Sample_type.r = 9999,
                       Sample_type.cliffdelta = 9999,
                       Sample_type.p = 9999)

i="K01576"
#Get significant differences between metagenomes and metatranscriptomes and then Suspended and Sinking particles
for (i in uniquegenes.ls) {
  print(paste0("Working on ", i, ". Number ", which(uniquegenes.ls == i), " out of ", length(uniquegenes.ls)))
  
  #Subset to only one KO entry
  tmp.sbst = subset(amoAClean_CO2CH4_tbl_long, KO == i & Sample_date!="Nov 21")
  
  #Remove samples with missing metagenome information
  tmp.sbst$counts = as.numeric(tmp.sbst$counts)
  
  #Add more info - remove NA's and Infinite numbers
  tmp.sbst = tmp.sbst %>%
    filter(Sample_type!="Free_living")
  
  
  
  #Run significance test between FL and PA 
  
  #Separate into suspended and sinking
  tmp.L = subset(tmp.sbst, Sample_type == "Light_fraction")
  tmp.H = subset(tmp.sbst, Sample_type == "Heavy_fraction")
  
  if (length(unique(tmp.sbst$Sample_type)) > 1) {
    
  #Run significance test between FL and PA 
  tmp.w = wilcox.test(formula = tmp.sbst$counts ~ tmp.sbst$Sample_type, conf.int = TRUE)

  #Bug hunting
  #print(paste0("We have ", length(unique(tmp.sbst)), " samples"))
  
  # Calculate effect size (r)
  W <- tmp.w$statistic
  n1 <- length(tmp.L$Associatednumber)
  n2 <- length(tmp.H$Associatednumber)
  
  # Ensure n1 and n2 are greater than or equal to 3 before calculating Cliff's delta
if (n1 >= 3 & n2 >= 3) {
  r <- W / (n1 * n2)
  cliff_delta <- effsize::cliff.delta(tmp.L$counts, tmp.H$counts)
  cliff_delta_val = cliff_delta$estimate
} else {
  r <- NA  # Assign NA or another placeholder value
  cliff_delta_val <- NA
  warning("Not enough values in one of the groups for Cliff's delta calculation.")
}
  
  
  #Make temporary dataframe with results
  tmp.res = data.frame(Gene = paste0(i),
                       Susp.Metagenomes = mean(tmp.L$counts, na.rm = T),
                       Sink.Metagenomes = mean(tmp.H$counts, na.rm = T),
                       Sample_type.W = tmp.w$statistic,
                       Sample_type.r = r,
                       Sample_type.cliffdelta = cliff_delta_val,
                       Sample_type.p = tmp.w$p.value)
  
  
  Results_LH.df = rbind(Results_LH.df, tmp.res)
  }
  
}
#Check results and clean up dataframe
Results_LH.df = Results_LH.df[-1,]
Results_LH.df

#Subset to only significant gene hits
Results_SignLH.df = subset(Results_LH.df, Sample_type.p < 0.05)
dim(Results_SignLH.df)

#For record keeping
#write.csv(Results_SignLH.df, "F:/Functional_R_analysis/Significant_LHdiff_MG.csv")




####Make Gene plot ####

Results_SignLH_MG.df = read.csv("D:/Functional_R_analysis/Significant_LHdiff_MG.csv", row.names = 1)
dim(Results_SignLH_MG.df)

Top25_Fraction.df = Results_SignLH_MG.df #%>% filter(Sample_type.r > quantile(Sample_type.r, 0.90))
dim(Top25_Fraction.df)

ggplot(Top25_Fraction.df, aes(y = -log10(Sample_type.p), x = log2(Sample_type.r)))+
  geom_point()

#Add calculation for better context
Top25_Fraction.df$Diff = Top25_Fraction.df$Susp.Metagenomes / Top25_Fraction.df$Sink.Metagenomes

test = Top25_Fraction.df %>%
  left_join(annot, by = c("Gene" = "KO"), relationship = "many-to-many") %>% # add gene information
  distinct() %>% #remove duplicate rows
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) #separate description

dim(test)
dim(Top25_Fraction.df)

# Plot preferences
Top25_Fraction_MG.df = ggplot(test, aes(x=Diff, y=Sample_type.r, colour=Sample_type.p, label = SName)) + 
  geom_point(size = 3) +
  scale_colour_gradient2("p-value", low= "green", mid = "black", high = "red", na.value = "black", midpoint = 0.03, limits = c(0.01, 0.05))+
  ggrepel::geom_label_repel(aes(fill = "KILLME"), max.overlaps = 100) +
  scale_fill_manual(values = "white")+
  ggtitle("CO2/CH4 LH particle metagenome differences")+
  ylab("Wilcoxon R value")+
  xlab("Suspended / Sinking Gene Abundance")+
  My_Theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+ 
  guides(fill="none")
# visualise
Top25_Fraction_MG.df 

#Save plots
pdf("F:/Functional_R_analysis/Figures/CO2CH4_MG_IndivGenes.pdf", width = 5, height = 4)
Top25_Fraction_MG.df
dev.off()

#png("E:/Functional_R_analysis/Figures/CO2CH4_MG_IndivGenes.png", width = 8, height = 7, units = "in", res = 120)
#Top25_Fraction_MG.df
#dev.off()



 
```


##Combine Lifestyle differences and make table
```{r}

Results_SignLH_MG.df = read.csv("F:/Functional_R_analysis/Significant_LHdiff_MG.csv", row.names = 1)
dim(Results_SignLH_MG.df)
Results_SignLH_MT.df = read.csv("F:/Functional_R_analysis/Significant_LHdiff_MT.csv", row.names = 1)
dim(Results_SignLH_MT.df)


#Add calculation for better context
Results_SignLH_MG.df$Diff = Results_SignLH_MG.df$Susp.Metagenomes / Results_SignLH_MG.df$Sink.Metagenomes
Results_SignLH_MT.df$Diff = Results_SignLH_MT.df$Susp.TranscriptsPerGenome / Results_SignLH_MT.df$Sink.TranscriptsPerGenome

#Add data type column
Results_SignLH_MG.df$Data_type = "Metagenomes"
Results_SignLH_MT.df$Data_type = "TranscriptsPerGene"

Results_SignLH_MG.df = Results_SignLH_MG.df %>%
  select(Gene, Data_type, Diff, Sample_type.r, Sample_type.p)
Results_SignLH_MT.df = Results_SignLH_MT.df %>%
  select(Gene, Data_type, Diff, Sample_type.r, Sample_type.p)

Results_SignLH.df = rbind(Results_SignLH_MG.df, Results_SignLH_MT.df)
dim(Results_SignLH.df)



Detail_SignLH.df = Results_SignLH.df %>%
  left_join(annot, by = c("Gene" = "KO"), relationship = "many-to-many") %>% # add gene information
  distinct() %>% #remove duplicate rows
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  select(Gene, Data_type, Diff, Sample_type.r, Sample_type.p, ENZYME, SName, LName)

colnames(Detail_SignLH.df)

#Because German computer are stupid
Detail_SignLH.df$ENZYME = gsub(";", "&", Detail_SignLH.df$ENZYME)
Detail_SignLH.df$Diff = as.character(Detail_SignLH.df$Diff)
Detail_SignLH.df$Sample_type.r = as.character(Detail_SignLH.df$Sample_type.r)
Detail_SignLH.df$Sample_type.p = as.character(Detail_SignLH.df$Sample_type.p)

write.table(Detail_SignLH.df, "D:/Functional_R_analysis/Final_Figures_Tables/TableSXX_LifestyleGenes_Raw.csv", sep = "\t")
Detail_SignLH.df = readxl::read_xlsx("F:/Functional_R_analysis/Final_Figures_Tables/TableSXX_LifestyleGenes_Raw.csv")
```



#Volcano plots - FLvsPA
Missing absence data so not trustworthy, and if I introduce it, it can cause problems with infinites.
##Transcripts per gene volcano plot

```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()

#Correct abundance
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#write.csv(amoAClean_CO2CH4_tbl_long, "E:/Functional_R_analysis/moAClean_CO2CH4_OccurrenceFiltered_V2_TG.csv")

#amoAClean_CO2CH4_tbl_long = read.csv( "E:/Functional_R_analysis/moAClean_CO2CH4_OccurrenceFiltered_V2_TG.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long[ , ! names(amoAClean_CO2CH4_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long)
dim(CO2CH4_TG.df)







####Run Statistical Fraction test####

#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

#Change sample_type for FLvsPA
CO2CH4_TG.df$Sample_type = gsub("Free_living", "FL", CO2CH4_TG.df$Sample_type)
CO2CH4_TG.df$Sample_type = gsub("Light_fraction", "PA", CO2CH4_TG.df$Sample_type)
CO2CH4_TG.df$Sample_type = gsub("Heavy_fraction", "PA", CO2CH4_TG.df$Sample_type)


#Extract list of genes
uniquegenes.ls = unique(CO2CH4_TG.lng$KO)
uniquegenes.ls

#Make results table for metagenome vs metatranscriptomes
#Results_MT.df = data.frame(Gene = "DELETEME",
 #                       Sample_type.TranscriptsPerGenome = 9999,
  #                      Sample_type.r = 9999,
   #                     Sample_type.p = 9999)
#Make results table for FLvsPA
Results_FLvsPA.df = data.frame(Gene = "DELETEME",
                           FL.TranscriptsPerGenome = 9999,
                           PA.TranscriptsPerGenome = 9999,
                           Sample_type.W = 9999,
                           Sample_type.r = 9999,
                           Sample_type.cliffdelta = 9999,
                           Sample_type.p = 9999)

i="K22213"
i="K15737"
#Get significant differences between FL and PA transcription of individual carbon genes
for (i in uniquegenes.ls) {
  print(paste0("Working on ", i, ". Number ", which(uniquegenes.ls == i), " out of ", length(uniquegenes.ls)))
  
  #Subset to only one KO entry
  tmp.sbst = subset(CO2CH4_TG.df, KO == i & Sample_date!="Nov 21")
  
  #Remove samples with missing metagenome information
  tmp.sbst$TranscriptsPerGenome = as.numeric(tmp.sbst$TranscriptsPerGenome)
  
  #Add more info - remove NA's and Infinite numbers
  tmp.sbst = tmp.sbst %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0))
  
  
  
  #Run significance test between FL and PA 
  
  #Separate into FL and PA
  tmp.FL = subset(tmp.sbst, Sample_type == "FL")
  tmp.PA = subset(tmp.sbst, Sample_type == "PA")
  
  if (length(unique(tmp.sbst$Sample_type)) > 1) {
    
  #Run significance test between FL and PA 
  tmp.w = wilcox.test(formula = tmp.sbst$TranscriptsPerGenome ~ tmp.sbst$Sample_type, conf.int = TRUE)

  #Bug hunting
  #print(paste0("We have ", length(unique(tmp.sbst)), " samples"))
  
  # Calculate effect size (r)
  W <- tmp.w$statistic
  n1 <- length(tmp.FL)
  n2 <- length(tmp.PA)
  r <- W / (n1 * n2)
  
  cliff_delta <- effsize::cliff.delta(tmp.FL$TranscriptsPerGenome, tmp.PA$TranscriptsPerGenome)
  
  #Make temporary dataframe with results
  tmp.res = data.frame(Gene = paste0(i),
                       FL.TranscriptsPerGenome = mean(tmp.FL$TranscriptsPerGenome, na.rm = T),
                       PA.TranscriptsPerGenome = mean(tmp.PA$TranscriptsPerGenome, na.rm = T),
                       Sample_type.W = tmp.w$statistic,
                       Sample_type.r = r,
                       Sample_type.cliffdelta = cliff_delta$estimate,
                       Sample_type.p = tmp.w$p.value)
  
  
  Results_FLvsPA.df = rbind(Results_FLvsPA.df, tmp.res)
  
  }
}


#Check results and clean up dataframe
Results_FLvsPA.df = Results_FLvsPA.df[-1,]
Results_FLvsPA.df

#Subset to only significant gene hits
#Results_SignMT.df = subset(Results_MT.df, Sample_type.p < 0.05)
#dim(Results_SignMT.df)
Results_Sign_FLvsPA.df = subset(Results_FLvsPA.df, Sample_type.p < 0.05)
dim(Results_Sign_FLvsPA.df)

#For record keeping
#write.csv(Results_Sign_FLvsPA.df, "D:/Functional_R_analysis/Significant_FLvsPA_MT.csv")
Results_Sign_FLvsPA_MT.df = read.csv("D:/Functional_R_analysis/Significant_FLvsPA_MT.csv", row.names = 1)


#### Make plot ####
Results_Sign_FLvsPA_MT.df = read.csv("D:/Functional_R_analysis/Significant_FLvsPA_MT.csv", row.names = 1)

#Subset to top 25 and check it worked
Top25_Fraction.df = Results_Sign_FLvsPA_MT.df %>% 
  arrange(desc(abs(Sample_type.cliffdelta)))# %>%  # Order by absolute distance from 0
  #slice_head(n = 25)  # Select the top 25 rows
dim(Top25_Fraction.df)

Top25_Fraction.df

#Add calculation for better context
Top25_Fraction.df$Diff = Top25_Fraction.df$FL.TranscriptsPerGenome / Top25_Fraction.df$PA.TranscriptsPerGenome

test = Top25_Fraction.df %>%
  left_join(annot, by = c("Gene" = "KO"), relationship = "many-to-many") %>% # add gene information
  distinct() %>% #remove duplicate rows
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) #separate description


dim(test)
dim(Top25_Fraction.df)

# Plot preferences
Top25_Fraction_MT.plt = ggplot(test, aes(x=Diff, y=Sample_type.p, colour=Sample_type.p, label = SName)) + 
  geom_point(size = 3) +
  scale_colour_gradient2("p value", low= "green", mid = "black", high = "magenta", na.value = "red")+
  ggrepel::geom_label_repel(aes(fill = "KILLME")) +
  scale_fill_manual(values = "white")+
  ggtitle("CO2/CH4 particle transcripts per gene differences")+
  #ylab("Cliff's delta")+
  scale_x_log10()+
  scale_y_reverse()+
  xlab("Free-living / Particle-associated transcripts per gene")+
  geom_vline(xintercept = 1)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+ 
  guides(fill="none")
# visualise
Top25_Fraction_MT.plt

#Save plots
pdf("D:/Functional_R_analysis/Figures/CO2CH4_MT_IndivGenes_FLvsPA.pdf", width = 8, height = 7)
Top25_Fraction_MT.plt
dev.off()

png("E:/Functional_R_analysis/Figures/CO2CH4_MT_IndivGenes_FLvsPA.png", width = 8, height = 7, units = "in", res = 120)
Top25_Fraction_MT.plt
dev.off()

saveRDS(Top25_Fraction_MT.plt, "F:/Functional_R_analysis/Figures/CO2CH4_MT_IndivGenes_FLvsPA.RDS")
 
```

Interpreting the correlation coefficient
0.1 - 0.3	Small effect
0.3 - 0.5	Medium effect
> 0.5	Large effect


Interpreting Cliffâs Delta (d):
Effect Size (d)	Interpretation
0.147	Small
0.330	Medium
0.474	Large


PA high abundance
poxB control of acetate production under aerobic conditions (Lorquet et al., 2004)  - upregulated in response to general stress (Weber et al., 2005)
ectD is required for the main ectoine hydroxylase activity in C. salexigens. â stress response to temperature and salt (GarcÃ­a-Estepa et al., 2006)
pdhA - cetyl-CoA and CO(2), and provides the primary link between glycolysis and the tricarboxylic acid (TCA) cycle, and is therefore essential to cell growth (Spalding & Prigge, 2010)
	strongly inhibited under anaerobic conditions (Lorquet et al., 2004)
	Upregulated under nutrient starvation conditions (Betts et al., 2002)
gcl is the enzyme for the rate-limiting step of synthesising glutathione, a compound vital for cell survival, as it acts as a cellular antioxidant (Sigler et al., 1999; H. Zhang et al., 2020)
fdhA produces methane from formate and other substrates and is therefore located in methanogens, but expression is controlled by H2 concentrations rather than formate (Wood et al., 2003)

Suspended high abundance
oorB is part of the central energy metabolism pathway (TCA/Glycolysis/gluconeogenesis) - downregulated under hyperosmotic stress (Cameron et al., 2012) - so things are good in this case 
oadA plays a crucial role in citrate utilisation and fermentation pathways - expression requires anaerobic conditions, and the presence of Na+ and citrate (Bott et al., 1995; Meyer et al., 1997)
pmoA is a large component of the methane metabolism pathway and represent a large methane sink in the ecosystem - regulated by CH4 abundance (RodrÃ­guez et al., 2019)
Pepck â glucose production (gluconeogenesis) and produces CO2 - decreased expression during DNA damage events (Kim et al., 2011)
Fdh â reversible formate <-> CO2, de novo nucleotide (purine) biosynthesis, produces methane from formate and other substrates and is therefore located in methanogens, but expression is controlled by H2 concentrations rather than formate (Wood et al., 2003)

##Metagenomes volcano plot


```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG' & Sample_type!="Free_living") %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  group_by(KO) %>% 
  mutate(occurrence = sum(abundance)/nsamples) %>% 
  ungroup() %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  filter(occurrence > 0.2) %>%
  distinct()
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)

dim(amoAClean_CO2CH4_tbl_long)


####Run Statistical Fraction test####


#Extract list of genes
uniquegenes.ls = unique(amoAClean_CO2CH4_tbl_long$KO)
uniquegenes.ls

#Make results table for metagenome L vs H
Results_FLvsPA.df = data.frame(Gene = "DELETEME",
                           FL.Metagenomes = 9999,
                           PA.Metagenomes = 9999,
                           Sample_type.r = tmp.m$statistic,
                           Sample_type.p = 9999)

i="K01576"
#Get significant differences between metagenomes and metatranscriptomes and then FL and PA
for (i in uniquegenes.ls) {
  print(paste0("Working on ", i, ". Number ", which(uniquegenes.ls == i), " out of ", length(uniquegenes.ls)))
  
  #Subset to only one KO entry
  tmp.sbst = subset(amoAClean_CO2CH4_tbl_long, KO == i & Sample_date!="Nov 21")
  
  #ENsure counts are numeric
  tmp.sbst$counts = as.numeric(tmp.sbst$counts)
  
  #Add more info - remove NA's and Infinite numbers
  tmp.sbst = tmp.sbst %>%
  mutate_at(c("counts"), ~replace(., is.na(.), 0))
  
  
  
  #Run significance test between FL and PA
  
  #Separate into FL and PA
  tmp.l = subset(tmp.sbst, Sample_type == "FL")
  tmp.h = subset(tmp.sbst, Sample_type == "PA")
  #Subset for dataframes to match
  tmp.l = subset(tmp.l, BioSample!= "SAMEA110290340" & BioSample!= "SAMEA112714817")
  tmp.h = subset(tmp.h, BioSample!= "SAMEA112714807")
  
  #tmp.l[,c(1,7,11,14,25,29:32)]
  #tmp.h[,c(1,7,11,14,25,29:32)]
  #print(paste0("FL have ", dim(tmp.l)[1], " samples, and PA have ",  dim(tmp.h)[1]))
  
  #Run mantel test
  test1 = vegdist(tmp.l$counts, method = "euclidean")
  test2 = vegdist(tmp.h$counts, method = "euclidean")
  tmp.m = vegan::mantel(test1, test2)

  #print("Test")
  
  #Make temporary dataframe with results
  tmp.res = data.frame(Gene = paste0(i),
                       FL.Metagenomes = mean(tmp.l$counts, na.rm = T),
                       PA.Metagenomes = mean(tmp.h$counts, na.rm = T),
                       Sample_type.r = tmp.m$statistic,
                       Sample_type.p = tmp.m$signif)
  
  
  Results_FLvsPA.df = rbind(Results_FLvsPA.df, tmp.res)
  
}
#Check results and clean up dataframe
Results_FLvsPA.df = Results_FLvsPA.df[-1,]
Results_FLvsPA.df

#Subset to only significant gene hits
Results_Sign_FLvsPA.df = subset(Results_FLvsPA.df, Sample_type.p < 0.05)
dim(Results_Sign_FLvsPA.df)

#For record keeping
#write.csv(Results_Sign_FLvsPA.df, "F:/Functional_R_analysis/Significant_FLvsPA_MG.csv")




####Make Gene plot ####

Results_Sign_FLvsPA_MG.df = read.csv("E:/Functional_R_analysis/Significant_FLvsPA_MG.csv", row.names = 1)
dim(Results_Sign_FLvsPA_MG.df)

Top25_Fraction.df = Results_Sign_FLvsPA_MG.df %>% filter(Sample_type.r > quantile(Sample_type.r, 0.90))
dim(Top25_Fraction.df)

ggplot(Top25_Fraction.df, aes(y = -log10(Sample_type.p), x = log2(Sample_type.r)))+
  geom_point()

#Add calculation for better context
Top25_Fraction.df$Diff = Top25_Fraction.df$FL.Metagenomes / Top25_Fraction.df$PA.Metagenomes

test = Top25_Fraction.df %>%
  left_join(annot, by = c("Gene" = "KO"), relationship = "many-to-many") %>% # add gene information
  distinct() %>% #remove duplicate rows
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) #separate description

dim(test)
dim(Top25_Fraction.df)

# Plot preferences
Top25_Fraction_MG.df = ggplot(test, aes(x=Diff, y=Sample_type.r, colour=Sample_type.p, label = SName)) + 
  geom_point(size = 3) +
  scale_colour_gradient2("p value", low= "green", mid = "black", high = "magenta", na.value = "red")+
  ggrepel::geom_label_repel(aes(fill = "KILLME")) +
  scale_fill_manual(values = "white")+
  ggtitle("CO2/CH4 FLvsPA particle metagenome differences")+
  ylab("Mantel R value")+
  xlab("FL / PA Gene Abundance")+
  My_Theme+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+ 
  guides(fill="none")
# visualise
Top25_Fraction_MG.df 

#Save plots
pdf("E:/Functional_R_analysis/Figures/CO2CH4_MG_IndivGenes_FLvsPA.pdf", width = 8, height = 7)
Top25_Fraction_MG.df
dev.off()

png("E:/Functional_R_analysis/Figures/CO2CH4_MG_IndivGenes_FLvsPA.png", width = 8, height = 7, units = "in", res = 120)
Top25_Fraction_MG.df
dev.off()



 
```
PA, 
rbcL (chloroplast gene, involved in photosynthesis and usually in chloroplast DNA (Klein et al., 1994; Nurhasanah et al., 2019)), 
pheC (phenylalanine biosynthesis and upregulated under cold tolerant conditions (Cheng et al., 2023; Zhao et al., 1992)), 
csiD (only expressed under carbon starvation conditions (Marschall et al., 1998)), 
oadA (upregulated in response to citrate and essential for its uptake (Blancato et al., 2008; Repizo et al., 2013)) - expression requires anaerobic conditions, and the presence of Na+ and citrate (Bott et al., 1995; Meyer et al., 1997)
DDC (converts tryptophan to tryptamine, linking primary and secondary metabolic pathways (Goddijn et al., 1994))  
Suspended particles 
ubiA (ubiquinone biosynthesis that expresses under stress conditions, specifically low oxygen and carbon (Suzuki et al., 1994)), 
alsD (internal cell pH buffering (Renna et al., 1993)), 
bioU (biotin production, and essential carboxylation, decarboxylation, and transcarboxylation cofactor (Sirithanakorn & Cronan, 2021)), 
menA (menaquinone biosynthesis, important for anaerobic electron transport systems (Suvarna et al., 1998)), and 
GGCX (the only known vitamin K post-translational modification, produces Î³-carboxyglutamate, a vital precursor to many proteins including those involved in cellular growth, survival, and signalling (Shearer & Newman, 2014; Shearer & Okano, 2018)). 

##Combine Lifestyle differences and make table
```{r}

Results_Sign_FLvsPA_MG.df = read.csv("D:/Functional_R_analysis/Significant_FLvsPA_MG.csv", row.names = 1)
dim(Results_Sign_FLvsPA_MG.df)
Results_Sign_FLvsPA_MT.df = read.csv("D:/Functional_R_analysis/Significant_FLvsPA_MT.csv", row.names = 1)
dim(Results_Sign_FLvsPA_MT.df)


#Add calculation for better context
Results_Sign_FLvsPA_MG.df$Diff = Results_Sign_FLvsPA_MG.df$FL.Metagenomes / Results_Sign_FLvsPA_MG.df$PA.Metagenomes
Results_Sign_FLvsPA_MT.df$Diff = Results_Sign_FLvsPA_MT.df$FL.TranscriptsPerGenome / Results_Sign_FLvsPA_MT.df$PA.TranscriptsPerGenome

#Add data type column
Results_Sign_FLvsPA_MG.df$Data_type = "Metagenomes"
Results_Sign_FLvsPA_MT.df$Data_type = "TranscriptsPerGene"

Results_Sign_FLvsPA_MG.df = Results_Sign_FLvsPA_MG.df %>%
  select(Gene, Data_type, Diff, Sample_type.r, Sample_type.p)
Results_Sign_FLvsPA_MT.df = Results_Sign_FLvsPA_MT.df %>%
  select(Gene, Data_type, Diff, Sample_type.r, Sample_type.p)

Results_Sign_FLvsPA.df = rbind(Results_Sign_FLvsPA_MG.df, Results_Sign_FLvsPA_MT.df)
dim(Results_Sign_FLvsPA.df)



Detail_Sign_FLvsPA.df = Results_Sign_FLvsPA.df %>%
  left_join(annot, by = c("Gene" = "KO"), relationship = "many-to-many") %>% # add gene information
  distinct() %>% #remove duplicate rows
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  select(Gene, Data_type, Diff, Sample_type.r, Sample_type.p, ENZYME, SName, LName)

colnames(Detail_Sign_FLvsPA.df)

#Because German computer are stupid
Detail_Sign_FLvsPA.df$ENZYME = gsub(";", "&", Detail_Sign_FLvsPA.df$ENZYME)
Detail_Sign_FLvsPA.df$Diff = as.character(Detail_Sign_FLvsPA.df$Diff)
Detail_Sign_FLvsPA.df$Sample_type.r = as.character(Detail_Sign_FLvsPA.df$Sample_type.r)
Detail_Sign_FLvsPA.df$Sample_type.p = as.character(Detail_Sign_FLvsPA.df$Sample_type.p)

write.table(Detail_Sign_FLvsPA.df, "D:/Functional_R_analysis/Final_Figures_Tables/TableSXX_LifestyleGenes_FLvsPA.csv", sep = "\t")

Detail_Sign_FLvsPA.df = readxl::read_xlsx("F:/Functional_R_analysis/Final_Figures_Tables/TableS1_IndicatorAnalysis.xlsx")
```



#Indicator species - Table SXX

library(dplyr)
library(tidyr)
library(tibble)
library(indicspecies)
library(data.table)

```{r}

#Import physicochemical data
Physicochem.df = readxl::read_xlsx("D:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>%
  mutate(Station = ifelse(grepl("Meedem Grund", Station), "Medemgrund", Station))

```

##mOTUs


```{r}

####Import and prepare dataframe ####

motus_final_taxa_metadata <- readRDS(file="D:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS") %>% #import
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date)) %>% # filter out weird samples 
  filter(!str_detect(sampleid, "_METAT")) %>% #filter out metatranscriptome derived mOTUs
  mutate(across(everything(), ~ str_replace(., "^.__", ""))) %>% # clean up taxonomic names
  mutate(fulltaxa = paste0(phylum, "__", class, "__", order, "__", family, "__", genus, "__", species, "__", mOTU)) # add fulltaxa column
dim(motus_final_taxa_metadata)


####Run indicator gene test between salinities####

#Test to ensure salinity works
range(motus_final_taxa_metadata$salinity)

#Add grouping - groups are based on salinity (itself grouped into informative ecological ranges), season of sampling, fraction - 18 groups total
motu_tbl_long <- motus_final_taxa_metadata %>%
  mutate(  # Create a new categorical variable "Salinity_group" based on salinity levels
    Salinity_group = case_when(
      salinity < 0.5 ~ "Freshwater",
      salinity >= 0.5 & salinity < 5 ~ "Oligohaline",
      salinity >= 5 & salinity < 18 ~ "Mesohaline",
      salinity >= 18 & salinity <= 30 ~ "Polyhaline",
      TRUE ~ "Other" # If salinity does not fit any of the above conditions, classify as "Other"
    )) %>%
  arrange(Salinity_group) %>%  # Ensure alphabetical order
  group_by(Salinity_group) %>%  # Group the data first
  mutate(  
    # Generate a unique group ID after grouping
    Group_ID = cur_group_id()  
  ) %>%
  ungroup()  # Remove grouping after assigning group IDs

# Create a mapping table for BioSample to Group_ID.
#    This table should have one unique Group_ID for each BioSample.
mapping <- motu_tbl_long %>%
  distinct(sampleid, Group_ID) %>%
  pivot_wider(names_from = sampleid, values_from = Group_ID) %>%
  mutate(fulltaxa = "Group_ID")

# Create the wide-format table (otutable) using pivot_wider.
#    - 'BioSample' values become column names.
#    - The values come from 'TranscriptsPerGene'.
motu_otutable <- motu_tbl_long %>%
  select(sampleid, fulltaxa, counts) %>%  # select only relevant columns
  mutate(counts = as.numeric(counts)) %>%  # Ensure counts is numeric
  pivot_wider(names_from = sampleid, values_from = counts) %>% # pivot to make the actual otu table
  bind_rows(mapping) %>% # add the group IDs as an additional row
  mutate(across(everything(), ~ replace_na(., 0))) %>% # replace all NA values with 0, as we could not identify these genes in either the metagenomes and/or the metatranscriptomes
  data.frame() %>% # convert the tibble to a dataframe
  column_to_rownames(var = "fulltaxa") %>% # use the kegg gene ID as rownames
  t() %>% # flip to match format with samples as rows, and columns as OTUs/ASVs
  data.frame() %>%
  relocate(Group_ID) # make group ID the first column
  
dim(motu_otutable)

#How man groups do we have? Need below 20 otherwise takes too long
unique(motu_otutable$Group_ID)

#Set to presence/absence
test <- ifelse(motu_otutable[,-1]>0,1,0)
dim(motu_otutable[,-1])

Sys.time()

phi_motu_sal <- indicspecies::multipatt(test, 
                 motu_otutable$Group_ID, 
                 func = "r.g", 
                 control = how(nperm=999)) 

Sys.time()


summary(phi_motu_sal)

Sys.time()
#Run actual indicator species comparison
indval_motu_sal <- indicspecies::multipatt(motu_otutable[,-1],
                    motu_otutable$Group_ID, 
                    func = "IndVal.g",
                    control = how(nperm=999)) 
Sys.time()

summary(indval_motu_sal, alpha = 1)
summary(indval_motu_sal, indvalcomp=TRUE)

#A = specificity - how likely that the surveyed site belongs to the target site group given the fact that the species has been found. It is a positive predictive value of the species as indicator of the site group.
#If we find the species how likely is it to belong to that group of sites?

#B = sensitivity - how likely we are to find the species in sites belonging to the site group. It represents how well the species acts as an indicator of the target site group.
#If we look at the site, how likely are we to find the specific species?


#Extract data into a df
indval_motu_sal.sign <- indval_motu_sal$sign %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #left_join(
  #  indval_motu_sal$A %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("A_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  #left_join(
  #  indval_motu_sal$B %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("B_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  column_to_rownames(var = "SampleID") %>% # Convert back to rownames
  mutate(p.value.bh = p.adjust(p.value, method = "BH")) %>%
  filter(p.value.bh<=0.05) %>%
  filter(index == 1 | index == 8 | index == 11 | index == 14) %>% # Only freshwater, Meso + Oligo, freshwater + oligohaline + mesohaline, and Meso + Oligo + Poly
  filter(stat > 0.8)
indval_motu_sal.sign





####Run indicator gene test between FL and PA ####

#Test to ensure salinity works
unique(motus_final_taxa_metadata$sample_type)


#Add grouping - groups are based on salinity (itself grouped into informative ecological ranges), season of sampling, fraction - 18 groups total
motu_tbl_long <- motus_final_taxa_metadata %>%
  arrange(sample_type) %>%  # Ensure alphabetical order
  group_by(sample_type) %>%  # Group the data first
  mutate(  
    # Generate a unique group ID after grouping
    Group_ID = cur_group_id()  
  ) %>%
  ungroup()  # Remove grouping after assigning group IDs

# Create a mapping table for BioSample to Group_ID.
#    This table should have one unique Group_ID for each BioSample.
mapping <- motu_tbl_long %>%
  distinct(sampleid, Group_ID) %>%
  pivot_wider(names_from = sampleid, values_from = Group_ID) %>%
  mutate(fulltaxa = "Group_ID")

# Create the wide-format table (otutable) using pivot_wider.
#    - 'BioSample' values become column names.
#    - The values come from 'counts'.
motu_otutable <- motu_tbl_long %>%
  select(sampleid, fulltaxa, counts) %>%  # select only relevant columns
  mutate(counts = as.numeric(counts)) %>%  # Ensure counts is numeric
  pivot_wider(names_from = sampleid, values_from = counts) %>% # pivot to make the actual otu table
  bind_rows(mapping) %>% # add the group IDs as an additional row
  mutate(across(everything(), ~ replace_na(., 0))) %>% # replace all NA values with 0, as we could not identify these genes in either the metagenomes and/or the metatranscriptomes
  data.frame() %>% # convert the tibble to a dataframe
  column_to_rownames(var = "fulltaxa") %>% # use the kegg gene ID as rownames
  t() %>% # flip to match format with samples as rows, and columns as OTUs/ASVs
  data.frame() %>%
  relocate(Group_ID) # make group ID the first column
  
dim(motu_otutable)

#How man groups do we have? Need below 20 otherwise takes too long
unique(motu_otutable$Group_ID)

#Set to presence/absence
test <- ifelse(motu_otutable[,-1]>0,1,0)
dim(motu_otutable[,-1])

Sys.time()

phi_motu_FLvsPA <- multipatt(test, 
                 motu_otutable$Group_ID, 
                 func = "r.g", 
                 control = how(nperm=999),
                 min.order = 1,
                 print.perm = TRUE) 

Sys.time()


summary(phi_motu_FLvsPA)

Sys.time()
#Run actual indicator species comparison
indval_motu_FLvsPA <- indicspecies::multipatt(motu_otutable[,-1],
                    motu_otutable$Group_ID, 
                    func = "IndVal.g",
                    control = how(nperm=999)) 
Sys.time()

summary(indval_motu_FLvsPA, alpha = 1)
#summary(indval_motu_FLvsPA, indvalcomp=TRUE)

#A = specificity - how likely that the surveyed site belongs to the target site group given the fact that the species has been found. It is a positive predictive value of the species as indicator of the site group.
#If we find the species how likely is it to belong to that group of sites?

#B = sensitivity - how likely we are to find the species in sites belonging to the site group. It represents how well the species acts as an indicator of the target site group.
#If we look at the site, how likely are we to find the specific species?


#Extract data into a df

indval_motu_FLvsPA.sign <- indval_motu_FLvsPA$sign %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #left_join(
  #  indval_motu_FLvsPA$A %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("A_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  #left_join(
  #  indval_motu_FLvsPA$B %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("B_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  column_to_rownames(var = "SampleID") %>% # Convert back to rownames
  mutate(p.value.bh = p.adjust(p.value, method = "BH")) %>%
  filter(p.value.bh<=0.05) %>%
  filter(index<4 | index == 6) %>%
  rownames_to_column("fulltaxa")
indval_motu_FLvsPA.sign
dim(indval_motu_FLvsPA.sign)

indval_motu_FLvsPA.sign %>%
  group_by(index) %>%
  summarise(count = n())

####Run indicator gene test between Suspended and Sinking ####

#Test to ensure salinity works
unique(motus_final_taxa_metadata$sample_type)


#Add grouping - groups are based on salinity (itself grouped into informative ecological ranges), season of sampling, fraction - 18 groups total
motu_tbl_long <- motus_final_taxa_metadata %>%
  arrange(sample_type) %>%  # Ensure alphabetical order
  group_by(sample_type) %>%  # Group the data first
  mutate(  
    # Generate a unique group ID after grouping
    Group_ID = cur_group_id()  
  ) %>%
  ungroup()  # Remove grouping after assigning group IDs

# Create a mapping table for BioSample to Group_ID.
#    This table should have one unique Group_ID for each BioSample.
mapping <- motu_tbl_long %>%
  distinct(sampleid, Group_ID) %>%
  pivot_wider(names_from = sampleid, values_from = Group_ID) %>%
  mutate(fulltaxa = "Group_ID")

# Create the wide-format table (otutable) using pivot_wider.
#    - 'BioSample' values become column names.
#    - The values come from 'counts'.
motu_otutable <- motu_tbl_long %>%
  select(sampleid, fulltaxa, counts) %>%  # select only relevant columns
  mutate(counts = as.numeric(counts)) %>%  # Ensure counts is numeric
  pivot_wider(names_from = sampleid, values_from = counts) %>% # pivot to make the actual otu table
  bind_rows(mapping) %>% # add the group IDs as an additional row
  mutate(across(everything(), ~ replace_na(., 0))) %>% # replace all NA values with 0, as we could not identify these genes in either the metagenomes and/or the metatranscriptomes
  data.frame() %>% # convert the tibble to a dataframe
  column_to_rownames(var = "fulltaxa") %>% # use the kegg gene ID as rownames
  t() %>% # flip to match format with samples as rows, and columns as OTUs/ASVs
  data.frame() %>%
  relocate(Group_ID) # make group ID the first column
  
dim(motu_otutable)

#How man groups do we have? Need below 20 otherwise takes too long
unique(motu_otutable$Group_ID)

#Set to presence/absence
test <- ifelse(motu_otutable[,-1]>0,1,0)
dim(motu_otutable[,-1])

Sys.time()

phi_motu_SuspvsSink <- multipatt(test, 
                 motu_otutable$Group_ID, 
                 func = "r.g", 
                 control = how(nperm=999),
                 min.order = 1,
                 print.perm = TRUE) 

Sys.time()


summary(phi_motu_SuspvsSink)

Sys.time()
#Run actual indicator species comparison
indval_motu_SuspvsSink <- indicspecies::multipatt(motu_otutable[,-1],
                    motu_otutable$Group_ID, 
                    func = "IndVal.g",
                    control = how(nperm=999)) 
Sys.time()

summary(indval_motu_SuspvsSink, alpha = 1)
#summary(indval_motu_SuspvsSink, indvalcomp=TRUE)

#A = specificity - how likely that the surveyed site belongs to the target site group given the fact that the species has been found. It is a positive predictive value of the species as indicator of the site group.
#If we find the species how likely is it to belong to that group of sites?

#B = sensitivity - how likely we are to find the species in sites belonging to the site group. It represents how well the species acts as an indicator of the target site group.
#If we look at the site, how likely are we to find the specific species?


#Extract data into a df

indval_motu_SuspvsSink.sign <- indval_motu_SuspvsSink$sign %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #left_join(
  #  indval_motu_SuspvsSink$A %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("A_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  #left_join(
  #  indval_motu_SuspvsSink$B %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("B_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  column_to_rownames(var = "SampleID") %>% # Convert back to rownames
  mutate(p.value.bh = p.adjust(p.value, method = "BH")) %>%
  filter(p.value.bh<=0.05) %>%
  filter(index > 1 & index<4 ) %>%
  rownames_to_column("fulltaxa")
indval_motu_SuspvsSink.sign
dim(indval_motu_SuspvsSink.sign)

indval_motu_SuspvsSink.sign %>%
  group_by(index) %>%
  summarise(count = n())

```

###Taxa in common between WGCNA module grey (-ve salinity) and salinity (freshwater) indicator taxa

```{r}

#Read in grey module taxa ids
mOTU_grey.ls = read.csv("D:/Functional_R_analysis/mOTU_WGCNAmodule_greytaxa.csv", row.names = 1)

#Filter to taxa in common for grey module and salinity indicator species
Indicator_mOTU_freshwater.ls = indval_motu_sal.sign %>%
  rownames_to_column("newname") %>%
  select(newname) %>% # choose only the informative column
  separate(newname, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "MAGID")) %>% #separate the taxa column into individual taxa names according to the level
  distinct() %>% #remove duplicates
  arrange(across(everything()))  # Reorders columns alphabetically
Indicator_mOTU_freshwater.ls


# Create a list of dataframes with the last column removed.
dfs <- list(
  mOTU_grey.ls %>% select(-((ncol(.)-1):ncol(.))),
  Indicator_mOTU_freshwater.ls %>% select(-((ncol(.)-1):ncol(.)))
)

# Use reduce() and inner_join() to join the dataframes on all common columns.
common_rows <- reduce(dfs, inner_join)

# View the result
common_rows

```
###Taxa in common between WGCNA module turquoise (FL associated) and Free-living indicator taxa

```{r}

#Read in grey module taxa ids
mOTU_grey.ls = read.csv("D:/Functional_R_analysis/mOTU_WGCNAmodule_turquoisetaxa.csv", row.names = 1)

#Filter to taxa in common for grey module and salinity indicator species
Indicator_mOTU_freshwater.ls = indval_motu_sal.sign %>%
  rownames_to_column("newname") %>%
  select(newname) %>% # choose only the informative column
  separate(newname, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "MAGID")) %>% #separate the taxa column into individual taxa names according to the level
  distinct() %>% #remove duplicates
  arrange(across(everything()))  # Reorders columns alphabetically
Indicator_mOTU_freshwater.ls


# Create a list of dataframes with the last column removed.
dfs <- list(
  mOTU_grey.ls %>% select(-((ncol(.)-1):ncol(.))),
  Indicator_mOTU_freshwater.ls %>% select(-((ncol(.)-1):ncol(.)))
)

# Use reduce() and inner_join() to join the dataframes on all common columns.
common_rows <- reduce(dfs, inner_join)

# View the result
common_rows

```
##Metagenomes
```{r}
####Prepare data frame####

#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  distinct()
amoAClean_CO2CH4_tbl_long$counts = amoAClean_CO2CH4_tbl_long$counts / 1000

#View(amoAClean_CO2CH4_tbl_long)
dim(amoAClean_CO2CH4_tbl_long)

#Reorder factors
amoAClean_CO2CH4_tbl_long$Station = factor(amoAClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

amoAClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",amoAClean_CO2CH4_tbl_long$Sample_date)

amoAClean_CO2CH4_tbl_long$Sample_date = factor(amoAClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long$data_type)

dim(amoAClean_CO2CH4_tbl_long)

#write.csv2(amoAClean_CO2CH4_tbl_long, "D:/Functional_R_analysis/MG_amoAClean_CO2CH4_tbl_long.csv", dec = ',', sep = ',')
amoAClean_CO2CH4_tbl_long = read.csv("D:/Functional_R_analysis/MG_amoAClean_CO2CH4_tbl_long.csv", dec = ",", sep = ";", row.names = 1)

MG_amoAClean_CO2CH4_tbl_long_v0 = amoAClean_CO2CH4_tbl_long


####Run indicator gene test between salinities####

#Test to ensure salinity works
range(MG_amoAClean_CO2CH4_tbl_long_v0$Salinity_PSU)

#Add grouping - groups are based on salinity (itself grouped into informative ecological ranges), season of sampling, fraction - 18 groups total
MG_amoAClean_CO2CH4_tbl_long <- MG_amoAClean_CO2CH4_tbl_long_v0 %>%
  mutate(  # Create a new categorical variable "Salinity_group" based on salinity levels
    Salinity_group = case_when(
      Salinity_PSU < 0.5 ~ "Freshwater",
      Salinity_PSU >= 0.5 & Salinity_PSU < 5 ~ "Oligohaline",
      Salinity_PSU >= 5 & Salinity_PSU < 18 ~ "Mesohaline",
      Salinity_PSU >= 18 & Salinity_PSU <= 30 ~ "Polyhaline",
      TRUE ~ "Other" # If salinity does not fit any of the above conditions, classify as "Other"
    )) %>%
  arrange(Salinity_group) %>%  # Ensure alphabetical order
  group_by(Salinity_group) %>%  # Group the data first
  mutate(  
    # Generate a unique group ID after grouping
    Group_ID = cur_group_id()  
  ) %>%
  ungroup()  # Remove grouping after assigning group IDs

# Create a mapping table for BioSample to Group_ID.
#    This table should have one unique Group_ID for each BioSample.
mapping <- MG_amoAClean_CO2CH4_tbl_long %>%
  distinct(BioSample, Group_ID) %>%
  pivot_wider(names_from = BioSample, values_from = Group_ID) %>%  
  mutate(KO = "Group_ID")

# Create the wide-format table (otutable) using pivot_wider.
#    - 'BioSample' values become column names.
#    - The values come from 'TranscriptsPerGene'.
MG_CO2CH4_otutable <- MG_amoAClean_CO2CH4_tbl_long %>%
  select(BioSample, KO, counts) %>%  # select only relevant columns
  pivot_wider(names_from = BioSample, values_from = counts) %>% # pivot to make the actual otu table
  bind_rows(mapping) %>% # add the group IDs as an additional row
  mutate(across(everything(), ~ replace_na(., 0))) %>% # replace all NA values with 0, as we could not identify these genes in either the metagenomes and/or the metatranscriptomes
  data.frame() %>% # convert the tibble to a dataframe
  column_to_rownames(var = "KO") %>% # use the kegg gene ID as rownames
  t() %>% # flip to match format with samples as rows, and columns as OTUs/ASVs
  data.frame() %>%
  relocate(Group_ID) # make group ID the first column
  
dim(MG_CO2CH4_otutable)

#How man groups do we have? Need below 20 otherwise takes too long
unique(MG_CO2CH4_otutable$Group_ID)

#Set to presence/absence
test <- ifelse(MG_CO2CH4_otutable[,-1]>0,1,0)
dim(MG_CO2CH4_otutable[,-1])

Sys.time()

phi_MG_sal <- multipatt(test, 
                 MG_CO2CH4_otutable$Group_ID, 
                 func = "r.g", 
                 control = how(nperm=999)) 

Sys.time()


summary(phi_MG_sal)

Sys.time()
#Run actual indicator species comparison
indval_MG_sal <- indicspecies::multipatt(MG_CO2CH4_otutable[,-1],
                    MG_CO2CH4_otutable$Group_ID, 
                    func = "IndVal.g",
                    control = how(nperm=999)) 
Sys.time()

summary(indval_MG_sal, alpha = 1)
summary(indval_MG_sal, indvalcomp=TRUE)

#A = specificity - how likely that the surveyed site belongs to the target site group given the fact that the species has been found. It is a positive predictive value of the species as indicator of the site group.
#If we find the species how likely is it to belong to that group of sites?

#B = sensitivity - how likely we are to find the species in sites belonging to the site group. It represents how well the species acts as an indicator of the target site group.
#If we look at the site, how likely are we to find the specific species?


#Extract data into a df
indval_MG_sal.sign <- indval_MG_sal$sign %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #left_join(
  #  indval_MG_sal$A %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("A_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  #left_join(
  #  indval_MG_sal$B %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("B_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  column_to_rownames(var = "SampleID") %>% # Convert back to rownames
  mutate(p.value.bh = p.adjust(p.value, method = "BH")) %>%
  filter(p.value.bh<=0.05) %>%
  filter(index == 1 | index == 8 | index == 11 | index == 14) %>% # Only freshwater, Meso + Oligo, freshwater + oligohaline + mesohaline, and Meso + Oligo + Poly
  filter(stat > 0.8)
indval_MG_sal.sign





####Run indicator gene test between FL and PA ####

#Test to ensure salinity works
unique(MG_amoAClean_CO2CH4_tbl_long_v0$Sample_type)


#Add grouping - groups are based on salinity (itself grouped into informative ecological ranges), season of sampling, fraction - 18 groups total
MG_amoAClean_CO2CH4_tbl_long <- MG_amoAClean_CO2CH4_tbl_long_v0 %>%
  mutate(  # Create a new categorical variable "Salinity_group" based on salinity levels
    Salinity_group = case_when(
      Salinity_PSU < 0.5 ~ "Freshwater",
      Salinity_PSU >= 0.5 & Salinity_PSU < 5 ~ "Oligohaline",
      Salinity_PSU >= 5 & Salinity_PSU < 18 ~ "Mesohaline",
      Salinity_PSU >= 18 & Salinity_PSU <= 30 ~ "Polyhaline",
      TRUE ~ "Other" # If salinity does not fit any of the above conditions, classify as "Other"
    )) %>%
  arrange(Sample_type) %>%  # Ensure alphabetical order
  group_by(Sample_type) %>%  # Group the data first
  mutate(  
    # Generate a unique group ID after grouping
    Group_ID = cur_group_id()  
  ) %>%
  ungroup()  # Remove grouping after assigning group IDs

# Create a mapping table for BioSample to Group_ID.
#    This table should have one unique Group_ID for each BioSample.
mapping <- MG_amoAClean_CO2CH4_tbl_long %>%
  distinct(BioSample, Group_ID) %>%
  pivot_wider(names_from = BioSample, values_from = Group_ID) %>%
  mutate(KO = "Group_ID")

# Create the wide-format table (otutable) using pivot_wider.
#    - 'BioSample' values become column names.
#    - The values come from 'counts'.
MG_CO2CH4_otutable <- MG_amoAClean_CO2CH4_tbl_long %>%
  select(BioSample, KO, counts) %>%  # select only relevant columns
  pivot_wider(names_from = BioSample, values_from = counts) %>% # pivot to make the actual otu table
  bind_rows(mapping) %>% # add the group IDs as an additional row
  mutate(across(everything(), ~ replace_na(., 0))) %>% # replace all NA values with 0, as we could not identify these genes in either the metagenomes and/or the metatranscriptomes
  data.frame() %>% # convert the tibble to a dataframe
  column_to_rownames(var = "KO") %>% # use the kegg gene ID as rownames
  t() %>% # flip to match format with samples as rows, and columns as OTUs/ASVs
  data.frame() %>%
  relocate(Group_ID) # make group ID the first column
  
dim(MG_CO2CH4_otutable)

#How man groups do we have? Need below 20 otherwise takes too long
unique(MG_CO2CH4_otutable$Group_ID)

#Set to presence/absence
test <- ifelse(MG_CO2CH4_otutable[,-1]>0,1,0)
dim(MG_CO2CH4_otutable[,-1])

Sys.time()

phi_MG_FLvsPA <- multipatt(test, 
                 MG_CO2CH4_otutable$Group_ID, 
                 func = "r.g", 
                 control = how(nperm=999),
                 min.order = 1,
                 print.perm = TRUE) 

Sys.time()


summary(phi_MG_FLvsPA)

Sys.time()
#Run actual indicator species comparison
indval_MG_FLvsPA <- indicspecies::multipatt(MG_CO2CH4_otutable[,-1],
                    MG_CO2CH4_otutable$Group_ID, 
                    func = "IndVal.g",
                    control = how(nperm=999)) 
Sys.time()

summary(indval_MG_FLvsPA, alpha = 1)
#summary(indval_MG_FLvsPA, indvalcomp=TRUE)

#A = specificity - how likely that the surveyed site belongs to the target site group given the fact that the species has been found. It is a positive predictive value of the species as indicator of the site group.
#If we find the species how likely is it to belong to that group of sites?

#B = sensitivity - how likely we are to find the species in sites belonging to the site group. It represents how well the species acts as an indicator of the target site group.
#If we look at the site, how likely are we to find the specific species?


#Extract data into a df
#Extract data into a df

indval_MG_FLvsPA.sign <- indval_MG_FLvsPA$sign %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #left_join(
  #  indval_MG_FLvsPA$A %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("A_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  #left_join(
  #  indval_MG_FLvsPA$B %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("B_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  column_to_rownames(var = "SampleID") %>% # Convert back to rownames
  mutate(p.value.bh = p.adjust(p.value, method = "BH")) %>%
  filter(p.value.bh<=0.05)
indval_MG_FLvsPA.sign
dim(indval_MG_FLvsPA.sign)


####Run indicator gene test between Supended and Sinking ####

#Test to ensure salinity works
unique(MG_amoAClean_CO2CH4_tbl_long_v0$Sample_type)


#Add grouping - groups are based on salinity (itself grouped into informative ecological ranges), season of sampling, fraction - 18 groups total
MG_amoAClean_CO2CH4_tbl_long <- MG_amoAClean_CO2CH4_tbl_long_v0 %>%
  mutate(  # Create a new categorical variable "Salinity_group" based on salinity levels
    Salinity_group = case_when(
      Salinity_PSU < 0.5 ~ "Freshwater",
      Salinity_PSU >= 0.5 & Salinity_PSU < 5 ~ "Oligohaline",
      Salinity_PSU >= 5 & Salinity_PSU < 18 ~ "Mesohaline",
      Salinity_PSU >= 18 & Salinity_PSU <= 30 ~ "Polyhaline",
      TRUE ~ "Other" # If salinity does not fit any of the above conditions, classify as "Other"
    )) %>%
  arrange(Sample_type) %>%  # Ensure alphabetical order
  group_by(Sample_type) %>%  # Group the data first
  mutate(  
    # Generate a unique group ID after grouping
    Group_ID = cur_group_id()  
  ) %>%
  ungroup()  # Remove grouping after assigning group IDs

# Create a mapping table for BioSample to Group_ID.
#    This table should have one unique Group_ID for each BioSample.
mapping <- MG_amoAClean_CO2CH4_tbl_long %>%
  distinct(BioSample, Group_ID) %>%
  pivot_wider(names_from = BioSample, values_from = Group_ID) %>%
  mutate(KO = "Group_ID")

# Create the wide-format table (otutable) using pivot_wider.
#    - 'BioSample' values become column names.
#    - The values come from 'counts'.
MG_CO2CH4_otutable <- MG_amoAClean_CO2CH4_tbl_long %>%
  select(BioSample, KO, counts) %>%  # select only relevant columns
  pivot_wider(names_from = BioSample, values_from = counts) %>% # pivot to make the actual otu table
  bind_rows(mapping) %>% # add the group IDs as an additional row
  mutate(across(everything(), ~ replace_na(., 0))) %>% # replace all NA values with 0, as we could not identify these genes in either the metagenomes and/or the metatranscriptomes
  data.frame() %>% # convert the tibble to a dataframe
  column_to_rownames(var = "KO") %>% # use the kegg gene ID as rownames
  t() %>% # flip to match format with samples as rows, and columns as OTUs/ASVs
  data.frame() %>%
  relocate(Group_ID) # make group ID the first column
  
dim(MG_CO2CH4_otutable)

#How man groups do we have? Need below 20 otherwise takes too long
unique(MG_CO2CH4_otutable$Group_ID)

#Set to presence/absence
test <- ifelse(MG_CO2CH4_otutable[,-1]>0,1,0)
dim(MG_CO2CH4_otutable[,-1])

Sys.time()

phi_MG_FLvsPA <- multipatt(test, 
                 MG_CO2CH4_otutable$Group_ID, 
                 func = "r.g", 
                 control = how(nperm=999),
                 min.order = 1,
                 print.perm = TRUE) 

Sys.time()


summary(phi_MG_FLvsPA)

Sys.time()
#Run actual indicator species comparison
indval_MG_FLvsPA <- indicspecies::multipatt(MG_CO2CH4_otutable[,-1],
                    MG_CO2CH4_otutable$Group_ID, 
                    func = "IndVal.g",
                    control = how(nperm=999)) 
Sys.time()

summary(indval_MG_FLvsPA, alpha = 1)
#summary(indval_MG_FLvsPA, indvalcomp=TRUE)

#A = specificity - how likely that the surveyed site belongs to the target site group given the fact that the species has been found. It is a positive predictive value of the species as indicator of the site group.
#If we find the species how likely is it to belong to that group of sites?

#B = sensitivity - how likely we are to find the species in sites belonging to the site group. It represents how well the species acts as an indicator of the target site group.
#If we look at the site, how likely are we to find the specific species?


#Extract data into a df

indval_MG_FLvsPA.sign <- indval_MG_FLvsPA$sign %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #left_join(
  #  indval_MG_FLvsPA$A %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("A_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  #left_join(
  #  indval_MG_FLvsPA$B %>%
  #    as.data.frame() %>%
  #    rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  #    rename_with(~ paste0("B_", .), -SampleID), # Rename df2 columns
  #  by = "SampleID"
  #) %>%
  column_to_rownames(var = "SampleID") %>% # Convert back to rownames
  mutate(p.value.bh = p.adjust(p.value, method = "BH")) %>%
  filter(p.value.bh<=0.05)
indval_MG_FLvsPA.sign
dim(indval_MG_FLvsPA.sign)



```
##Metatranscriptomes
```{r}
####Prep dataframe ####

#Load proper physicochemical df
metadata = metadata_v0

####Set up metatranscriptome dataframe
#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  
  filter(gene_cluster %nin% amoAMatches.ls$gene_cluster) %>%
  #mutate(DESCRIPTION = "pmoA; methane monooxygenase subunit A") %>% # Rename description to purely pmoA
  
  select(gene_cluster, KO, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)

amoAClean_CO2CH4_tbl_long_MT <- amoAClean_geneabund_KO %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  mutate(BioSample = str_extract(sampleid, "SAMEA[0-9]+")) %>%
  left_join(metadata, by = c("BioSample" = "BioSample",
                             "sampleid" = "sampleid")) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  distinct()

dim(test)
dim(amoAClean_CO2CH4_tbl_long_MT)
#Correct abundance
amoAClean_CO2CH4_tbl_long_MT$counts = amoAClean_CO2CH4_tbl_long_MT$counts / 1000


#View(amoAClean_CO2CH4_tbl_long_MT)
dim(amoAClean_CO2CH4_tbl_long_MT)

#write.csv(amoAClean_CO2CH4_tbl_long_MT, "D:/Functional_R_analysis/2025_02_19_amoAClean_CO2CH4_OccurrenceFiltered_TG_4IndicSpec.csv")

amoAClean_CO2CH4_tbl_long_MT = read.csv( "D:/Functional_R_analysis/2025_02_19_amoAClean_CO2CH4_OccurrenceFiltered_TG_4IndicSpec.csv")

#Reorder factors
amoAClean_CO2CH4_tbl_long_MT$Station = factor(amoAClean_CO2CH4_tbl_long_MT$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuttel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muhlenberger Loch"))

#amoAClean_CO2CH4_tbl_long_MT$Sample_date = gsub("Mai", "May",amoAClean_CO2CH4_tbl_long_MT$Sample_date)

amoAClean_CO2CH4_tbl_long_MT$Sample_date = factor(amoAClean_CO2CH4_tbl_long_MT$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAG", "Metagenomes", amoAClean_CO2CH4_tbl_long_MT$data_type)
amoAClean_CO2CH4_tbl_long_MT$data_type = gsub("METAT", "Transcriptomes", amoAClean_CO2CH4_tbl_long_MT$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- spread(amoAClean_CO2CH4_tbl_long_MT[ , ! names(amoAClean_CO2CH4_tbl_long_MT) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(amoAClean_CO2CH4_tbl_long_MT)
dim(CO2CH4_TG.df)


#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGene = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes

CO2CH4_TG.df_v1 = CO2CH4_TG.df



####Run indicator gene test between salinities####

#Test to ensure salinity works
range(CO2CH4_TG.df_v1$Salinity_PSU)

#Add grouping - groups are based on salinity (itself grouped into informative ecological ranges), season of sampling, fraction - 18 groups total
CO2CH4_TG.df <- CO2CH4_TG.df_v1 %>%
  mutate(  # Create a new categorical variable "Salinity_group" based on salinity levels
    Salinity_group = case_when(
      Salinity_PSU < 0.5 ~ "Freshwater",
      Salinity_PSU >= 0.5 & Salinity_PSU < 5 ~ "Oligohaline",
      Salinity_PSU >= 5 & Salinity_PSU < 18 ~ "Mesohaline",
      Salinity_PSU >= 18 & Salinity_PSU <= 30 ~ "Polyhaline",
      TRUE ~ "Other" # If salinity does not fit any of the above conditions, classify as "Other"
    )) %>%
  arrange(Salinity_group) %>%  # Ensure alphabetical order
  group_by(Salinity_group) %>%  # Group the data first
  mutate(  
    # Generate a unique group ID after grouping
    Group_ID = cur_group_id()  
  ) %>%
  ungroup()  # Remove grouping after assigning group IDs

#Make the CO2CH4_TG.df df into a otutable for the indicator species assessment
Indicator.df = CO2CH4_TG.df %>% # select data
  select(BioSample, KO, TranscriptsPerGene, Group_ID) %>% #choose only relevant columns
  pivot_wider(names_from = BioSample, values_from = TranscriptsPerGene) %>%
  relocate(Group_ID, .before = everything())  # Ensure Group_ID is the first column




# Create a mapping table for BioSample to Group_ID.
#    This table should have one unique Group_ID for each BioSample.
mapping <- CO2CH4_TG.df %>%
  distinct(BioSample, Group_ID) %>%
  pivot_wider(names_from = BioSample, values_from = Group_ID) %>%
  mutate(KO = "Group_ID")

# Create the wide-format table (otutable) using pivot_wider.
#    - 'BioSample' values become column names.
#    - The values come from 'TranscriptsPerGene'.
MT_CO2CH4_otutable <- CO2CH4_TG.df %>%
  select(BioSample, KO, TranscriptsPerGene) %>%  # select only relevant columns
  pivot_wider(names_from = BioSample, values_from = TranscriptsPerGene) %>% # pivot to make the actual otu table
  bind_rows(mapping) %>% # add the group IDs as an additional row
  mutate(across(everything(), ~ replace_na(., 0))) %>% # replace all NA values with 0, as we could not identify these genes in either the metagenomes and/or the metatranscriptomes
  data.frame() %>% # convert the tibble to a dataframe
  column_to_rownames(var = "KO") %>% # use the kegg gene ID as rownames
  t() %>% # flip to match format with samples as rows, and columns as OTUs/ASVs
  data.frame() %>%
  relocate(Group_ID) # make group ID the first column
  
dim(MT_CO2CH4_otutable)

#How man groups do we have? Need below 20 otherwise takes too long
unique(MT_CO2CH4_otutable$Group_ID)

#Set to presence/absence
test <- ifelse(MT_CO2CH4_otutable[,-1]>0,1,0)
dim(MT_CO2CH4_otutable[,-1])

Sys.time()

phi_MT_sal <- multipatt(test, 
                 MT_CO2CH4_otutable$Group_ID, 
                 func = "r.g", 
                 control = how(nperm=999)) 

Sys.time()


summary(phi_MT_sal)

Sys.time()
#Run actual indicator species comparison
indval_MT_sal <- indicspecies::multipatt(MT_CO2CH4_otutable[,-1],
                    MT_CO2CH4_otutable$Group_ID, 
                    func = "IndVal.g",
                    control = how(nperm=999)) 
Sys.time()

summary(indval_MT_sal, alpha = 1)
summary(indval_MT_sal, indvalcomp=TRUE)

#A = specificity - how likely that the surveyed site belongs to the target site group given the fact that the species has been found. It is a positive predictive value of the species as indicator of the site group.
#If we find the species how likely is it to belong to that group of sites?

#B = sensitivity - how likely we are to find the species in sites belonging to the site group. It represents how well the species acts as an indicator of the target site group.
#If we look at the site, how likely are we to find the specific species?


#Extract data into a df
indval_MT_sal.sign <- indval_MT_sal$sign %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  left_join(
    indval_MT_sal$A %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
      rename_with(~ paste0("A_", .), -SampleID), # Rename df2 columns
    by = "SampleID"
  ) %>%
  left_join(
    indval_MT_sal$B %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
      rename_with(~ paste0("B_", .), -SampleID), # Rename df2 columns
    by = "SampleID"
  ) %>%
  column_to_rownames(var = "SampleID") %>% # Convert back to rownames
  mutate(p.value.bh = p.adjust(p.value, method = "BH")) %>%
  filter(p.value.bh<=0.05) %>%
  filter(index == 1 | index == 11) # Only freshwater, and freshwater + oligohaline + mesohaline
indval_MT_sal.sign





####Run indicator gene test between FL and PA ####

#Test to ensure salinity works
unique(CO2CH4_TG.df_v1$Sample_type)

#Add grouping - groups are based on salinity (itself grouped into informative ecological ranges), season of sampling, fraction - 18 groups total
CO2CH4_TG.df <- CO2CH4_TG.df_v1 %>%
  mutate(  # Create a new categorical variable "Salinity_group" based on salinity levels
    Salinity_group = case_when(
      Salinity_PSU < 0.5 ~ "Freshwater",
      Salinity_PSU < 5 ~ "Oligohaline",
      Salinity_PSU >= 5 & Salinity_PSU < 18 ~ "Mesohaline",
      Salinity_PSU >= 18 & Salinity_PSU <= 30 ~ "Polyhaline",
      TRUE ~ "Other" # If salinity does not fit any of the above conditions, classify as "Other"
    )) %>%
  arrange(Sample_type) %>%  # Ensure alphabetical order
  group_by(Sample_type) %>%  # Group the data first
  mutate(  
    # Generate a unique group ID after grouping
    Group_ID = cur_group_id()  
  ) %>%
  ungroup()  # Remove grouping after assigning group IDs

#Make the CO2CH4_TG.df df into a otutable for the indicator species assessment
Indicator.df = CO2CH4_TG.df %>% # select data
  select(BioSample, KO, TranscriptsPerGene, Group_ID) %>% #choose only relevant columns
  pivot_wider(names_from = BioSample, values_from = TranscriptsPerGene) %>%
  relocate(Group_ID, .before = everything())  # Ensure Group_ID is the first column




# Create a mapping table for BioSample to Group_ID.
#    This table should have one unique Group_ID for each BioSample.
mapping <- CO2CH4_TG.df %>%
  distinct(BioSample, Group_ID) %>%
  pivot_wider(names_from = BioSample, values_from = Group_ID) %>%
  mutate(KO = "Group_ID")

# Create the wide-format table (otutable) using pivot_wider.
#    - 'BioSample' values become column names.
#    - The values come from 'TranscriptsPerGene'.
MT_CO2CH4_otutable <- CO2CH4_TG.df %>%
  select(BioSample, KO, TranscriptsPerGene) %>%  # select only relevant columns
  pivot_wider(names_from = BioSample, values_from = TranscriptsPerGene) %>% # pivot to make the actual otu table
  bind_rows(mapping) %>% # add the group IDs as an additional row
  mutate(across(everything(), ~ replace_na(., 0))) %>% # replace all NA values with 0, as we could not identify these genes in either the metagenomes and/or the metatranscriptomes
  data.frame() %>% # convert the tibble to a dataframe
  column_to_rownames(var = "KO") %>% # use the kegg gene ID as rownames
  t() %>% # flip to match format with samples as rows, and columns as OTUs/ASVs
  data.frame() %>%
  relocate(Group_ID) # make group ID the first column
  
dim(MT_CO2CH4_otutable)

#How man groups do we have? Need below 20 otherwise takes too long
unique(MT_CO2CH4_otutable$Group_ID)

#Set to presence/absence
test <- ifelse(MT_CO2CH4_otutable[,-1]>0,1,0)
dim(MT_CO2CH4_otutable[,-1])

Sys.time()

phi_MT_FLvsPA <- multipatt(test, 
                 MT_CO2CH4_otutable$Group_ID, 
                 func = "r.g", 
                 control = how(nperm=999),
                 min.order = 1,
                 print.perm = TRUE) 

Sys.time()


summary(phi_MT_FLvsPA)

Sys.time()
#Run actual indicator species comparison
indval_MT_FLvsPA <- indicspecies::multipatt(MT_CO2CH4_otutable[,-1],
                    MT_CO2CH4_otutable$Group_ID, 
                    func = "IndVal.g",
                    control = how(nperm=999)) 
Sys.time()

summary(indval_MT_FLvsPA, alpha = 1)
summary(indval_MT_FLvsPA, indvalcomp=TRUE)

#A = specificity - how likely that the surveyed site belongs to the target site group given the fact that the species has been found. It is a positive predictive value of the species as indicator of the site group.
#If we find the species how likely is it to belong to that group of sites?

#B = sensitivity - how likely we are to find the species in sites belonging to the site group. It represents how well the species acts as an indicator of the target site group.
#If we look at the site, how likely are we to find the specific species?


#Extract data into a df
#Extract data into a df

indval_MT_FLvsPA.sign <- indval_MT_FLvsPA$sign %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  left_join(
    indval_MT_FLvsPA$A %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
      rename_with(~ paste0("A_", .), -SampleID), # Rename df2 columns
    by = "SampleID"
  ) %>%
  left_join(
    indval_MT_FLvsPA$B %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
      rename_with(~ paste0("B_", .), -SampleID), # Rename df2 columns
    by = "SampleID"
  ) %>%
  column_to_rownames(var = "SampleID") %>% # Convert back to rownames
  mutate(p.value.bh = p.adjust(p.value, method = "BH")) %>%
  filter(p.value<=0.05) %>%
  filter(index > 0 & index < 4 | index == 11) # Only FL, Suspended, Sinking, and Suspended + Sinking
indval_MT_FLvsPA.sign

####Run indicator gene test between Suspended and Sinking ####

#Test to ensure salinity works
unique(CO2CH4_TG.df_v1$Sample_type)

#Add grouping - groups are based on salinity (itself grouped into informative ecological ranges), season of sampling, fraction - 18 groups total
CO2CH4_TG.df <- CO2CH4_TG.df_v1 %>%
  mutate(  # Create a new categorical variable "Salinity_group" based on salinity levels
    Salinity_group = case_when(
      Salinity_PSU < 0.5 ~ "Freshwater",
      Salinity_PSU < 5 ~ "Oligohaline",
      Salinity_PSU >= 5 & Salinity_PSU < 18 ~ "Mesohaline",
      Salinity_PSU >= 18 & Salinity_PSU <= 30 ~ "Polyhaline",
      TRUE ~ "Other" # If salinity does not fit any of the above conditions, classify as "Other"
    )) %>%
  arrange(Sample_type) %>%  # Ensure alphabetical order
  group_by(Sample_type) %>%  # Group the data first
  mutate(  
    # Generate a unique group ID after grouping
    Group_ID = cur_group_id()  
  ) %>%
  ungroup()  # Remove grouping after assigning group IDs

#Make the CO2CH4_TG.df df into a otutable for the indicator species assessment
Indicator.df = CO2CH4_TG.df %>% # select data
  select(BioSample, KO, TranscriptsPerGene, Group_ID) %>% #choose only relevant columns
  pivot_wider(names_from = BioSample, values_from = TranscriptsPerGene) %>%
  relocate(Group_ID, .before = everything())  # Ensure Group_ID is the first column




# Create a mapping table for BioSample to Group_ID.
#    This table should have one unique Group_ID for each BioSample.
mapping <- CO2CH4_TG.df %>%
  distinct(BioSample, Group_ID) %>%
  pivot_wider(names_from = BioSample, values_from = Group_ID) %>%
  mutate(KO = "Group_ID")

# Create the wide-format table (otutable) using pivot_wider.
#    - 'BioSample' values become column names.
#    - The values come from 'TranscriptsPerGene'.
MT_CO2CH4_otutable <- CO2CH4_TG.df %>%
  select(BioSample, KO, TranscriptsPerGene) %>%  # select only relevant columns
  pivot_wider(names_from = BioSample, values_from = TranscriptsPerGene) %>% # pivot to make the actual otu table
  bind_rows(mapping) %>% # add the group IDs as an additional row
  mutate(across(everything(), ~ replace_na(., 0))) %>% # replace all NA values with 0, as we could not identify these genes in either the metagenomes and/or the metatranscriptomes
  data.frame() %>% # convert the tibble to a dataframe
  column_to_rownames(var = "KO") %>% # use the kegg gene ID as rownames
  t() %>% # flip to match format with samples as rows, and columns as OTUs/ASVs
  data.frame() %>%
  relocate(Group_ID) # make group ID the first column
  
dim(MT_CO2CH4_otutable)

#How man groups do we have? Need below 20 otherwise takes too long
unique(MT_CO2CH4_otutable$Group_ID)

#Set to presence/absence
test <- ifelse(MT_CO2CH4_otutable[,-1]>0,1,0)
dim(MT_CO2CH4_otutable[,-1])

Sys.time()

phi_MT_SuspvsSink <- multipatt(test, 
                 MT_CO2CH4_otutable$Group_ID, 
                 func = "r.g", 
                 control = how(nperm=999),
                 min.order = 1,
                 print.perm = TRUE) 

Sys.time()


summary(phi_MT_SuspvsSink)

Sys.time()
#Run actual indicator species comparison
indval_MT_SuspvsSink <- indicspecies::multipatt(MT_CO2CH4_otutable[,-1],
                    MT_CO2CH4_otutable$Group_ID, 
                    func = "IndVal.g",
                    control = how(nperm=999)) 
Sys.time()

summary(indval_MT_SuspvsSink, alpha = 1)
summary(indval_MT_SuspvsSink, indvalcomp=TRUE)

#A = specificity - how likely that the surveyed site belongs to the target site group given the fact that the species has been found. It is a positive predictive value of the species as indicator of the site group.
#If we find the species how likely is it to belong to that group of sites?

#B = sensitivity - how likely we are to find the species in sites belonging to the site group. It represents how well the species acts as an indicator of the target site group.
#If we look at the site, how likely are we to find the specific species?


#Extract data into a df

indval_MT_SuspvsSink.sign <- indval_MT_SuspvsSink$sign %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
  left_join(
    indval_MT_SuspvsSink$A %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
      rename_with(~ paste0("A_", .), -SampleID), # Rename df2 columns
    by = "SampleID"
  ) %>%
  left_join(
    indval_MT_SuspvsSink$B %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%  # Convert rownames to column
      rename_with(~ paste0("B_", .), -SampleID), # Rename df2 columns
    by = "SampleID"
  ) %>%
  column_to_rownames(var = "SampleID") %>% # Convert back to rownames
  mutate(p.value.bh = p.adjust(p.value, method = "BH")) %>%
  filter(p.value<=0.05) %>%
  filter(index > 1 & index < 4) # Only FL, Suspended, Sinking, and Suspended + Sinking
indval_MT_SuspvsSink.sign

```



##Generate table for export - Table SXX

```{r}

#Import Gene information (carbon and nitrogen cycling specific)
Geneinfo.df = readxl::read_xlsx("D:/Functional_R_analysis/CarbonGene_info.xlsx") %>%
  select(`Gene Name`, `KEGG ID`, Function, `Central/Secondary Metabolism`, Citation) %>%
  mutate(Indicator = `KEGG ID`) %>%
  select(-`KEGG ID`) %>%
  distinct()

#Prep dataframes for joining
indisp_motu.df = indval_motu_FLvsPA.sign %>%
  mutate(Indicator = fulltaxa) %>% #extract the indicator from the rownames
  select(Indicator, index, stat, p.value.bh) %>% # select only the relevant columns
  mutate(Microbiome = "mOTU")
indisp_MG.df = indval_MG_FLvsPA.sign %>%
  rownames_to_column("Indicator") %>% #extract the indicator from the rownames
  select(Indicator, index, stat, p.value.bh) %>% # select only the relevant columns
  mutate(Microbiome = "Functional potential")
indisp_MT.df = indval_MT_FLvsPA.sign%>%
  rownames_to_column("Indicator") %>% #extract the indicator from the rownames
  select(Indicator, index, stat, p.value.bh) %>% # select only the relevant columns
  mutate(Microbiome = "Transcripts")

indsp.df = rbind(indisp_motu.df, indisp_MG.df, indisp_MT.df) %>% #bind mOTU, MG, and MT dfs together
  left_join(Geneinfo.df, by = ("Indicator" = "Indicator"))
indsp.df


write.table(indsp.df, "D:/Functional_R_analysis/Final_Figures_Tables/Indicators_fractions.tsv", sep = "\t", dec = ",")


```

#pH plot - Figure S1
```{r}

PP_data.df = read.csv("D:/Functional_R_analysis/PhysicochemicalParameters_mod3.txt", sep = "\t")

PP_data.df$Sample_date = gsub("-", " ", PP_data.df$Sample_date)

pH.plt = ggplot(PP_data.df, aes(x = Stromkilometer, y = pH, colour = Sample_date, group = Sample_date)) +
  geom_line(lwd = 1)+
  geom_point()+
  xlab("Elbe km")+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme

pH.plt
#Mean of two points was used

pdf("D:/Functional_R_analysis/Figures/pH.pdf", width = 6, height = 6)
pH.plt
dev.off()
```

#Autotrophy estimate (C Fix) - Figure S3

```{r}
####Import metadata####
metadata <- read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAT.genecount.profile")) %>% # Make metatranscriptome metadata file 
  mutate(data_type="METAT") # Add column that says METAT


metadata2 <- read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", header=TRUE, sep=";") %>% 
  mutate(sampleid=paste0(ProjectID,"_",BioSample,"_METAG.genecount.profile"))%>% # Make metagenome metadata file
  mutate(data_type="METAG") # Add column that says METAG

metadata <- rbind(metadata, metadata2) # Combine metadata files

rm(metadata2)

metadata$Station = gsub("Meedem Grund", "Medemgrund", metadata$Station) 

#Clean up data  
metadata$station_km = metadata$Stromkilometer
metadata$station_km = gsub(608.165, 608, metadata$station_km)
metadata$station_km = gsub(613, 713, metadata$station_km)
metadata$station_km = gsub(632.88, 633, metadata$station_km)
metadata$station_km = gsub(632.884, 633, metadata$station_km)
metadata$station_km = gsub(633.022, 633, metadata$station_km)
metadata$station_km = gsub(6334, 633, metadata$station_km)
metadata$station_km = gsub(651.32, 651, metadata$station_km)
metadata$station_km = gsub(651.323, 651, metadata$station_km)
metadata$station_km = gsub(651.955, 651, metadata$station_km)
metadata$station_km = gsub(6513, 651, metadata$station_km)
metadata$station_km = gsub(665.41, 665, metadata$station_km)
metadata$station_km = gsub(665.414, 665, metadata$station_km)
metadata$station_km = gsub(665.546, 665, metadata$station_km)
metadata$station_km = gsub(6654, 665, metadata$station_km)
metadata$station_km = gsub(691.997, 692, metadata$station_km)
metadata$station_km = gsub(692.010, 692, metadata$station_km)
metadata$station_km = gsub(692.01, 692, metadata$station_km)
metadata$station_km = gsub(694, 692, metadata$station_km)
metadata$station_km = gsub(711.515, 713, metadata$station_km)
metadata$station_km = gsub(712, 713, metadata$station_km)
metadata$station_km = gsub(714.975, 713, metadata$station_km)
metadata$station_km = gsub(714.98, 713, metadata$station_km)
sort(unique(metadata$station_km))

metadata = subset(metadata, station_km > 630)
metadata$station_km = as.numeric(metadata$station_km)
metadata$Stromkilometer = NULL

metadata$Sample_date = gsub("-", " ", metadata$Sample_date)
metadata$Sample_date = gsub("Mai", "May", metadata$Sample_date)
rownames(metadata)<-metadata$sampleid
```

```{r}
####Carbon fixing pathways (CFPs) information - 7 major ones####
#Calvin cycle
#the reverse tricarboxylic acid (rTCA) cycle, the 3-hydroxypropionate (3HP) bi-cycle, the 4-hydroxybutyrate/3-hydroxypropionate (4HB/3HP) cycle, the dicarboxylate/4-hydroxybutyrate (DC/4HB) cycle, the reductive acetyl-CoA pathway (WoodâLjungdahl pathwayâWLP), and the reductive glycine pathway
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/


#Calvin cycle - K01601 (cbbL) + cbbM  + K00855 (prkB)
#While both RubisCO and ribulose 5-phosphate kinase are required for the operation of the Calvin cycle, we amplified only portions of genes encoding form I (cbbL) and form II (cbbM) RubisCO as Calvin cycle markers (45). The form III, or archaeal, RubisCO was not included in this analysis, as a functional Calvin cycle has not been demonstrated in members of the domain Archaea that actively express this enzyme (17)
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC522104/#:~:text=Three%20key%20genes%20of%20the,synthase%20%5BnifJ%5D)%3B%20and%202%2D
#Phosphoribulokinase I (PRK1)Phosphoribulokinase II (PRK2)
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/

#rTCA - 	K15230 K15231 (aclAB) +  K00169 K00171 K00169 K00170 (porCDAB) + K00176 K00174 K00175 K00177 (oorDABC)
#rTCA cycle were amplified: ATP citrate lyase (aclAB); pyruvate:ferredoxin oxidoreductase (or ferredoxin-dependent pyruvate synthase), which has two independent genes (heterodimeric pyruvate:ferredoxin oxidoreductase [porCDAB] and homodimeric ferredoxin-dependent pyruvate synthase [nifJ]); and 2-oxoglutarate:ferredoxin oxidoreductase (or Î±-ketoglutarate:acceptor oxidoreductase) (oorDABC) (18, 45).
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC522104/#:~:text=Three%20key%20genes%20of%20the,synthase%20%5BnifJ%5D)%3B%20and%202%2D
#Citryl-CoA lyase (CCL)Citryl-CoA synthetase small (CCSs)Citryl-CoA synthetase large (CCSl
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/


#3-hydroxypropionate (3HP) bi-cycle - 	K14468 (mcr) 	+ K15019 (pcc)
#MalonylâCoA is reduced to 3âhydroxypropionate in a NADPHâdependent reaction, which is catalyzed by the bifunctional enzyme malonylâCoA reductase. This key enzyme comprises malonate semialdehyde and 3âhydroxypropionate dehydrogenase activity (HÃ¼gler et al., 2002).
#Hydroxypropionate is further converted to propionylâCoA by a trifunctional enzyme, propionylâCoA synthase, the second key enzyme of the cycle.
  #https://www.sciencedirect.com/science/article/abs/pii/S0076687905970122?via%3Dihub
  #https://www.sciencedirect.com/science/article/pii/S0021925818520366

#4-hydroxybutyrate/3-hydroxypropionate (4HB/3HP) cycle - K18120 K00043 K08318
#4-Hydroxybutyrate dehydrogenase(HBD)
#https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/

#dicarboxylate/4-hydroxybutyrate (DC/4HB) cycle - 
#4-Hydroxybutyrate dehydrogenase(HBD)
  #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9802188/

#The following 2 use the exact same enzymes for the reverse (oxidation) reaction, so we cannot actually tell what direction is occuring in the sample, hence we must exclude it from the analysis
#reductive acetyl-CoA pathway (WoodâLjungdahl pathwayâWLP) - K00193 (cdhC) + K00194 (cdhD) + K00197 (cdhE) + K00195 (cdhB) + K00196 (cooF) + K00198 (cooS) + K00192 (cdhA)
#CODH/ACS complex - K00193 (cdhC) + K00194 (cdhD) + K00197 (cdhE) + K00195 (cdhB) + K00196 (cooF) + K00198 (cooS) + K00192 (cdhA)
  #https://www.pnas.org/doi/full/10.1073/pnas.1716667115

#reductive glycine pathway - 
#Can run in either direction with identicsl enzymes so no further analysis was pursued


#pufm - K08929
#anoxygenic phototrophy

#### Metagenomes ####

CarbonfixationKeygenes.df = read.csv("F:/Functional_R_analysis/CarbonFixationPathway_KeyGenes.csv", sep = ";") %>%
  dplyr::filter(KO %nin% c("K08929")) %>%
  dplyr::filter(Notes %nin% c("Overestimating due to aclA requirements"))
dim(CarbonfixationKeygenes.df)


CFix_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  filter(KO %in% CarbonfixationKeygenes.df$KO) %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  
  #filter(KO %in% CarbonfixationKeygenes.df$KO) %>% # only extract the CO2CH4 gene
  dplyr::select(gene_cluster, DESCRIPTION, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(-c(KO), sum, na.rm = TRUE)) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(CFix_geneabund_KO)
unique(CFix_geneabund_KO$DESCRIPTION) # Should be 8


CFix_geneabund_KO_long <- CFix_geneabund_KO %>%
  pivot_longer(-c(, DESCRIPTION), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonfixationKeygenes.df, by = c("KO" = "KO")) %>% # Add the carbon fixtion pathway information
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()
  

#Correct abundance
CFix_geneabund_KO_long$counts = CFix_geneabund_KO_long$counts / 1000

#Clean up for plot
CFix_geneabund_KO_long$station_km = as.numeric(as.character(CFix_geneabund_KO_long$station_km))


CFix_geneabund_KO_long$Sample_date = factor(CFix_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

CFix_geneabund_KO_long.sum = Rmisc::summarySE(CFix_geneabund_KO_long, measurevar = "counts", groupvars = c("station_km", "Sample_date", "pathway"))

#Keep for records
write.csv(CFix_geneabund_KO_long.sum, "F:/Functional_R_analysis/CarbonFixationPathways_MG.csv")

#CFix_geneabund_KO_long.sum = read.csv("D:/Functional_R_analysis/CarbonFixationPathways_MG.csv")


CFix_geneabund_KO_long_MG.sum = CFix_geneabund_KO_long.sum



####Metatranscriptomes ####

CFix_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonfixationKeygenes.df$KO) %>% # only extract the CO2CH4 gene
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(CFix_geneabund_KO)



CFix_geneabund_KO_long <- CFix_geneabund_KO %>%
  filter(KO %in% CarbonfixationKeygenes.df$KO) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(CarbonfixationKeygenes.df, by = c("KO"="KO")) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ungroup() %>% 
  distinct()

#Correct abundance
CFix_geneabund_KO_long$counts = CFix_geneabund_KO_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(CFix_geneabund_KO_long)


#Reorder factors
CFix_geneabund_KO_long$Station = factor(CFix_geneabund_KO_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

CFix_geneabund_KO_long$Sample_date = gsub("-", " ",CFix_geneabund_KO_long$Sample_date)

CFix_geneabund_KO_long$Sample_date = factor(CFix_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
CFix_geneabund_KO_long$data_type = gsub("METAT", "Transcriptomes", CFix_geneabund_KO_long$data_type)
CFix_geneabund_KO_long$data_type = gsub("METAG", "Metagenomes", CFix_geneabund_KO_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CFix_TG.df <- spread(CFix_geneabund_KO_long[ , ! names(CFix_geneabund_KO_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(CFix_geneabund_KO_long)
dim(CFix_TG.df)

#Calculate Transcripts per gene copy
CFix_TG.df$TranscriptsPerGenome = CFix_TG.df$Transcriptomes / CFix_TG.df$Metagenomes

#Remove samples for which we have no metatranscriptomes
CFix_TG.df = subset(CFix_TG.df, Associatednumber > 116)

#Remove samples for which sequencing failed
CFix_TG.df = subset(CFix_TG.df, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))

#Make sure data is set up properly
CFix_TG.df$TranscriptsPerGenome = as.numeric(as.character(CFix_TG.df$TranscriptsPerGenome))
CFix_TG.df$Transcriptomes = NULL
CFix_TG.df$Metagenomes = NULL
CFix_TG.df$Associatednumber = as.character(CFix_TG.df$Associatednumber)

CFix_TG.df$Sample_date = factor(CFix_TG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

CFix_TG.sum = Rmisc::summarySE(CFix_TG.df, measurevar = "TranscriptsPerGenome", groupvars = c("station_km", "Sample_date", "pathway"))

#Keep for records
write.csv(CFix_TG.sum, "F:/Functional_R_analysis/CarbonFixationPathways_MT.csv")

#CFix_TG.sum = read.csv("F:/Functional_R_analysis/CarbonFixationPathways_MT.csv")

CFix_geneabund_KO_long_MT.sum = CFix_TG.sum

####Add  sum of carbon fixation pathways ####

#Read in dataframes
CFix_geneabund_KO_long_MG.sum = read.csv("F:/Functional_R_analysis/CarbonFixationPathways_MG.csv")
CFix_geneabund_KO_long_MT.sum = read.csv("F:/Functional_R_analysis/CarbonFixationPathways_MT.csv")
CFix_geneabund_KO_long_MG.sum$X = NULL
CFix_geneabund_KO_long_MT.sum$X = NULL
#Standardise for easier plotting
colnames(CFix_geneabund_KO_long_MG.sum)
CFix_geneabund_KO_long_MT.sum$counts = CFix_geneabund_KO_long_MT.sum$TranscriptsPerGenome
CFix_geneabund_KO_long_MT.sum$TranscriptsPerGenome = NULL
colnames(CFix_geneabund_KO_long_MT.sum)
#Add sequencing info
CFix_geneabund_KO_long_MG.sum$data_type = "Metagenomes"
CFix_geneabund_KO_long_MT.sum$data_type = "TranscriptsperGenome"
#Move the count column for easier viewing if required
CFix_geneabund_KO_long_MT.sum = CFix_geneabund_KO_long_MT.sum %>% relocate(counts, .after = N)

#Add pathways together
CFix_geneabund_KO_long_MG_sum.sum <- CFix_geneabund_KO_long_MG.sum %>% # Read in data
  dplyr::group_by(station_km, Sample_date) %>% # group
  dplyr::summarise(counts = sum(counts, na.rm = TRUE), # calculate the sum of the different pathways 
                   N = n(), #how many samples are included? This is useless as we don't do this on raw data
                   sd = sd(counts, na.rm = TRUE), 
                   se = sd(counts, na.rm = TRUE)/ sqrt(n()),
                   ci = NA
                   ) %>%
  mutate(data_type = "Metagenomes") %>% # add column to match original dataframe
  mutate(pathway = "Combined sum") %>% # add column to match original dataframe
  select(station_km, Sample_date, pathway, N, counts, sd, se, ci, data_type) # place columns in the same order as the original dataframe
#Add the sum of the pathways to the original plot
CFix_geneabund_KO_long_MG.sum = rbind(CFix_geneabund_KO_long_MG.sum, CFix_geneabund_KO_long_MG_sum.sum)

#Add pathways together
CFix_geneabund_KO_long_MT_sum.sum <- CFix_geneabund_KO_long_MT.sum %>% # Read in data
  dplyr::group_by(station_km, Sample_date) %>% # group
  dplyr::summarise(counts = sum(counts, na.rm = TRUE), # calculate the sum of the different pathways 
                   N = n(), #how many samples are included? This is useless as we don't do this on raw data
                   sd = sd(counts, na.rm = TRUE), 
                   se = sd(counts, na.rm = TRUE)/ sqrt(n()),
                   ci = NA
                   ) %>%
  mutate(data_type = "TranscriptsperGenome") %>% # add column to match original dataframe
  mutate(pathway = "Combined sum") %>% # add column to match original dataframe
  select(station_km, Sample_date, pathway, N, counts, sd, se, ci, data_type) # place columns in the same order as the original dataframe
#Add the sum of the pathways to the original plot
CFix_geneabund_KO_long_MT.sum = rbind(CFix_geneabund_KO_long_MT.sum, CFix_geneabund_KO_long_MT_sum.sum)



#### Plotting ####


#Plot separately
CFix_geneabund_KO_long_MG.sum$Sample_date = factor(CFix_geneabund_KO_long_MG.sum$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))

CFix_geneabund_KO_long_MG.sum$pathway = factor(CFix_geneabund_KO_long_MG.sum$pathway,
                                  levels = c("3HP",
                                             "4HB/3HP__DC/4HB",
                                             "Calvin",
                                             "rTCA",
                                             "Combined sum"))


#Plot
CFix_MG.plt = ggplot(CFix_geneabund_KO_long_MG.sum, aes(y = counts, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_point(size = 2)+
  geom_smooth()+
  facet_grid(data_type ~ pathway)+
  scale_y_log10("Gene abundance (per genome)")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
CFix_MG.plt

CFix_geneabund_KO_long_MT.sum$Sample_date = factor(CFix_geneabund_KO_long_MT.sum$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))

CFix_geneabund_KO_long_MT.sum$pathway = factor(CFix_geneabund_KO_long_MT.sum$pathway,
                                  levels = c("3HP",
                                             "4HB/3HP__DC/4HB",
                                             "Calvin",
                                             "rTCA",
                                             "Combined sum"))

#Plot
CFix_MT.plt = ggplot(CFix_geneabund_KO_long_MT.sum, aes(y = counts, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_point(size = 2)+
  geom_smooth()+
  facet_grid(data_type ~ pathway)+
  scale_y_log10("Gene abundance (per gene)")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
CFix_MT.plt


#Combine plots with ggarrange

CFix.plt = ggarrange(CFix_MG.plt,
                     CFix_MT.plt,
                     common.legend = T,
                     ncol = 1,
                     legend = "right")

CFix.plt


pdf("D:/Functional_R_analysis/Final_Figures_Tables/FigureS2_CarbonFixationPaths.pdf", width = 15, height = 9)
CFix.plt
dev.off()

#Correlate rTCA with seasons - METAG
test = CFix_geneabund_KO_long_MG.sum %>% # load data in
  filter(pathway == "rTCA") # select only relevant
model1 = aov(counts ~ station_km * Sample_date, data = test) # generate model
summary(model1) # get p-value 
rstatix::eta_squared(model1) # correlation strength

#Correlate rTCA with seasons - METAT
test = CFix_geneabund_KO_long_MT.sum %>% # load data in
  filter(pathway == "rTCA") # select only relevant
model1 = aov(counts ~ station_km * Sample_date, data = test) # generate model
summary(model1) # get p-value 
rstatix::eta_squared(model1) # correlation strength

```
##Salinity correlation
###Set up Salinity plot
```{r}

#Read in new PP dataframe as a clean data frame
Physicochem.df = readxl::read_xlsx("D:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM."]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

#Extract relevant columns
Salinity.df = Physicochem.df  %>% 
  dplyr::select(all_of(PP_totest.ls)) %>%
  dplyr::select(Sample_date, station_km, Salinity_PSU) %>%
  distinct()
dim(Salinity.df)

#Convert relevant columns to numeric
Salinity.df[,c(2:3)] = as.data.frame(sapply(Salinity.df[,c(2:3)], as.numeric))

Salinity.df$Sample_date = factor(Salinity.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))



```
###Calculate combined
```{r}

#Add pathways together - MG
MG_test.df <- CFix_geneabund_KO_long %>% # Read in data
  select(station_km, Sample_date, counts) %>% # select only relevant columns
  dplyr::group_by(station_km, Sample_date) %>% # group
  dplyr::summarise(counts = sum(counts, na.rm = TRUE) / n()# calculate the sum of the different pathways 
                   ) %>%
  mutate(data_type = "Metagenomes") %>% # add column to match original dataframe
  mutate(pathway = "Combined sum") %>% # add column to match original dataframe
  select(station_km, Sample_date, pathway,counts, data_type) # place columns in the same order as the original dataframe
#Add the sum of the pathways to the original plot and add salinity
MG_test.df = rbind(MG_test.df, CFix_geneabund_KO_long)%>%
  left_join(Salinity.df, by = c("Sample_date" = "Sample_date", "station_km"= "station_km"))

#Add pathways together - MT
MT_test.df <- CFix_TG.df %>% # Read in data
  select(station_km, Sample_date, TranscriptsPerGenome) %>% # select only relevant columns
  dplyr::group_by(station_km, Sample_date) %>% # group
  dplyr::summarise(TranscriptsPerGenome = sum(TranscriptsPerGenome, na.rm = TRUE)/n() # calculate the sum of the different pathways 
                   ) %>%
  mutate(data_type = "Transcriptomes") %>% # add column to match original dataframe
  mutate(pathway = "Combined sum") %>% # add column to match original dataframe
  select(station_km, Sample_date, pathway,TranscriptsPerGenome, data_type) # place columns in the same order as the original dataframe
#Add the sum of the pathways to the original plot and add salinity
MT_test.df = rbind(MT_test.df, CFix_TG.df) %>%
  left_join(Salinity.df, by = c("Sample_date" = "Sample_date", "station_km"= "station_km"))
```

###Run correlations
```{r}

Results_salinity_Cor_Cfix.df = data.frame("Sequencing" = "DELETEME",
                                          "Pathway" = "DELETEME",
                                          "Sample_date" = "DELETEME",
                                          "rho" = 9999,
                                          "p.value" = 9999)

i= unique(MG_test.df$pathway)[1]
x = unique(MG_test.df$Sample_date)[1]
#Run for each pathway - metagenomes
for (i in unique(MG_test.df$pathway)) {
  for (x in unique(MG_test.df$Sample_date)) {
  #Subset to only relevant data
  tmp = subset(MG_test.df, pathway == i & Sample_date == x)
  #Run test
  tmp.cor = cor.test(tmp$counts, tmp$Salinity_PSU, method = "s")
  #Save as new dataframe and combine with the results dataframe
  tmp.df = data.frame("Sequencing" = "GenesPerGenome",
                      "Pathway" = i,
                      "Sample_date" = x,
                      "rho" = tmp.cor$estimate,
                      "p.value" = tmp.cor$p.value)
  Results_salinity_Cor_Cfix.df = rbind(Results_salinity_Cor_Cfix.df, tmp.df)

} }
#Run for each pathway - metatranscriptomes
for (i in unique(MT_test.df$pathway)) {
  for (x in unique(MT_test.df$Sample_date)) {
  #Subset to only relevant data
  tmp = subset(MT_test.df, pathway == i & Sample_date == x)
  #Run test
  tmp.cor = cor.test(tmp$TranscriptsPerGenome, tmp$Salinity_PSU, method = "s")
  #Save as new dataframe and combine with the results dataframe
  tmp.df = data.frame("Sequencing" = "TranscriptsPerGenome",
                      "Pathway" = i,
                      "Sample_date" = x,
                      "rho" = tmp.cor$estimate,
                      "p.value" = tmp.cor$p.value)
  Results_salinity_Cor_Cfix.df = rbind(Results_salinity_Cor_Cfix.df, tmp.df)

} }
Results_salinity_Cor_Cfix.df = Results_salinity_Cor_Cfix.df[-1,]
Results_salinity_Cor_Cfix.df
dim(Results_salinity_Cor_Cfix.df)

Results_salinity_Cor_Cfix_sign.df = subset(Results_salinity_Cor_Cfix.df, p.value < 0.05)
dim(Results_salinity_Cor_Cfix_sign.df)
```

#Plot dCO2, dCH4, and dO2 - Figure S7
```{r}


#Read in new PP dataframe as a clean data frame
Physicochem.df = readxl::read_xlsx("F:/Functional_R_analysis/PhysicochemicalParameters_mod3.xlsx") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM."]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"

#Extract relevant columns
PP_totest.df = Physicochem.df  %>% 
  dplyr::select(all_of(PP_totest.ls)) %>%
  dplyr::select(Sample_date, station_km, O2_uM, dCO2_uM, dCH4_nM, Salinity_PSU) %>%
  distinct()
dim(PP_totest.df)

#Convert relevant columns to numeric
PP_totest.df[,c(2:6)] = as.data.frame(sapply(PP_totest.df[,c(2:6)], as.numeric))

PP_totest.df$Sample_date = factor(PP_totest.df$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))

CO2.sum = Rmisc::summarySE(PP_totest.df, measurevar = "dCO2_uM", groupvars = c("Sample_date", "station_km"), na.rm = TRUE)

CO2.plt = ggplot(CO2.sum, aes(x = station_km, y = dCO2_uM, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth(se = FALSE) +
  geom_errorbar(
    aes(ymin = dCO2_uM - se, 
        ymax = dCO2_uM + se, 
        colour = Sample_date),
                width = 3
  )+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab(expression("Dissolved CO"[2]~"(ÂµM)"))
CO2.plt

cor.test(PP_totest.df$dCO2_uM, PP_totest.df$station_km, method = "p")
cor.test(PP_totest.df$dCO2_uM, PP_totest.df$Salinity_PSU, method = "p")


CH4.sum = Rmisc::summarySE(PP_totest.df, measurevar = "dCH4_nM", groupvars = c("Sample_date", "station_km"), na.rm = TRUE)

CH4.plt = ggplot(CH4.sum, aes(x = station_km, y = dCH4_nM, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth(se = FALSE) +
  geom_errorbar(
    aes(ymin = dCH4_nM - se, 
        ymax = dCH4_nM + se, 
        colour = Sample_date),
                width = 3
  )+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  scale_y_log10()+
  My_Theme+
  xlab("Elbe km")+
  ylab(expression("Dissolved CH"[4]~"(nM)"))
CH4.plt

cor.test(PP_totest.df$dCH4_nM, PP_totest.df$station_km, method = "s")
cor.test(PP_totest.df$dCH4_nM, PP_totest.df$Salinity_PSU, method = "s")

O2.sum = Rmisc::summarySE(PP_totest.df, measurevar = "O2_uM", groupvars = c("Sample_date", "station_km"), na.rm = TRUE)

O2.plt = ggplot(O2.sum, aes(x = station_km, y = O2_uM, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth(se = FALSE) +
  geom_errorbar(
    aes(ymin = O2_uM - se, 
        ymax = O2_uM + se, 
        colour = Sample_date),
                width = 3
  )+
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab(expression("Dissolved O"[2]~"(ÂµM)"))
O2.plt

cor.test(PP_totest.df$O2_uM, PP_totest.df$station_km, method = "s")
cor.test(PP_totest.df$O2_uM, PP_totest.df$Salinity_PSU, method = "s")

O2dC02dCH4.plt = ggpubr::ggarrange(O2.plt, CO2.plt, CH4.plt,
          common.legend = T,
          legend = "right")
O2dC02dCH4.plt

pdf("D:/Functional_R_analysis/Figures/O2dCO2dCH4.pdf", width = 8, height = 6)
O2dC02dCH4.plt
dev.off()


cor.test(PP_totest.df$O2_uM, PP_totest.df$Salinity_PSU, method = "s")
cor.test(PP_totest.df$dCO2_uM, PP_totest.df$station_km, method = "s")


####For funsies####


PP_totest.df$O2plusCO2 = PP_totest.df$dCO2_uM - PP_totest.df$O2_uM 

O2plusCO2.plt = ggplot(PP_totest.df, aes(x = station_km, y = O2plusCO2, colour = Sample_date, group = Sample_date)) + 
  geom_point() + 
  geom_smooth() +
  scale_color_manual("Date", values = Date_colour_list)+
  scale_x_reverse()+
  My_Theme+
  xlab("Elbe km")+
  ylab(expression("Dissolved O"[2]~"(ÂµM)"))
O2plusCO2.plt


```
#Anoxygenic phototrophic bacteria assessment - pufM
There are two main anoxygenic phototrophy pathways in bacteria, one uses photochemical reaction centres, and we can use pufM and puL as marker genes for this, primers specifically designed for this (Gazulla et al., 2023; 10.1007/s00248-023-02220-y). But the other pathway involves rhodopsins (Bryan & Frigaard 2006; 10.1016/j.tim.2006.09.001), which have not been explored to a similar extent, PR database: Boeuf et al., 2015; 10.1093/database/bav080

Marker genes for all light-harvestig mechanisms have been established (Finkel et al., 2013; 10.1038/ismej.2012.112), and they include micorbial rhodopsins (PR), photosystem-I (psaA) and aerobic anoxygenic photosynthesis (pufM).

But pufM (KO: K08929) has been well established and commonly used on its own (Villena-Alemany, et al., 2024; 10.1186/s40168-024-01786-0) . If this is found by a reviewer, please mention this note and I will work to integrate the database and other genes into the supplementary infomation.

Actinorhodopsins, pufM, bchL/chlLm and bchX genes for phototrophic systems - 10.3389/fmicb.2016.02026

Review of rhodopsins over the last 20 years: 10.1146/annualrev-micro-031721-020452
```{r}

#load metasdata from clean backup
metadata = metadata_v0

#### Metagenomes ####


AAPTroph_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  filter(KO %in% "K08929") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  dplyr::select(gene_cluster, DESCRIPTION, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(-c(KO), sum, na.rm = TRUE)) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(AAPTroph_geneabund_KO)
unique(AAPTroph_geneabund_KO$DESCRIPTION) # Should be 1


AAPTroph_geneabund_KO_long <- AAPTroph_geneabund_KO %>%
  pivot_longer(-c(, DESCRIPTION), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct() %>%
  dplyr::filter(SName!="amoA")
AAPTroph_geneabund_KO_long

#Correct abundance
AAPTroph_geneabund_KO_long$counts = AAPTroph_geneabund_KO_long$counts / 1000

#Clean up for plot
AAPTroph_geneabund_KO_long$station_km = as.numeric(as.character(AAPTroph_geneabund_KO_long$station_km))


AAPTroph_geneabund_KO_long$Sample_date = factor(AAPTroph_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

AAPTroph_MG.df = AAPTroph_geneabund_KO_long

#Add together the different fractions
AAPTroph_pufM_MG.sum <- AAPTroph_MG.df %>%
  group_by(Sample_date, station_km) %>%
  summarise(
    mean_pufM = mean(counts, na.rm = TRUE),
    pufM_sd = sd(counts),
    pufM_se = se(counts),
  ) %>%
  mutate(data_type = "GenesPerGenome")
AAPTroph_pufM_MG.sum





####Metatranscriptomes ####

AAPTroph_geneabund_KO = annot %>%
  filter(KO %in% "K08929") %>% # only extract the CO2CH4 gene
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  
  dplyr::select(gene_cluster, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(AAPTroph_geneabund_KO)

AAPTroph_geneabund_KO_long <- AAPTroph_geneabund_KO %>%
  pivot_longer(!DESCRIPTION, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  
 
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ungroup() %>% 
  distinct()

#Correct abundance
AAPTroph_geneabund_KO_long$counts = AAPTroph_geneabund_KO_long$counts / 1000


#View(amoAClean_CO2CH4_tbl_long)
dim(AAPTroph_geneabund_KO_long)


#Reorder factors
AAPTroph_geneabund_KO_long$Station = factor(AAPTroph_geneabund_KO_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

AAPTroph_geneabund_KO_long$Sample_date = gsub("-", " ",AAPTroph_geneabund_KO_long$Sample_date)

AAPTroph_geneabund_KO_long$Sample_date = factor(AAPTroph_geneabund_KO_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
AAPTroph_geneabund_KO_long$data_type = gsub("METAT", "Transcriptomes", AAPTroph_geneabund_KO_long$data_type)
AAPTroph_geneabund_KO_long$data_type = gsub("METAG", "Metagenomes", AAPTroph_geneabund_KO_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
AAPTroph_TG.df <- spread(AAPTroph_geneabund_KO_long[ , ! names(AAPTroph_geneabund_KO_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(AAPTroph_geneabund_KO_long)
dim(AAPTroph_TG.df)

#Calculate Transcripts per gene copy
AAPTroph_TG.df$TranscriptsPerGenome = AAPTroph_TG.df$Transcriptomes / AAPTroph_TG.df$Metagenomes


#Remove samples for which we have no metatranscriptomes
AAPTroph_TG.df = subset(AAPTroph_TG.df, Associatednumber > 116)
AAPTroph_TG.df = subset(AAPTroph_TG.df, TranscriptsPerGenome < 999999999)

#Remove samples for which sequencing failed
AAPTroph_TG.df = subset(AAPTroph_TG.df, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))

#Make sure data is set up properly
AAPTroph_TG.df$TranscriptsPerGenome = as.numeric(as.character(AAPTroph_TG.df$TranscriptsPerGenome))
AAPTroph_TG.df$Transcriptomes = NULL
AAPTroph_TG.df$Metagenomes = NULL
AAPTroph_TG.df$Associatednumber = as.character(AAPTroph_TG.df$Associatednumber)

AAPTroph_TG.df$Sample_date = factor(AAPTroph_TG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))
#Add together the different fractions
AAPTroph_pufM_MT.sum <- AAPTroph_TG.df %>%
  group_by(Sample_date, station_km) %>%
  summarise(
    mean_pufM = mean(TranscriptsPerGenome, na.rm = TRUE),
    pufM_sd = sd(TranscriptsPerGenome),
    pufM_se = se(TranscriptsPerGenome),
  ) %>%
  mutate(data_type = "TranscriptsperGene")
AAPTroph_pufM_MT.sum




#### Plotting simple figure - removed fractions - Attic ####



#Make pretty
AAPTroph_pufM_MG.sum$Sample_date = factor(AAPTroph_pufM_MG.sum$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))
AAPTroph_pufM_MT.sum$Sample_date = factor(AAPTroph_pufM_MT.sum$Sample_date,
                                  levels = c("May 21",
                                             "Jul 21",
                                             "Feb 22",
                                             "May 22",
                                             "Jun 22",
                                             "Nov 22"))



#Plot
AAPTroph_MG.plt = ggplot(AAPTroph_pufM_MG.sum, aes(y = mean_pufM, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_smooth()+
  geom_point()+
  geom_errorbar(aes(ymin = mean_pufM - pufM_sd, ymax = mean_pufM + pufM_sd, colour = Sample_date),
                width = 3) + 
  facet_grid(data_type ~ .)+
  scale_y_log10("pufM abundance")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  My_Theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
AAPTroph_MG.plt

AAPTroph_MT.plt = ggplot(AAPTroph_pufM_MT.sum, aes(y = mean_pufM, x = station_km, colour = Sample_date, group = Sample_date)) +
  geom_smooth()+
  geom_point()+
  geom_errorbar(aes(ymin = mean_pufM - pufM_sd, ymax = mean_pufM + pufM_sd, colour = Sample_date),
                width = 3) + 
  facet_grid(data_type ~ .)+
  scale_y_log10("pufM abundance")+
  scale_x_reverse("Elbe km")+
  scale_color_manual("Sample Date", values = Date_colour_list)+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
AAPTroph_MT.plt


AAPTroph_pufM_MG.sum %>%
  #dplyr::group_by(Sample_type) %>%
  ungroup() %>%
  dplyr::summarise(mean_val = mean(mean_pufM))
AAPTroph_pufM_MT.sum %>%
  #dplyr::group_by(Sample_type) %>%
  ungroup() %>%
  dplyr::summarise(mean_val = mean(mean_pufM))


#Combine plots with ggarrange

AAPTroph.plt = ggarrange(AAPTroph_MG.plt,
                     AAPTroph_MT.plt,
                     common.legend = T,
                     ncol = 2,
                     legend = "right")

AAPTroph.plt


pdf("D:/Functional_R_analysis/Figures/Figure3_pufM.pdf", width = 9, height = 4)
AAPTroph.plt
dev.off()


#### Statistics and means ####
#Subset to only pufM
pufM_TG.df = subset(AAPTroph_TG.df, SName == "pufM")

#Calculate meana nd median
Mean_MG = AAPTroph_geneabund_KO_long %>%
  group_by(SName, Sample_type) %>%
  summarise(average = mean(counts), median = median(counts))
Mean_MG
Mean_MT = pufM_TG.df %>%
  group_by(SName, Sample_type) %>%
  summarise(average = mean(TranscriptsPerGenome), median = median(TranscriptsPerGenome))
Mean_MT

#Also consider distributions
Rmisc::summarySE(AAPTroph_geneabund_KO_long, measurevar = "counts", groupvars = c("SName", "Sample_type"))
Rmisc::summarySE(AAPTroph_TG.df, measurevar = "TranscriptsPerGenome", groupvars = c("SName", "Sample_type"))

#Significant differences between sample types
pairwise.wilcox.test(AAPTroph_geneabund_KO_long$counts, AAPTroph_geneabund_KO_long$Sample_type)
pairwise.wilcox.test(pufM_TG.df$TranscriptsPerGenome, pufM_TG.df$Sample_type)

#Significant correlation with Elbe km
cor.test(AAPTroph_geneabund_KO_long$counts, AAPTroph_geneabund_KO_long$station_km, AAPod = "s")
cor.test(pufM_TG.df$TranscriptsPerGenome, pufM_TG.df$station_km, AAPod = "s")

#Add salinity to the dataframes
Salinity_pufM_MG.df = AAPTroph_geneabund_KO_long %>%
  left_join(Salinity.df, by = c("Sample_date" = "Sample_date", "station_km" = "station_km"))
#Add salinity to the dataframes
Salinity_pufM_MT.df = pufM_TG.df %>%
  left_join(Salinity.df, by = c("Sample_date" = "Sample_date", "station_km" = "station_km"))

#Significant correlation with Salinity
cor.test(Salinity_pufM_MG.df$counts, Salinity_pufM_MG.df$Salinity_PSU, AAPod = "s")
cor.test(Salinity_pufM_MT.df$TranscriptsPerGenome, Salinity_pufM_MT.df$Salinity_PSU, AAPod = "s")

```


