---
title: "All genes"
output: html_document
date: "2024-07-12"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Load packages

```{r}
library(microeco)
library(meconetcomp)
library(dplyr)
library(tibble)
library(tidyr)
library(phyloseq)
library(magrittr)
library(ggplot2)

library(SpiecEasi)
library(mixedCCA)
library(SPRING)
library(beemStatic)
library(chorddiag)
library(ggradar)

library(Hmisc)


require(RCurl)
require(R.utils)
require(plotly)
require(forcats)
require(vegan)
require(dplyr)
require(ggpubr)
library(stringr)

require(WGCNA)

library(Hmisc)
library(igraph)
library(tidyverse)     # tidyverse will pull in ggplot2, readr, other useful libraries
library(magrittr)      # provides the %>% operator
library(genefilter)



```
#Prep environment
```{r}

#Set seed to make results more reproducible
set.seed(2)
#Set language to english
Sys.setenv(LANG = "en")
#Set up working directory
setwd("D:/Functional_R_analysis/")
#Define theme for plotting
My_Theme = theme_bw()+
  theme(axis.title.x = element_text(size=18),
       # theme_grey(base_size = 22),
        axis.text.x = element_text(angle=0, colour = "black", vjust=1, hjust = 0.5, size=18), 
        axis.text.y = element_text(colour = "black", size=18),
        axis.title.y = element_text(size=18),
        plot.title = element_text(size = 18, hjust = 0.5),
        legend.title =element_text(size = 18),
        legend.text = element_text(size = 16),
        legend.position="right",
        legend.key.size = unit(1, "cm"),
        strip.text.x = element_text(size=18, face="bold"),
        strip.text.y = element_text(size=18, face="bold"),
        #panel.background = element_blank(),
        panel.border = element_rect(fill = NA, colour = "black"),
        strip.background = element_rect(colour="black"),
       text = element_text(family = "sans"))

Poster_Theme = theme_bw()+
  theme(axis.title.x = element_text(size=28),
       # theme_grey(base_size = 22),
        axis.text.x = element_text(angle=0, colour = "black", vjust=1, hjust = 0.5, size=24), 
        axis.text.y = element_text(colour = "black", size=24),
        axis.title.y = element_text(size=28),
        plot.title = element_text(size = 24, hjust = 0.5),
        legend.title =element_text(size = 28),
        legend.text = element_text(size = 24),
        legend.position="right",
        legend.key.size = unit(1, "cm"),
        strip.text.x = element_text(size=24, face="bold"),
        strip.text.y = element_text(size=24, face="bold"),
        #panel.background = element_blank(),
        panel.border = element_rect(fill = NA, colour = "black"),
        strip.background = element_rect(colour="black"),
       text = element_text(family = "sans"))

#Station specific colours for consistency
Station_colour_list <- c("Muelenberger Loch" =  "black",
                "Twielenfleth" = "red",
                #"" = "violet",
                #"" = "violetred4", 
                "Schwarztonnensand" = "navy",
                #"" = "",
                #"" = "thistle3", 
                "Brunbuettel" = "forestgreen",
                #"" = "darkred",
                "Medemgrund" = "green",
                #"" = "orange",
                #"" = "turquoise",
                #"" = "cornflowerblue",
                #"" = "beige",
                "Station6" = "magenta")

Date_colour_list <- c(
                "May 21" = "forestgreen",
                "Jul 21" =  "red",
                #"" = "violet",
                #"" = "violetred4", 
                #"" = "",
                #"" = "thistle3", 
                "Feb 22" = "black",
                #"" = "darkred",
                #"" = "turquoise",
                #"" = "cornflowerblue",
                #"" = "beige",
                #"" = "orange",
                "May 22" = "green",
                "Jun 22" = "darkorange",
                "Nov 22" = "cornflowerblue"
                )

#Colourblind friendly pallete
cbbPalette <- c("black",
                "red",
                "navy", 
                "green", 
                "magenta",
                "forestgreen")
#If more options are needed
expanded_cbbPalette <- c("#000000", #Black
                "#E69F00", #Orange
                "#56B4E9", #Blue (light)
                "#009E73", #Sea green
                "#CC79A7", #Magenta (light)
                "#F0E442", #Yellow
                "#0072B2", #Blue
                "#D55E00", #Burnt orange
                "dodgerblue4",
                "rosybrown",
                "floralwhite",
                "lightgoldenrod4",
                "cornsilk3",
                "coral4",
                "gray38",
                "turquoise4",
                "springgreen3",
                "slateblue3",
                "forestgreen",
                "lightgreen") 

#Shapes for ggplot2
Shape_list = c(0, #Hollow square
               15, #Filled square
               1, #Hollow circle
               16, #Filled circle
               2, #Hollow triangle
               17, #Filled triangle
               5, #Hollow diamond
               23) #Filled diamond
                
#Set up position dodge for ggplot2
pd = position_dodge(0.15)

ConditionColourList <- c("AlcianBlue" = "black",
                         "CBBG" = "red")

#Colourblind friendly pallete
FractionColourList <- c("Suspended" = "grey50",
                        "Sinking" = "black")
FractionSecondaryColourList <- c(#"Suspended" = "black",
                                 #"Sinking" = "red",
                                 #"navy",
                                 "Suspended" = "grey", 
                                 "Sinking" = "grey40")


Group_colours = c("Dissolved Organic" = "#000000", #Black
                  "Dissolved Inorganic" =  "#E69F00", #Orange
                  "Free-Living Organisms"= "#56B4E9", #Blue (light),
                  "Suspended PAO" = "#009E73", #Sea green,
                  "Sinking PAO" = "#CC79A7", #Magenta (light),
                  "Suspended Organic Particles" = "#F0E442", #Yellow,
                  "Suspended Inorganic Particles" = "#0072B2", #Blue,
                  "Sinking Organic Particles" = "#D55E00", #Burnt orange,
                  "Sinking Inorganic Particles" = "dodgerblue4")

```

#Prep metadata
```{r}


#Read in new PP dataframe as a clean data frame
Physicochem.df = read.csv("D:/Functional_R_analysis/PhysicochemicalParameters_mod2.txt", encoding = "UTF-8", sep = "\t") %>%
  subset(Sample_date!="Nov 21") #Remove data taken from shore

#Clean up data  
Physicochem.df$station_km = as.numeric(Physicochem.df$Stromkilometer)
Physicochem.df$Stromkilometer = NULL
Physicochem.df$station_km = gsub(608.165, 608, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(613, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.88, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(632.884, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(633.022, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6334, 633, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.32, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.323, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(651.955, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6513, 651, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.41, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.414, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(665.546, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(6654, 665, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(691.997, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.010, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(692.01, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(694, 692, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(711.515, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(712, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.975, 713, Physicochem.df$station_km)
Physicochem.df$station_km = gsub(714.98, 713, Physicochem.df$station_km)
sort(unique(Physicochem.df$station_km))

Physicochem.df = subset(Physicochem.df, station_km > 630)

#Rename rows for downstream applications
rownames(Physicochem.df) = Physicochem.df$Associatednumber

#Add density data - calculated from dry-weight and area
Physicochem.df$Density_gpercm3 = (as.numeric(Physicochem.df$SPM_mgperL) / (as.numeric(Physicochem.df$ParticleArea_um2perL))) * 10^5

#Add PA PP to Free-living rows 

#Extract sample numbers for FL - MG
FL_samples.df = Physicochem.df %>%
  filter(Sample_type == "Free_living")
PA_PP.ls = c("SPM_mgperL", "ParticleArea_um2perL", "Density_gpercm3", "POC_mgperL", "PTC_mgperL", "PTN_mgperL", "PTH_mgperL", "TEP_um2perL", "CSP_um2perL")
count = 1
i=6
x="SPM_mgperL"
for (i in 1:length(Physicochem.df$Associatednumber)) {
  if (grepl(Physicochem.df$Sample_type[i], "Free_living") == T ) {
    #Bug hunting
    #print(paste0("Match ",count, " found"))
    PA_sub.df = subset(Physicochem.df, Sample_type!="Free_living" & 
                         station_km == Physicochem.df$station_km[i] & 
                         Sample_date == Physicochem.df$Sample_date[i])
    for (x in PA_PP.ls) {
      #Bug hunting
      #print(paste0("Matching ", x))
      mean.tmp = mean(unlist(PA_sub.df[x]))
      #Bug hunt
      #print(paste0("Getting ", mean.tmp))
      Physicochem.df[i,x] = mean(unlist(PA_sub.df[x]))
    }
    count = count + 1
  }
}

Physicochem.df$Associatednumber = as.character(Physicochem.df$Associatednumber)

#Remove redundant ones identified with correlated pearson tests
PP_totest.ls = unique(colnames(Physicochem.df))
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Associatednumber"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DNA_concentration_ng.uL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Station"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "StationNumber"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_type"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sample_date"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "AccessionNumber_TBDSven"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "POC_mgperL"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "PTH_mgperL"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TN_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Total_DIN_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Phosphate_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Temperature_TBDHereon"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_uM"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "Ammonium_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Nitrite_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Silicate_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "SRP_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "RespirationRate_O2ug.L.h"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DIC_uM.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "DOC_uM.L"]  # Removes elements that are "b"
#PP_totest.ls = PP_totest.ls[PP_totest.ls != "TotalDissolvedPhosphate_mg.L"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "Sat_O2_Perc"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCH4_uM"]  # Removes elements that are "b"
PP_totest.ls = PP_totest.ls[PP_totest.ls != "dCO2_nM"]  # Removes elements that are "b"


#Extract relevant columns
PP_totest.df = Physicochem.df  %>% dplyr::select(all_of(PP_totest.ls))

colnames(PP_totest.df)

#Make sure rownames have been preserved
rownames(PP_totest.df)
dim(PP_totest.df)


#Apply row numbers from sample IDs
rownames(PP_totest.df) = PP_totest.df$Associatednumber
PP_totest.df$Associatednumber = NULL




#Add lifestyle information
tmp = data.frame(model.matrix(~ PP_totest.df$Sample_type-1, data=PP_totest.df))
colnames(tmp) = gsub("PP_totest.df.Sample_type", "", colnames(tmp))
PP_totest.df = cbind(PP_totest.df, tmp)

#Add date information
tmp = data.frame(model.matrix(~ PP_totest.df$Sample_date-1, data=PP_totest.df))
colnames(tmp) = gsub("PP_totest.df.Sample_date", "", colnames(tmp))
PP_totest.df = cbind(PP_totest.df, tmp)

#Add station information
tmp = data.frame(model.matrix(~ PP_totest.df$Station-1, data=PP_totest.df))
colnames(tmp) = gsub("PP_totest.df.Station", "", colnames(tmp))
PP_totest.df = cbind(PP_totest.df, tmp)

#Add density data - calculated from dry-weight and area
PP_totest.df$Density_gpercm3 = (as.numeric(PP_totest.df$SPM_mgperL) / (as.numeric(PP_totest.df$ParticleArea_um2perL))) * 10^5




#Flip so columns are samples for dissimilarity assessment
PP_totest.df = t(PP_totest.df)

#Get sample names for microbiome comparison
PP_totest.ls = rownames(PP_totest.df)


PP_loop.df = PP_totest.df[-c(1:3),]


PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric)


####Generate metadata file for WGCNA ####
metadata_WGCNA = Physicochem.df %>%
  dplyr::select(Associatednumber, station_km, Sample_type, Sample_date, 
         SPM_mgperL, DOC_mg.L, TN_mg.L, DIC_mg.L, POC_mgperL, PTC_mgperL, PTN_mgperL,
         Sat_O2_Perc, Temperature_TBDHereon, Salinity_PSU, Turbidity_NTU, pH, O2_uM, Silicate_mg.L, Ammonium_mg.L,
         Nitrite_mg.L, Nitrate_mg.L, SRP_mgperL, TotalDissolvedPhosphate_mg.L,
         ParticleArea_um2perL, TEP_um2perL, CSP_um2perL, dCH4_nM, dCO2_uM) %>%
  distinct()

metadata_WGCNA$Sample_date = gsub(" ","_", metadata_WGCNA$Sample_date)

rownames(metadata_WGCNA) = metadata_WGCNA$Associatednumber

metadata_WGCNA = metadata_WGCNA %>%
  as.data.frame() %>%
  mutate(TEP_um2perL = TEP_um2perL/100000000) %>%
  mutate(CSP_um2perL = CSP_um2perL/100000000)
#Divide by 100000000, due to limitations in floating-point computations and precision, and these numbers are much much larger than any of the others.

tmp = data.frame(model.matrix(~ metadata_WGCNA$Sample_type-1, data=metadata_WGCNA))
colnames(tmp) = c("FreeLiving", "SinkingParticles", "SuspendedParticles")

metadata_WGCNA = cbind(metadata_WGCNA, tmp)


#Add lifestyle information
tmp = data.frame(model.matrix(~ metadata_WGCNA$Sample_type-1, data=metadata_WGCNA))
colnames(tmp) = gsub("metadata_WGCNA.Sample_type", "", colnames(tmp))
metadata_WGCNA = cbind(metadata_WGCNA, tmp)

#Add date information
tmp = data.frame(model.matrix(~ metadata_WGCNA$Sample_date-1, data=metadata_WGCNA))
colnames(tmp) = gsub("metadata_WGCNA.Sample_date", "", colnames(tmp))
metadata_WGCNA = cbind(metadata_WGCNA, tmp)

#Add density data - calculated from dry-weight and area
metadata_WGCNA$Density_gpercm3 = (as.numeric(metadata_WGCNA$SPM_mgperL) / (as.numeric(metadata_WGCNA$ParticleArea_um2perL))) * 10^5

#Add date information
#tmp = data.frame(model.matrix(~ metadata_WGCNA$Station-1, data=metadata_WGCNA))
#colnames(tmp) = gsub("metadata_WGCNA.Station", "", colnames(tmp))
#metadata_WGCNA = cbind(metadata_WGCNA, tmp)

```
#Prep taxa table
```{r}

#Create taxa table equivalent
All_WGCNA_taxtable = annot %>%
  filter(KO!="") %>%
  mutate(KO = as.character(KO)) %>%
  tibble::remove_rownames() %>%
  distinct() %>%
  column_to_rownames(var = "KO") %>%
  dplyr::select(DISEASE, DRUG, ENZYME, MODULE, PATHWAY, PUBMED, REACTION, DESCRIPTION) %>%
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) #separate description

```

#Carry out with metagenome data - Figure 5
```{r Prep metagenome data}

#Import gene list
CarbonGenelist.df = read.csv("F:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
#sort(unique(amoAMatches.ls$KO))

Geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
  mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  dplyr::select(gene_cluster, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(Geneabund_KO)





#saveRDS(Geneabund_KO, "F:/Functional_R_analysis/Network/Geneabund_KO_MG.rds")
Geneabund_KO = readRDS("F:/Functional_R_analysis/Network/Geneabund_KO_MG.rds")

Geneabund_KO_MG.lng <- Geneabund_KO %>%
  pivot_longer(!DESCRIPTION, names_to = "sampleid", values_to = "counts", values_drop_na = 0) # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0. 

  
  
##Need to cut dataframe into 120 pieces and run code on it in loop, and then stick it back together
  ##This needs to be redone
  
Final_Geneabund_KO_MG.lng = as.data.frame(matrix(ncol = 27, nrow = 1))
colnames(Final_Geneabund_KO_MG.lng) = c("sampleid", "counts", "SName", "LName", "KO", "Sample",   "Associatednumber", "DNA_concentration_ng.uL", "Station", "StationNumber", "Sample_type", "Sample_date", "SPM_mgperL", "DOC_mg.L", "TN_mg.L",  "DIC_mg.L", "DOC_uM.L", "DIC_uM.L", "POC_mgperL", "PTC_mgperL", "PTN_mgperL",  "PTH_mgperL", "BioSample", "ERANumber", "ProjectID", "data_type", "station_km")
  
i=1
i=120
for (i in 1:ceiling(dim(Geneabund_KO_MG.lng)[1]/18158)) {
  
  number = i * 18158 
  #number = i * 20
  
  tmp.lng = Geneabund_KO_MG.lng[c((number-18158):number),] 
  #tmp.lng = Geneabund_KO_MG.lng[c((number-20):number),] # Bug hunting
  
  tmp.out = tmp.lng %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information for amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()
  
  Final_Geneabund_KO_MG.lng = rbind(Final_Geneabund_KO_MG.lng, tmp.out)
  
  
  if ( i == ceiling(dim(Geneabund_KO_MG.lng)[1]/18158) ) {
    
    end = dim(Geneabund_KO_MG.lng)[1]
    number = ((i-1) * 18158)
    tmp.lng = Geneabund_KO_MG.lng[c(number:end),] 
    
    tmp.out = tmp.lng %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information fpr amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()
  
  Final_Geneabund_KO_MG.lng = rbind(Final_Geneabund_KO_MG.lng, tmp.out)
  
  print(paste0("Finished the last one!"))
  }
  
  print(paste0("Completed ", i, " out of ", round(dim(Geneabund_KO_MG.lng)[1]/18158), " dataframes, which is ", round(i/round(dim(Geneabund_KO_MG.lng)[1]/18158) * 100), "%"))
  
  
}

#Remove unnecesary top row, as it was generated when making the initial df
Final_Geneabund_KO_MG.lng = Final_Geneabund_KO_MG.lng[-1,]

Geneabund_KO_MG.lng = Final_Geneabund_KO_MG.lng

#save in case of crashes (which are inevitable with a df of this size)
saveRDS(Final_Geneabund_KO_MG.lng, "F:/Functional_R_analysis/Network/Geneabund_KO_MG.lng.rds")
#Geneabund_KO_MG.lng = readRDS("D:/Functional_R_analysis/Network/Geneabund_KO_MG.lng.rds") 


#Correct count data
Geneabund_KO_MG.lng$counts = Geneabund_KO_MG.lng$counts / 1000

#View(Geneabund_KO_MG.lng)
dim(Geneabund_KO_MG.lng)

#Reorder factors
Geneabund_KO_MG.lng$Statio = factor(Geneabund_KO_MG.lng$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

Geneabund_KO_MG.lng$Sample_date = gsub("-", " ",Geneabund_KO_MG.lng$Sample_date)

Geneabund_KO_MG.lng$Sample_date = factor(Geneabund_KO_MG.lng$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
Geneabund_KO_MG.lng$data_type = gsub("METAG", "Metagenomes", Geneabund_KO_MG.lng$data_type)

dim(Geneabund_KO_MG.lng)

#Remove outliers and make dataframe wide from a long format
Geneabund_KO_MG.wde = Geneabund_KO_MG.lng %>%
  dplyr::select(Associatednumber, counts, KO) %>%
  pivot_wider(names_from = KO, values_from = counts, values_fn = mean) %>%
  as.data.frame() %>%
  filter(Associatednumber!="164") %>%
  column_to_rownames("Associatednumber")

#We need to have samples as columns, and genes as rows in a wide format.
WGCNA_MG_raw.df = t(Geneabund_KO_MG.wde)

```
## Actual WGCNA for MG
### Sample_type
```{r}

set.seed(2)

data = WGCNA_MG_raw.df %>%
  as.data.frame() %>%
  rownames_to_column(var = "GeneId")



data[1:5,1:10]        # Look at first 5 rows and 10 columns
dim(data)

names(data)[1] = "GeneId"
names(data)           # Look at the column names


col_sel = names(data)[-1]     # Get all but first column name
mdata <- data %>%
  tidyr::pivot_longer(
    .,                        # The dot is the the input data, magrittr tutorial
    col = all_of(col_sel),
    values_transform = as.numeric
    ) %>%
  left_join(metadata_WGCNA, by = c("name" = "Associatednumber")) %>%
  dplyr::select(GeneId, name, value, Sample_type) %>%
  dplyr::rename(group = Sample_type)

mdata$name = as.character(mdata$name)


# ==== Plot groups (Sample Groups vs RNA Seq Counts) to identify outliers

 p <- mdata %>%
    ggplot(., aes(x = name, y = value)) +             # x = treatment, y = RNA Seq count
    geom_violin() +                                   # violin plot, show distribution
    geom_point(alpha = 0.2) +                         # scatter plot
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)          # Rotate treatment text
    ) +
    labs(x = "Treatment Groups / Samples", y = "Gene Hit Counts") +
    facet_grid(cols = vars(group), drop = TRUE, scales = "free_x")      # Facet by hour
p

pdf("F:/Functional_R_analysis/Network/WGCNA_OutlierHunting_MG_all.pdf", width = 48, height = 10)
p
dev.off()
#No outliers were detected

#Remove outliers
#mdata = mdata %>%
 # filter(value < 4000000)
#Rerun above code to make sure outliers have been removed

#Normalise data with DESeq2
library(DESeq2)
de_input = as.data.frame(data[,-1])
row.names(de_input) = data$GeneId
de_input[1:5,1:10]


meta_df <- data.frame(Sample = names(data[-1])) %>%
  left_join(metadata_WGCNA, by = c("Sample" = "Associatednumber")) %>%
  dplyr::select(Sample, Sample_type) %>%
  dplyr::rename(Type = Sample_type)

dds <- DESeq2::DESeqDataSetFromMatrix(round(de_input),
                              meta_df,
                              design = ~Type)
#> converting counts to integer mode
#> Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#> design formula are characters, converting to factors

dds <- DESeq(dds)
#> estimating size factors
#> estimating dispersions
#> gene-wise dispersion estimates
#> mean-dispersion relationship
#> final dispersion estimates
#> fitting model and testing
vsd <- varianceStabilizingTransformation(dds)
#>
#> Attaching package: 'genefilter'
#> The following objects are masked from 'package:matrixStats':
#>
#>     rowSds, rowVars
#> The following object is masked from 'package:readr':
#>
#>     spec
wpn_vsd <- getVarianceStabilizedData(dds)
rv_wpn <- rowVars(wpn_vsd)
summary(rv_wpn)
#>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
#>  0.00000  0.00000  0.00000  0.08044  0.03322 11.14529

q75_wpn <- quantile( rowVars(wpn_vsd), .75)  # <= original
q95_wpn <- quantile( rowVars(wpn_vsd), .95)  # <= changed to 95 quantile to reduce dataset
expr_normalized <- wpn_vsd[ rv_wpn > q95_wpn, ]

expr_normalized[1:5,1:10]
#>                       B-3      B-4      B-5      L-3      L-4      L-5      S-3
#> AC149818.2_FG001 7.600901 7.077399 7.803434 7.220840 7.410408 8.028223 7.160846
#> AC149829.2_FG003 8.782014 8.179876 7.900062 8.299778 7.529891 8.631731 8.055118
#> AC182617.3_FG001 8.047244 7.120668 6.885533 7.501391 7.279413 7.809565 7.184253
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816 6.633722 7.798843
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427 7.904850 7.484542
#>                       S-4      S-5   B_L1.1
#> AC149818.2_FG001 7.401382 7.345322 6.524435
#> AC149829.2_FG003 8.744502 8.142909 8.240407
#> AC182617.3_FG001 8.140134 6.972400 7.777347
#> AC186512.3_FG001 6.949501 6.952659 6.059033
#> AC186512.3_FG007 8.375664 7.762799 6.335663
dim(expr_normalized)
# This would give us 415 genes - so we use all genes for downstream analysis
expr_normalized_df <- data.frame(expr_normalized) %>%
  mutate(
    Gene_id = row.names(expr_normalized)
  ) %>%
  pivot_longer(-Gene_id)

wpn_vsd.df <- data.frame(wpn_vsd) %>%
  mutate(
    Gene_id = row.names(wpn_vsd)
  ) %>%
  pivot_longer(-Gene_id)

expr_normalized_df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized and 95 quantile Expression",
    x = "treatment",
    y = "normalized expression"
  )

wpn_vsd.df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized Expression",
    x = "treatment",
    y = "normalized expression"
  )

# === Carry out WGCNA

# Use "expr_normalized" for a smaller dataset, but as we have relative few genes, we'll use the full carbon processing dataset 

input_mat = t(wpn_vsd)
dim(input_mat)
input_mat[1:5,1:10]    
#>     AC149818.2_FG001 AC149829.2_FG003 AC182617.3_FG001 AC186512.3_FG001
#> B-3         7.600901         8.782014         8.047244         6.901539
#> B-4         7.077399         8.179876         7.120668         7.389644
#> B-5         7.803434         7.900062         6.885533         6.975945
#> L-3         7.220840         8.299778         7.501391         6.859593
#> L-4         7.410408         7.529891         7.279413         7.370816
#>     AC186512.3_FG007 AC189795.3_FG001 AC190609.3_FG002 AC190623.3_FG001
#> B-3         7.919688         8.149041         12.64301         6.575155
#> B-4         7.754506         8.077571         11.99816         7.170788
#> B-5         7.670946         7.524430         12.12500         7.438024
#> L-3         7.417760         8.420552         12.36979         8.223261
#> L-4         7.988427         7.105196         11.64515         8.008850
#>     AC192451.3_FG001 AC195340.3_FG001
#> B-3         6.700385         9.104258
#> B-4         7.325447         9.135480
#> B-5         7.819142         9.023856
#> L-3         8.052019         8.908933
#> L-4         8.528875         8.583982

#Treatment/samples should be rows, and genes columns
#library(WGCNA)
allowWGCNAThreads()          # allow multi-threading (optional)
#> Allowing multi-threading with up to 4 threads.

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 25, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  input_mat,             # <= Input data
  blockSize = 9000,
  powerVector = powers,
  verbose = 5
  )
#> pickSoftThreshold: will use block size 5486.
#>  pickSoftThreshold: calculating connectivity for given powers...
#>    ..working on genes 1 through 5486 of 5486
#>    Power SFT.R.sq  slope truncated.R.sq mean.k. median.k. max.k.
#> 1      1   0.5350  2.500          0.960  1940.0    1950.0   2840
#> 2      2   0.0642  0.331          0.897   964.0     927.0   1860
#> 3      3   0.1680 -0.444          0.859   560.0     505.0   1340
#> 4      4   0.5050 -0.822          0.906   358.0     300.0   1030
#> 5      5   0.6800 -1.070          0.935   243.0     189.0    819
#> 6      6   0.7770 -1.230          0.954   173.0     125.0    673
#> 7      7   0.8330 -1.310          0.972   127.0      85.3    564
#> 8      8   0.8660 -1.390          0.980    96.4      60.2    484
#> 9      9   0.8810 -1.450          0.981    74.8      43.2    422
#> 10    10   0.8940 -1.490          0.984    59.1      31.7    371
#> 11    12   0.9070 -1.540          0.988    38.7      17.6    295
#> 12    14   0.9150 -1.580          0.988    26.7      10.3    240
#> 13    16   0.9220 -1.570          0.985    19.1       6.3    200
#> 14    18   0.9200 -1.570          0.979    14.1       4.0    169
#> 15    20   0.9240 -1.570          0.982    10.7       2.6    145

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")



dim(input_mat)
#View(input_mat)
picked_power = 10
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
dim(input_mat)
netwk <- blockwiseModules(input_mat,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "unsigned",
                          randomSeed = 2,
                          corType = "pearson",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 50,
                          maxBlockSize = 40000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          #saveTOMs = T,
                          #saveTOMFileBase = "./Network/WGCNA_MG_all",
                          #loadTOM = T,

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
#Calculating module eigengenes block-wise from all genes
#   Flagging genes and samples with too many missing values...
#    ..step 1
#  ..Excluding 11 genes from the calculation due to too many missing samples or zero variance.
#    ..step 2
# ..Working on block 1 .
#    TOM calculation: adjacency..
#    ..will not use multithreading.
#     Fraction of slow calculations: 0.000000
#    ..connectivity..
#    ..matrix multiplication (system BLAS)..
#    ..normalization..
#    ..done.
#   ..saving TOM for block 1 into file ./Network/WGCNA_MG-block.1.RData
# ....clustering..
# ....detecting modules..
# ....calculating module eigengenes..
# ....checking kME in modules..
#     ...removing 4 genes from module 1 because their KME is too low.
#     ..removing 4 genes from module 2 because their KME is too low.
#     ..removing 2 genes from module 3 because their KME is too low.
#     ..removing 3 genes from module 4 because their KME is too low
# ..merging modules that are too close..
#     mergeCloseModules: Merging modules whose distance is less than 0.25
#       Calculating new MEs...

#cor <- stats::cor     # Return cor function to original namespace

#Take a look at the modules
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
unique(mergedColors)

# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )


pdf("F:/Functional_R_analysis/Network/WGCNA_tree_MG_all.pdf", width = 16, height = 8)
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()

#Extract module assignments 
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]
#>            gene_id    colors
#> 1 K23094   grey
#> 2  K03392   blue
#> 3  K05359   grey
#> 4  K00476   grey
#> 5  K00471   grey

write_delim(module_df,
            file = "Network/WGCNA_gene_modules_MG_all.txt",
            delim = "\t")

#How many modules are there
length(unique(module_df$colors))

# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

#Export MEs0 for later downstream analysis
write.csv(MEs0, "F:/Functional_R_analysis/Network/MEs0_MG.csv")

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

WGCNA_sample_MG = mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
WGCNA_sample_MG

pdf("F:/Functional_R_analysis/Network/WGCNA_sample_MG_all.pdf", width = 20, height = 8)
WGCNA_sample_MG
dev.off()


# pick out a few modules of interest here
modules_of_interest = c("green", "turquoise", "tan")

# Pull out list of genes in that module
submod = module_df 

row.names(module_df) = module_df$gene_id

# Get normalized expression for those genes
wpn_vsd[1:5,1:10]

#Subset gene list - expression profiles
subexpr = wpn_vsd[submod$gene_id,]

#Make into a dataframe
submod_df = data.frame(subexpr) %>%
  mutate(
    gene_id = row.names(.)
  ) %>%
  pivot_longer(-gene_id) %>%
  mutate(
    module = module_df[gene_id,]$colors
  )

submod_df %>% ggplot(., aes(x=name, y=value, group=gene_id)) +
  geom_line(aes(color = module),
            alpha = 0.2) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90)
  ) +
  #scale_colour_manual(values = c("black", "blue", "brown", "green", "greenyellow", "grey", "magenta", "pink", "purple", "red", "salmon", "forestgreen", "turquoise", "yellow"))+
  facet_grid(rows = vars(module)) +
  labs(x = "sample",
       y = "normalized expression")




genes_of_interest = module_df

expr_of_interest = wpn_vsd[module_df$gene_id,]
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

genes_of_interest = module_df

expr_of_interest = wpn_vsd[genes_of_interest$gene_id,]
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

# Only recalculate TOM for modules of interest (faster, altho there's some online discussion if this will be slightly off)
TOM = TOMsimilarityFromExpr(t(expr_of_interest),
                            power = picked_power)
#> TOM calculation: adjacency..
#> ..will use 4 parallel threads.
#>  Fraction of slow calculations: 0.000000
#> ..connectivity..
#> ..matrix multiplication (system BLAS)..
#> ..normalization..
#> ..done.

# Add gene names to row and columns
row.names(TOM) = row.names(expr_of_interest)
colnames(TOM) = row.names(expr_of_interest)

dim(data.frame(TOM))

edge_list = data.frame(TOM) %>%
  mutate(
    gene1 = row.names(.)
  ) %>%
  pivot_longer(-gene1) %>%
  dplyr::rename(gene2 = name, correlation = value) %>%
  unique() %>%
  subset(!(gene1==gene2)) %>%
  mutate(
    module1 = module_df[gene1,]$colors,
    module2 = module_df[gene2,]$colors
  )

head(edge_list)
#> # A tibble: 6 x 5
#>   gene1            gene2            correlation module1   module2  
#>   <chr>            <chr>                  <dbl> <chr>     <chr>    
#> 1 AC186512.3_FG001 AC186512.3_FG007      0.0238 turquoise turquoise
#> 2 AC186512.3_FG001 AC190623.3_FG001      0.0719 turquoise turquoise
#> 3 AC186512.3_FG001 AC196475.3_FG004      0.143  turquoise turquoise
#> 4 AC186512.3_FG001 AC196475.3_FG005      0.0117 turquoise turquoise
#> 5 AC186512.3_FG001 AC196489.3_FG002      0.0181 turquoise turquoise
#> 6 AC186512.3_FG001 AC198481.3_FG004      0.0240 turquoise turquoise


adj = TOM[, colnames(TOM) != "samplesums"]
adj = adj[rownames(TOM) != "samplesums", ]
adj[adj > 0.1] = 1
adj[adj != 1] = 0

dim(adj)

network <- igraph::graph_from_adjacency_matrix(adj)
network <- igraph::simplify(network)  # removes self-loops
#results <- netwk
V(network)$color <- netwk$colors #Assign colours to genes for their respective modules

#Plot for sanity checking
par(mar=c(0,0,0,0))
# remove unconnected nodes
network <- delete_vertices(network, degree(network)==0)
multtest::plot(network, layout=layout.fruchterman.reingold(network), edge.arrow.size = 0.2)

#Add extra information to network plot
#E(network$label) <- ifelse(E(network)$weight > 0, '+', '-')
#E(network)$weight_abs <- abs(E(network)$weight)

#Make module tab for Gephi object
V(network)$module =  V(network)$color

#Add extra information to network plot
#V(network)$Function <- All_WGCNA_taxtable[V(network)$name, "Name"]
#V(network)$Direction <- All_WGCNA_taxtable[V(network)$name, "Direction"]
#V(network)$Compound <- All_WGCNA_taxtable[V(network)$name, "Compound"]
#V(network)$Class <- All_WGCNA_taxtable[V(network)$name, "Class"]
#V(network)$label = V(network)$name



# Export Network file to be read into Gephi, Cytoscape, VisANT, etc
write_graph(network, "./Network/WGCNA_all_MG_type.graphml", format = "graphml")

#Export edge file for back up
write_delim(edge_list,
            file = "Network/edgelist_MG_all_type.tsv",
            delim = "\t")


#Make space for other analyses
rm(Geneabund_KO_MG.lng, Final_Geneabund_KO_MG.lng, Geneabund_KO_MG.wde, WGCNA_MG_raw.df, MEs0, network, netwk, test, tmp.out, TOM, adj, edge_list, expr_of_interest, genecat_ps, input_mat, mdata, subexpr, vsd, dds, wpn_vsd.df, wpn_vsd)
gc()
```
##Correlate to environmental data

The Pearson correlation test answers something like the question

When X goes up, does Y also go up? 
When X goes down, does Y also go down?

while the Mantel test answers something like the question

When any two X observations are similar, are the corresponding Y observations also similar? 
When any two X observations are dissimilar, are the corresponding Y observations also dissimilar?
 
```{r}

#Import data if needed
MEs0 = read.csv("E:/Functional_R_analysis/Network/MEs0_MG.csv")

#Run loop for motus vs individual physicochemical parameters
Results_WGCNA_MG.df = data.frame("Data_type" = "Metagenomes",
                                 "Module_name" = "DELETEME",
                                 "PhysicochemicalParameter" = "DELETEME",
                                 "Pearson_corr_value" = 9999,
                                 "pvalue" = 9999)
PP_loop.df = PP_totest.df[-c(1:3),]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric) 

i=1
x=1
for (i in 1:(which(colnames(MEs0) == "treatment")-1)) {
  
  print(paste0("Working on module ", i, " out of ", (which(colnames(MEs0) == "treatment")-1)))
  
  for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    module.name = colnames(MEs0)[i]
    
    #Remove all samples that have NAs for that PP
    PP.tmp <- PP_loop.df[x,] %>%
      as.data.frame() %>%
      dplyr::select_if(~ !any(is.na(.))) %>%
      t()
      #t(as.data.frame(PP_loop.df[x,][,is.na(PP_loop.df[x,])]))
    
    
    #Normalise PP metrics and extract module eigenvalues
    PP.tmp <- PP.tmp %>%
      as.data.frame() %>%
      mutate_at(c(PP.name), ~(scale(.) %>% as.vector))
    module.tmp = MEs0 %>%
      as.data.frame() %>%
      dplyr::select(all_of(module.name))
    
    #Make sure to only include samples/treatments that are present in both PP and microbiome dissimialrity matrices
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(rownames(PP.tmp))))
    module_samples = data.frame(module_sample = sort(as.numeric(rownames(module.tmp))))


    #Compare and put into dataframe
    PP_samples$module_match = match(PP_samples$PP_sample, module_samples$module_sample)
    module_samples$PP_match = match(module_samples$module_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_module_matches = subset(PP_samples, module_match!="NA")


    #Subset distance matrices by matching samples
    module_sub.tmp = module.tmp %>% # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = PP.tmp %>%  # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    #For bug hunting
    #dim(module.tmp)
    #dim(module_sub.tmp)
    #dim(PP.tmp)
    #dim(PP_sub.tmp)
    
    #Run correlation test
    test.tmp = cor.test(PP_sub.tmp[,1], module_sub.tmp[,1], method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "Metagenomes",
                             "Module_name" = module.name,
                             "PhysicochemicalParameter" = PP.name,
                             "Pearson_corr_value" = test.tmp$estimate,
                             "pvalue" = test.tmp$p.value
                             )
    
    #Combine results with previous dataframe
    Results_WGCNA_MG.df = rbind(Results_WGCNA_MG.df, Results.tmp)
    
   # print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  
    } 
  }


#Check results and clean up dataframe
Results_WGCNA_MG.df = Results_WGCNA_MG.df[-1,]
Results_WGCNA_MG.df

#Check if each PP was included
unique(Results_WGCNA_MG.df$PhysicochemicalParameter)



```

#Carry out with metatranscriptome data - all driven by 1-2 samples so excluded from analysis 

```{r}

#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
#sort(unique(amoAMatches.ls$KO))

Geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
  mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  dplyr::select(gene_cluster, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
 dim(Geneabund_KO)


#saveRDS(Geneabund_KO, "F:/Functional_R_analysis/Network/Geneabund_KO_MT.rds")
Geneabund_KO = readRDS("F:/Functional_R_analysis/Network/Geneabund_KO_MT.rds")

Geneabund_KO_MT.lng <- Geneabund_KO %>%
  pivot_longer(!DESCRIPTION, names_to = "sampleid", values_to = "counts", values_drop_na = 0) # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0. 

  
  
##Need to cut dataframe into 120 pieces and run code on it in loop, and then stick it back together
  
Final_Geneabund_KO_MT.lng = as.data.frame(matrix(ncol = 27, nrow = 1))
colnames(Final_Geneabund_KO_MT.lng) = c("sampleid", "counts", "SName", "LName", "KO", "Sample",   "Associatednumber", "DNA_concentration_ng.uL", "Station", "StationNumber", "Sample_type", "Sample_date", "SPM_mgperL", "DOC_mg.L", "TN_mg.L",  "DIC_mg.L", "DOC_uM.L", "DIC_uM.L", "POC_mgperL", "PTC_mgperL", "PTN_mgperL",  "PTH_mgperL", "BioSample", "ERANumber", "ProjectID", "data_type", "station_km")
  
i=1
i=120
for (i in 1:ceiling(dim(Geneabund_KO_MT.lng)[1]/18158)) {
  
  number = i * 18158 
  #number = i * 20
  
  tmp.lng = Geneabund_KO_MT.lng[c((number-18158):number),] 
  #tmp.lng = Geneabund_KO_MT.lng[c((number-20):number),] # Bug hunting
  
  tmp.out = tmp.lng %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information fpr amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Associatednumber > 115) %>% # remove samples that have no metagenome samples
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ungroup() %>%
  distinct()
  
  Final_Geneabund_KO_MT.lng = rbind(Final_Geneabund_KO_MT.lng, tmp.out)
  
  
  if ( i == ceiling(dim(Geneabund_KO_MT.lng)[1]/18158) ) {
    
    end = dim(Geneabund_KO_MT.lng)[1]
    number = ((i-1) * 18158)
    tmp.lng = Geneabund_KO_MT.lng[c(number:end),] 
    
    tmp.out = tmp.lng %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information fpr amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Associatednumber > 115) %>% # remove samples that have no metagenome samples
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ungroup() %>%
  distinct()
  
  Final_Geneabund_KO_MT.lng = rbind(Final_Geneabund_KO_MT.lng, tmp.out)
  
  print(paste0("Finished the last one!"))
  }
  
  print(paste0("Completed ", i, " out of ", round(dim(Geneabund_KO_MT.lng)[1]/18158), " dataframes, which is ", round(i/round(dim(Geneabund_KO_MT.lng)[1]/18158) * 100), "%"))
  
  
}

#Remove unnecesary top row, as it was generated when making the initial df
Final_Geneabund_KO_MT.lng = Final_Geneabund_KO_MT.lng[-1,]

#save in case of crashes (which are inevitable with a df of this size)
saveRDS(Final_Geneabund_KO_MT.lng, "F:/Functional_R_analysis/Network/Geneabund_KO_MT.lng.rds")
#Geneabund_KO_MT.lng = readRDS("D:/Functional_R_analysis/Network/Geneabund_KO_MT.lng.rds") 

Geneabund_KO_MT.lng = Final_Geneabund_KO_MT.lng


#Correct abundance
Geneabund_KO_MT.lng$counts = Geneabund_KO_MT.lng$counts / 1000


#View(Geneabund_KO_MT.lng)
dim(Geneabund_KO_MT.lng)

write.csv(Geneabund_KO_MT.lng, "F:/Functional_R_analysis/OccurrenceFiltered_all_TG.csv")

#Geneabund_KO_MT.lng = read.csv( "D:/Functional_R_analysis/OccurrenceFiltered_all_TG.csv", row.names = 1)

#Reorder factors
Geneabund_KO_MT.lng$Station = factor(Geneabund_KO_MT.lng$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

Geneabund_KO_MT.lng$Sample_date = gsub("-", " ",Geneabund_KO_MT.lng$Sample_date)

Geneabund_KO_MT.lng$Sample_date = factor(Geneabund_KO_MT.lng$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
Geneabund_KO_MT.lng$data_type = gsub("METAG", "Metagenomes", Geneabund_KO_MT.lng$data_type)
Geneabund_KO_MT.lng$data_type = gsub("METAT", "Transcriptomes", Geneabund_KO_MT.lng$data_type)

#Add more info - remove NA's and Infinite numbers
#Geneabund_KO_MT.lng = Geneabund_KO_MT.lng %>%
 # mutate_at(c("counts"), ~replace(., is.na(.), 0)) 

#As we split it into a loop and 120 separate dataframes, we just need to run distinct one more time, but on the end dataframe
Geneabund_KO_MT.lng = Geneabund_KO_MT.lng %>%
  distinct()

#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- tidyr::spread(Geneabund_KO_MT.lng[ , ! names(Geneabund_KO_MT.lng) %in% c("X", "sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(Geneabund_KO_MT.lng)
dim(CO2CH4_TG.df)




#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes


#This is our dataset
CO2CH4_TG.df

Geneabund_KO_MT.wd = CO2CH4_TG.df  %>%
  dplyr::select(Associatednumber, TranscriptsPerGenome, KO) %>%
  filter(TranscriptsPerGenome!="IncompleteMetagenome") %>%
  mutate(TranscriptsPerGenome = as.numeric(TranscriptsPerGenome) + 1) %>%
  tidyr::pivot_wider(names_from = KO, values_from = TranscriptsPerGenome, values_fn = mean) %>%
  as.data.frame() %>%
  filter(Associatednumber!="164") %>%
  tibble::column_to_rownames("Associatednumber")

#Create a new column to calculate what samples have no transcripts per gene counts
Geneabund_KO_MT.wd$samplesums = Geneabund_KO_MT.wd %>%
  rowSums()
#Exclude samples with no meta-transcriptome genes
WGCNA_MT_raw.df = Geneabund_KO_MT.wd %>% 
  tibble::rownames_to_column(var = "rownames") %>%
  filter(samplesums != 0 | is.na(samplesums)) %>% 
  mutate_all(~ replace(., is.na(.), 0)) %>%
  tibble::column_to_rownames(var = "rownames") %>%
  dplyr::select(-samplesums)

WGCNA_MT_raw.df = t(WGCNA_MT_raw.df)

test = WGCNA_MT_raw.df

#Create a new column to calculate what genes have no transcripts per gene counts
test = test %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "rownames") %>%
  mutate(across(-rownames, as.numeric)) 

test$genesums = 
  rowSums(test[,-1])

test = test %>%
  tibble::column_to_rownames(var = "rownames")

#Exclude samples with no metatranscriptome samples
WGCNA_MT_raw.df = test %>% 
  tibble::rownames_to_column(var = "rownames") %>%
  filter(genesums != 0 | is.na(genesums)) %>% 
  mutate_all(~ replace(., is.na(.), 0)) %>%
  tibble::column_to_rownames(var = "rownames") %>%
  dplyr::select(-genesums)


```
## Actual WGCNA for MT
```{r}

set.seed(2)

data = WGCNA_MT_raw.df %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "GeneId")



data[1:5,1:10]        # Look at first 5 rows and 10 columns
dim(data)

names(data)[1] = "GeneId"
names(data)           # Look at the column names


col_sel = names(data)[-1]     # Get all but first column name
mdata <- data %>%
  tidyr::pivot_longer(
    .,                        # The dot is the the input data, magrittr tutorial
    col = all_of(col_sel),
    values_transform = as.numeric
    ) %>%
  left_join(metadata_WGCNA, by = c("name" = "Associatednumber")) %>%
  dplyr::select(GeneId, name, value, Sample_type) %>%
  dplyr::rename(group = Sample_type)

mdata$name = as.character(mdata$name)


# ==== Plot groups (Sample Groups vs RNA Seq Counts) to identify outliers

 p <- mdata %>%
    ggplot(., aes(x = name, y = value)) +             # x = treatment, y = RNA Seq count
    geom_violin() +                                   # violin plot, show distribution
    geom_point(alpha = 0.2) +                         # scatter plot
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)          # Rotate treatment text
    ) +
    labs(x = "Treatment Groups / Samples", y = "Gene Hit Counts") +
    facet_grid(cols = vars(group), drop = TRUE, scales = "free_x")      # Facet by hour
p

pdf("F:/Functional_R_analysis/Network/WGCNA_OutlierHunting_MT_all.pdf", width = 48, height = 10)
p
dev.off()
#No outliers were detected

#Remove outliers
mdata = mdata %>%
  filter(value < 40000)
#Rerun above code to make sure outliers have been removed

#Normalise data with DESeq2
library(DESeq2)
de_input = as.data.frame(data[,-1])
row.names(de_input) = data$GeneId
de_input[1:5,1:10]


meta_df <- data.frame(Sample = names(data[-1])) %>%
  left_join(metadata_WGCNA, by = c("Sample" = "Associatednumber")) %>%
  dplyr::select(Sample, Sample_type) %>%
  dplyr::rename(Type = Sample_type)

dds <- DESeq2::DESeqDataSetFromMatrix(round(de_input),
                              meta_df,
                              design = ~Type)
#> converting counts to integer mode
#> Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#> design formula are characters, converting to factors

dds <- DESeq(dds)
#> estimating size factors
#> estimating dispersions
#> gene-wise dispersion estimates
#> mean-dispersion relationship
#> final dispersion estimates
#> fitting model and testing
vsd <- varianceStabilizingTransformation(dds)
#>
#> Attaching package: 'genefilter'
#> The following objects are masked from 'package:matrixStats':
#>
#>     rowSds, rowVars
#> The following object is masked from 'package:readr':
#>
#>     spec
wpn_vsd <- getVarianceStabilizedData(dds)
rv_wpn <- rowVars(wpn_vsd)
summary(rv_wpn)
#>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
#>  0.00000  0.00000  0.00000  0.08044  0.03322 11.14529

q75_wpn <- quantile( rowVars(wpn_vsd), .75)  # <= original
q95_wpn <- quantile( rowVars(wpn_vsd), .95)  # <= changed to 95 quantile to reduce dataset
expr_normalized <- wpn_vsd[ rv_wpn > q95_wpn, ]

expr_normalized[1:5,1:10]
#>                       B-3      B-4      B-5      L-3      L-4      L-5      S-3
#> AC149818.2_FG001 7.600901 7.077399 7.803434 7.220840 7.410408 8.028223 7.160846
#> AC149829.2_FG003 8.782014 8.179876 7.900062 8.299778 7.529891 8.631731 8.055118
#> AC182617.3_FG001 8.047244 7.120668 6.885533 7.501391 7.279413 7.809565 7.184253
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816 6.633722 7.798843
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427 7.904850 7.484542
#>                       S-4      S-5   B_L1.1
#> AC149818.2_FG001 7.401382 7.345322 6.524435
#> AC149829.2_FG003 8.744502 8.142909 8.240407
#> AC182617.3_FG001 8.140134 6.972400 7.777347
#> AC186512.3_FG001 6.949501 6.952659 6.059033
#> AC186512.3_FG007 8.375664 7.762799 6.335663
dim(expr_normalized)
# This would give us 415 genes - so we use all genes for downstream analysis
expr_normalized_df <- data.frame(expr_normalized) %>%
  mutate(
    Gene_id = row.names(expr_normalized)
  ) %>%
  pivot_longer(-Gene_id)

wpn_vsd.df <- data.frame(wpn_vsd) %>%
  mutate(
    Gene_id = row.names(wpn_vsd)
  ) %>%
  pivot_longer(-Gene_id)

expr_normalized_df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized and 95 quantile Expression",
    x = "treatment",
    y = "normalized expression"
  )

wpn_vsd.df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized Expression",
    x = "treatment",
    y = "normalized expression"
  )

# === Carry out WGCNA

# Use "expr_normalized" for a smaller dataset, but as we have relative few genes, we'll use the full carbon processing dataset 

input_mat = t(wpn_vsd)
dim(input_mat)
input_mat[1:5,1:10]    
#>     AC149818.2_FG001 AC149829.2_FG003 AC182617.3_FG001 AC186512.3_FG001
#> B-3         7.600901         8.782014         8.047244         6.901539
#> B-4         7.077399         8.179876         7.120668         7.389644
#> B-5         7.803434         7.900062         6.885533         6.975945
#> L-3         7.220840         8.299778         7.501391         6.859593
#> L-4         7.410408         7.529891         7.279413         7.370816
#>     AC186512.3_FG007 AC189795.3_FG001 AC190609.3_FG002 AC190623.3_FG001
#> B-3         7.919688         8.149041         12.64301         6.575155
#> B-4         7.754506         8.077571         11.99816         7.170788
#> B-5         7.670946         7.524430         12.12500         7.438024
#> L-3         7.417760         8.420552         12.36979         8.223261
#> L-4         7.988427         7.105196         11.64515         8.008850
#>     AC192451.3_FG001 AC195340.3_FG001
#> B-3         6.700385         9.104258
#> B-4         7.325447         9.135480
#> B-5         7.819142         9.023856
#> L-3         8.052019         8.908933
#> L-4         8.528875         8.583982

#Treatment/samples should be rows, and genes columns
#library(WGCNA)
allowWGCNAThreads()          # allow multi-threading (optional)
#> Allowing multi-threading with up to 4 threads.

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 25, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  input_mat,             # <= Input data
  blockSize = 9000,
  powerVector = powers,
  verbose = 5
  )
#> pickSoftThreshold: will use block size 5486.
#>  pickSoftThreshold: calculating connectivity for given powers...
#>    ..working on genes 1 through 5486 of 5486
#>    Power SFT.R.sq  slope truncated.R.sq mean.k. median.k. max.k.
#> 1      1   0.5350  2.500          0.960  1940.0    1950.0   2840
#> 2      2   0.0642  0.331          0.897   964.0     927.0   1860
#> 3      3   0.1680 -0.444          0.859   560.0     505.0   1340
#> 4      4   0.5050 -0.822          0.906   358.0     300.0   1030
#> 5      5   0.6800 -1.070          0.935   243.0     189.0    819
#> 6      6   0.7770 -1.230          0.954   173.0     125.0    673
#> 7      7   0.8330 -1.310          0.972   127.0      85.3    564
#> 8      8   0.8660 -1.390          0.980    96.4      60.2    484
#> 9      9   0.8810 -1.450          0.981    74.8      43.2    422
#> 10    10   0.8940 -1.490          0.984    59.1      31.7    371
#> 11    12   0.9070 -1.540          0.988    38.7      17.6    295
#> 12    14   0.9150 -1.580          0.988    26.7      10.3    240
#> 13    16   0.9220 -1.570          0.985    19.1       6.3    200
#> 14    18   0.9200 -1.570          0.979    14.1       4.0    169
#> 15    20   0.9240 -1.570          0.982    10.7       2.6    145

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")



dim(input_mat)
#View(input_mat)
picked_power = 5 # Use 5 or 6 depending on result
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
dim(input_mat)
netwk <- blockwiseModules(input_mat,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "unsigned",
                          randomSeed = 2,
                          corType = "pearson",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 50,
                          maxBlockSize = 40000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = T,
                          #saveTOMFileBase = "./Network/WGCNA_MT_all",
                          loadTOM = T,

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
#Calculating module eigengenes block-wise from all genes
#   Flagging genes and samples with too many missing values...
#    ..step 1
#  ..Excluding 11 genes from the calculation due to too many missing samples or zero variance.
#    ..step 2
# ..Working on block 1 .
#    TOM calculation: adjacency..
#    ..will not use multithreading.
#     Fraction of slow calculations: 0.000000
#    ..connectivity..
#    ..matrix multiplication (system BLAS)..
#    ..normalization..
#    ..done.
#   ..saving TOM for block 1 into file ./Network/WGCNA_MT-block.1.RData
# ....clustering..
# ....detecting modules..
# ....calculating module eigengenes..
# ....checking kME in modules..
#     ...removing 4 genes from module 1 because their KME is too low.
#     ..removing 4 genes from module 2 because their KME is too low.
#     ..removing 2 genes from module 3 because their KME is too low.
#     ..removing 3 genes from module 4 because their KME is too low
# ..merging modules that are too close..
#     mergeCloseModules: Merging modules whose distance is less than 0.25
#       Calculating new MEs...

#cor <- stats::cor     # Return cor function to original namespace

#Take a look at the modules
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
unique(mergedColors)

# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )



pdf("D:/Functional_R_analysis/Network/WGCNA_tree_MT_all.pdf", width = 16, height = 8)
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()

#Extract module assignments 
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]
#>            gene_id    colors
#> 1 K23094   grey
#> 2  K03392   blue
#> 3  K05359   grey
#> 4  K00476   grey
#> 5  K00471   grey

write_delim(module_df,
            file = "Network/WGCNA_gene_modules_MT_all.txt",
            delim = "\t")

#How many modules are there
length(unique(module_df$colors))

# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

#export for downstream analysis backup
write.csv(MEs0, "D:/Functional_R_analysis/Network/MEs0_MT.csv")

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

WGCNA_sample_MT = mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
WGCNA_sample_MT

pdf("D:/Functional_R_analysis/Network/FigureS4_MT_SampleModule_WGCNA_sample_MT_all.pdf", width = 20, height = 8)
WGCNA_sample_MT
dev.off()


# pick out a few modules of interest here
modules_of_interest = c("green", "turquoise", "yellow", "brown", "blue")

# Pull out list of genes in that module
submod = module_df 

row.names(module_df) = module_df$gene_id

# Get normalized expression for those genes
wpn_vsd[1:5,1:10]

#Subset gene list - expression profiles
subexpr = wpn_vsd[submod$gene_id,]

#Make into a dataframe
submod_df = data.frame(subexpr) %>%
  mutate(
    gene_id = row.names(.)
  ) %>%
  pivot_longer(-gene_id) %>%
  mutate(
    module = module_df[gene_id,]$colors
  )

submod_df %>% ggplot(., aes(x=name, y=value, group=gene_id)) +
  geom_line(aes(color = module),
            alpha = 0.2) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90)
  ) +
  #scale_colour_manual(values = c("black", "blue", "brown", "green", "greenyellow", "grey", "magenta", "pink", "purple", "red", "salmon", "forestgreen", "turquoise", "yellow"))+
  facet_grid(rows = vars(module)) +
  labs(x = "sample",
       y = "normalized expression")




genes_of_interest = module_df

expr_of_interest = wpn_vsd[module_df$gene_id,]
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

####SHow temporarily ####



genes_of_interest = module_df

expr_of_interest = wpn_vsd[genes_of_interest$gene_id,]
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

# Only recalculate TOM for modules of interest (faster, altho there's some online discussion if this will be slightly off)
TOM = TOMsimilarityFromExpr(t(expr_of_interest),
                            power = picked_power)
#> TOM calculation: adjacency..
#> ..will use 4 parallel threads.
#>  Fraction of slow calculations: 0.000000
#> ..connectivity..
#> ..matrix multiplication (system BLAS)..
#> ..normalization..
#> ..done.

# Add gene names to row and columns
row.names(TOM) = row.names(expr_of_interest)
colnames(TOM) = row.names(expr_of_interest)

dim(data.frame(TOM))

edge_list = data.frame(TOM) %>%
  mutate(
    gene1 = row.names(.)
  ) %>%
  pivot_longer(-gene1) %>%
  dplyr::rename(gene2 = name, correlation = value) %>%
  unique() %>%
  subset(!(gene1==gene2)) %>%
  mutate(
    module1 = module_df[gene1,]$colors,
    module2 = module_df[gene2,]$colors
  )

head(edge_list)
#> # A tibble: 6 x 5
#>   gene1            gene2            correlation module1   module2  
#>   <chr>            <chr>                  <dbl> <chr>     <chr>    
#> 1 AC186512.3_FG001 AC186512.3_FG007      0.0238 turquoise turquoise
#> 2 AC186512.3_FG001 AC190623.3_FG001      0.0719 turquoise turquoise
#> 3 AC186512.3_FG001 AC196475.3_FG004      0.143  turquoise turquoise
#> 4 AC186512.3_FG001 AC196475.3_FG005      0.0117 turquoise turquoise
#> 5 AC186512.3_FG001 AC196489.3_FG002      0.0181 turquoise turquoise
#> 6 AC186512.3_FG001 AC198481.3_FG004      0.0240 turquoise turquoise


adj = TOM[, colnames(TOM) != "samplesums"]
adj = adj[rownames(TOM) != "samplesums", ]
adj[adj > 0.1] = 1
adj[adj != 1] = 0

dim(adj)

network <- igraph::graph_from_adjacency_matrix(adj)
network <- igraph::simplify(network)  # removes self-loops
#results <- netwk
V(network)$color <- netwk$colors #Assign colours to genes for their respective modules


#Plot for sanity checking
par(mar=c(0,0,0,0))
# remove unconnected nodes
network <- delete_vertices(network, degree(network)==0)
multtest::plot(network, layout=layout.fruchterman.reingold(network), edge.arrow.size = 0.2)

#Add extra information to network plot
#E(network$label) <- ifelse(E(network)$weight > 0, '+', '-')
#E(network)$weight_abs <- abs(E(network)$weight)

#Make module tab for Gephi object
V(network)$module =  V(network)$color

#Add extra information to network plot
#V(network)$Function <- All_WGCNA_taxtable[V(network)$name, "Name"]
#V(network)$Direction <- All_WGCNA_taxtable[V(network)$name, "Direction"]
#V(network)$Compound <- All_WGCNA_taxtable[V(network)$name, "Compound"]
#V(network)$Class <- All_WGCNA_taxtable[V(network)$name, "Class"]
#V(network)$label = V(network)$name



# Export Network file to be read into Gephi, Cytoscape, VisANT, etc
write_graph(network, "./Network/WGCNA_all_MT_type.graphml", format = "graphml")

#Export edge file for back up
write_delim(edge_list,
            file = "Network/edgelist_MT_all_type.tsv",
            delim = "\t")


#Make space for other analyses
rm(MEs0, network, netwk, WGCNA_MT_raw.df, test, Final_Geneabund_KO_MT.lng, tmp.out, Geneabund_KO_MT.lng, CO2CH4_TG.df, Geneabund_KO_MT.wd, WGCNA_MT_raw.df, TOM, adj, edge_list, expr_of_interest, genecat_ps, input_mat, mdata, subexpr, vsd, dds, wpn_vsd.df, wpn_vsd)
gc()
```

##Correlate to environmental data

The Pearson correlation test answers something like the question

When X goes up, does Y also go up? 
When X goes down, does Y also go down?

while the Mantel test answers something like the question

When any two X observations are similar, are the corresponding Y observations also similar? 
When any two X observations are dissimilar, are the corresponding Y observations also dissimilar?
 
```{r}
#Import MEs0
MEs0 = read.csv("D:/Functional_R_analysis/Network/MEs0_MT.csv", row.names = 1)

#Run loop for mOTUs vs individual physicochemical parameters
Results_WGCNA_MT.df = data.frame("Data_type" = "TranscriptsPerGene",
                                 "Module_name" = "DELETEME",
                                 "PhysicochemicalParameter" = "DELETEME",
                                 "Pearson_corr_value" = 9999,
                                 "pvalue" = 9999)
PP_loop.df = PP_totest.df[-c(1:3),]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric) 

i=1
x=1
for (i in 1:(which(colnames(MEs0) == "treatment")-1)) {
  
  print(paste0("Working on module ", i, " out of ", (which(colnames(MEs0) == "treatment")-1)))
  
  for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    module.name = colnames(MEs0)[i]
    
    #Remove all samples that have NAs for that PP
    PP.tmp <- PP_loop.df[x,] %>%
      as.data.frame() %>%
      dplyr::select_if(~ !any(is.na(.))) %>%
      t()
      #t(as.data.frame(PP_loop.df[x,][,is.na(PP_loop.df[x,])]))
    
    
    #Normalise PP metrics and extract module eigenvalues
    PP.tmp <- PP.tmp %>%
      as.data.frame() %>%
      mutate_at(c(PP.name), ~(scale(.) %>% as.vector))
    module.tmp = MEs0 %>%
      as.data.frame() %>%
      dplyr::select(all_of(module.name))
    
    #Make sure to only include samples/treatments that are present in both PP and microbiome dissimialrity matrices
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(rownames(PP.tmp))))
    module_samples = data.frame(module_sample = sort(as.numeric(rownames(module.tmp))))


    #Compare and put into dataframe
    PP_samples$module_match = match(PP_samples$PP_sample, module_samples$module_sample)
    module_samples$PP_match = match(module_samples$module_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_module_matches = subset(PP_samples, module_match!="NA")


    #Subset distance matrices by matching samples
    module_sub.tmp = module.tmp %>% # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = PP.tmp %>%  # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    #For bug hunting
    #dim(module.tmp)
    #dim(module_sub.tmp)
    #dim(PP.tmp)
    #dim(PP_sub.tmp)
    
    #Run correlation test
    test.tmp = cor.test(PP_sub.tmp[,1], module_sub.tmp[,1], method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "TranscriptsPerGene",
                             "Module_name" = module.name,
                             "PhysicochemicalParameter" = PP.name,
                             "Pearson_corr_value" = test.tmp$estimate,
                             "pvalue" = test.tmp$p.value
                             )
    
    #Combine results with previous dataframe
    Results_WGCNA_MT.df = rbind(Results_WGCNA_MT.df, Results.tmp)
    
   # print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  
    } 
  }


#Check results and clean up dataframe
Results_WGCNA_MT.df = Results_WGCNA_MT.df[-1,]
Results_WGCNA_MT.df

#Check if each PP was included
unique(Results_WGCNA_MT.df$PhysicochemicalParameter)



```
#Carry out with mOTU data - need data from other computer
##Metagenomes
###Set up microbiome taxa dataframes
```{r}
#Import dataframe
motus_final_taxa_metadata <- readRDS(file="D:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS")

#Set metadata in the correct format
metadata = Physicochem.df

#Exclude outlier results/results that don't fit into the experimental scheme
motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date))


#sCreate a physeq object
motus_table <- motus_final_taxa_metadata %>%
  filter(data_type == "METAG") %>%
  dplyr::select(mOTU, sampleid, counts) %>%
  group_by(sampleid) %>% 
  mutate(total=sum(counts)) %>% 
  filter(total > 2400) %>%  ##Here we just remove those with low counts
  dplyr::select(-total) %>% 
  ungroup() %>% 
  pivot_wider(names_from = sampleid, values_from = counts, values_fill = 0) %>% 
  column_to_rownames("mOTU") %>% 
  phyloseq::otu_table(taxa_are_rows = TRUE)
motus_taxa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  dplyr::select(mOTU, phylum, class, order, family, genus, species) %>% 
  unique() %>% 
  column_to_rownames("mOTU") %>% 
  as.matrix() %>%
  phyloseq::tax_table()
motus_sampledata <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAG") %>%
  dplyr::select(-phylum, -class, -order, -family, -genus, -species, -counts, -mOTU, -domain) %>% 
  unique() %>%  
  column_to_rownames("sampleid") %>% 
  sample_data()
bicest_motu_ps <- phyloseq(motus_table, motus_taxa, motus_sampledata)
bicest_motu_ps
#bicest_motu_ps_v0 = bicest_motu_ps
#bicest_motu_ps = bicest_motu_ps_v0


#Rename samples with the appropriate Associatednumber
#Stupidworkaround.df = read.csv("D:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", sep = ";")

test = motus_sampledata
#i=1
#x=1
#for (i in 1:length(Stupidworkaround.df$BioSample)) {
 # for (x in 1:length(motus_sampledata$BioSample)) {
  #if(grepl(Stupidworkaround.df$BioSample[i], motus_sampledata$BioSample[x]) == T) {
    
   # motus_sampledata$Associatednumber[x] = Stupidworkaround.df$Associatednumber[i]
    
    #print(paste0("Matching ", motus_sampledata$BioSample[x], " with ", Stupidworkaround.df$BioSample[i]))
    
#  }
 # }
#}



#Fix german computer issues that replace periods and commas weirdly
#i=1
#x=59
test$TEP_um2perL = 0
test$CSP_um2perL = 0
test$ParticleArea_um2perL = 0
test$Density_gpercm3 = 0
test$doc_mg_l = 0
test$dic_mg_l = 0
for (i in 1:length(Physicochem.df$Associatednumber)) {
  for (x in 1:length(test$Associatednumber)) {
  if(Physicochem.df$Associatednumber[i] == test$Associatednumber[x]) {
    
    print(paste0("Matching ", test$Associatednumber[x], " with ", Physicochem.df$Associatednumber[i]))
    
    #Update relevant physicochemical parameters as German computers cause weird issues
    test$doc_mg_l[x] = Physicochem.df$DOC_mg.L[i]
    test$dic_mg_l[x] = Physicochem.df$DIC_mg.L[i]
    
    test$ptc_mg_l[x] = Physicochem.df$PTC_mgperL[i]
    test$spm_mg_l[x] = Physicochem.df$SPM_mgperL[i]
    test$poc_mg_l[x] = Physicochem.df$POC_mgperL[i]
    test$Density_gpercm3[x] = Physicochem.df$Density_gpercm3[i]
    
    test$ParticleArea_um2perL[x] = Physicochem.df$ParticleArea_um2perL[i]
    test$TEP_um2perL[x] = Physicochem.df$TEP_um2perL[i]
    test$CSP_um2perL[x] = Physicochem.df$CSP_um2perL[i]
    
  }
  }
}

test$doc_um = NULL
test$dic_um = NULL
    

bicest_motu_ps <- phyloseq(motus_table, motus_taxa, test)
bicest_motu_ps@sam_data


taxa.df <- tax_glom(bicest_motu_ps, taxrank = 'species') %>%#Merge the species at the Phylum level
  transform_sample_counts(function(x) {x/sum(x)} ) %>% #Extract abundance data from phyloseq object
  psmelt() %>%#Melt it into a dataframe
  subset(date!="Nov 21")
  
taxa.df <- taxa.df[order(taxa.df$species),] #Order them at the Species level

taxa.df$species <- as.character(taxa.df$species)
  # group dataframe by Phylum, calculate relative abundance

#Remove na values
taxa.df$Abundance[grep(NaN, taxa.df$Abundance)] = 0

#Remove annoying extras from taxonomic names
taxa.df$phylum = gsub("p__", "", taxa.df$phylum)
taxa.df$class = gsub("c__", "", taxa.df$class)
taxa.df$order = gsub("o__", "", taxa.df$order)
taxa.df$family = gsub("f__", "", taxa.df$family)
taxa.df$genus = gsub("g__", "", taxa.df$genus)
taxa.df$species = gsub("s__", "", taxa.df$species)
taxa.df$species = gsub("s_", "", taxa.df$species)

taxa.df$taxapath = paste0(taxa.df$phylum, "__", taxa.df$class, "__", taxa.df$order, "__", taxa.df$family, "__", taxa.df$genus, "__", taxa.df$species)

Microbiome_wide_mOTU = taxa.df %>%
  dplyr::select(Abundance, Associatednumber, taxapath, OTU) %>%
  mutate(newname = paste0(taxapath, "__", OTU)) %>%
  dplyr::select(Abundance, Associatednumber, newname)

write.csv(Microbiome_wide_mOTU, "D:/Functional_R_analysis/Taxaabund_all_mOTU_lng.csv")

#Long to wide
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
Microbiome_wide_mOTU <- data.frame(spread(Microbiome_wide_mOTU,
                       key = Associatednumber, #Column that will contain new column names
                       value = Abundance)) # Value that will fill new columns

rownames(Microbiome_wide_mOTU) = Microbiome_wide_mOTU$newname
Microbiome_wide_mOTU$newname = NULL

colnames(Microbiome_wide_mOTU) = gsub("X","", colnames(Microbiome_wide_mOTU))


#We need to have samples as columns, and taxa as rows in a wide format.

#Sanity check to make sure all columns add up to 1
colSums(Microbiome_wide_mOTU)

```

## Actual WGCNA for mOTUs
```{r}

set.seed(2)

#Generate function
scale2 <- function(x, na.rm = FALSE) (x * 100 )

data = Microbiome_wide_mOTU %>%
  as.data.frame() %>%
  dplyr::mutate(across(where(is.numeric), scale2)) %>%
  rownames_to_column(var = "mOTUId")



data[1:5,1:10]        # Look at first 5 rows and 10 columns
dim(data)

names(data)[1] = "mOTUId"
names(data)           # Look at the column names


col_sel = names(data)[-1]     # Get all but first column name
mdata <- data %>%
  tidyr::pivot_longer(
    .,                        # The dot is the the input data, magrittr tutorial
    col = all_of(col_sel),
    values_transform = as.numeric
    ) %>%
  left_join(metadata_WGCNA, by = c("name" = "Associatednumber")) %>%
  dplyr::select(mOTUId, name, value, Sample_type) %>%
  dplyr::rename(group = Sample_type)

mdata$name = as.character(mdata$name)

# ==== Plot groups (Sample Groups vs RNA Seq Counts) to identify outliers

 p <- mdata %>%
    ggplot(., aes(x = name, y = value)) +             # x = treatment, y = RNA Seq count
    geom_violin() +                                   # violin plot, show distribution
    geom_point(alpha = 0.2) +                         # scatter plot
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)          # Rotate treatment text
    ) +
    labs(x = "Treatment Groups / Samples", y = "mOTU Abundance (%)") +
    facet_grid(cols = vars(group), drop = TRUE, scales = "free_x")      # Facet by hour
p

pdf("D:/Functional_R_analysis/Network/WGCNA_OutlierHunting_mOTU_all.pdf", width = 48, height = 10)
p
dev.off()
#No outliers were detected

#Remove outliers
#mdata = mdata %>%
 # filter(value < 4000000)
#Rerun above code to make sure outliers have been removed

#Normalise data with DESeq2
library(DESeq2)
de_input = as.data.frame(data[,-1])
row.names(de_input) = data$mOTUId
de_input[1:5,1:10]


meta_df <- data.frame(Sample = names(data[-1])) %>%
  left_join(metadata_WGCNA, by = c("Sample" = "Associatednumber")) %>%
  dplyr::select(Sample, Sample_type) %>%
  dplyr::rename(Type = Sample_type)

dds <- DESeq2::DESeqDataSetFromMatrix(round(de_input),
                              meta_df,
                              design = ~Type)
#> converting counts to integer mode
#> Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#> design formula are characters, converting to factors

dds <- DESeq(dds)
#> estimating size factors
#> estimating dispersions
#> gene-wise dispersion estimates
#> mean-dispersion relationship
#> final dispersion estimates
#> fitting model and testing
vsd <- varianceStabilizingTransformation(dds)
#>
#> Attaching package: 'genefilter'
#> The following objects are masked from 'package:matrixStats':
#>
#>     rowSds, rowVars
#> The following object is masked from 'package:readr':
#>
#>     spec
wpn_vsd <- getVarianceStabilizedData(dds)
rv_wpn <- rowVars(wpn_vsd)
summary(rv_wpn)
#>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
#>  0.00000  0.00000  0.00000  0.08044  0.03322 11.14529

q75_wpn <- quantile( rowVars(wpn_vsd), .75)  # <= original
q95_wpn <- quantile( rowVars(wpn_vsd), .95)  # <= changed to 95 quantile to reduce dataset
expr_normalized <- wpn_vsd[ rv_wpn > q95_wpn, ]

expr_normalized[1:5,1:10]
#>                       B-3      B-4      B-5      L-3      L-4      L-5      S-3
#> AC149818.2_FG001 7.600901 7.077399 7.803434 7.220840 7.410408 8.028223 7.160846
#> AC149829.2_FG003 8.782014 8.179876 7.900062 8.299778 7.529891 8.631731 8.055118
#> AC182617.3_FG001 8.047244 7.120668 6.885533 7.501391 7.279413 7.809565 7.184253
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816 6.633722 7.798843
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427 7.904850 7.484542
#>                       S-4      S-5   B_L1.1
#> AC149818.2_FG001 7.401382 7.345322 6.524435
#> AC149829.2_FG003 8.744502 8.142909 8.240407
#> AC182617.3_FG001 8.140134 6.972400 7.777347
#> AC186512.3_FG001 6.949501 6.952659 6.059033
#> AC186512.3_FG007 8.375664 7.762799 6.335663
dim(expr_normalized)
# This would give us 415 genes - so we use all genes for downstream analysis
expr_normalized_df <- data.frame(expr_normalized) %>%
  mutate(
    Gene_id = row.names(expr_normalized)
  ) %>%
  pivot_longer(-Gene_id)

wpn_vsd.df <- data.frame(wpn_vsd) %>%
  mutate(
    Gene_id = row.names(wpn_vsd)
  ) %>%
  pivot_longer(-Gene_id)

expr_normalized_df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized and 95 quantile Expression",
    x = "treatment",
    y = "normalized expression"
  )

wpn_vsd.df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized Expression",
    x = "treatment",
    y = "normalized expression"
  )

# === Carry out WGCNA

# Use "expr_normalized" for a smaller dataset, but as we have relative few genes, we'll use the full carbon processing dataset 

input_mat = t(wpn_vsd)
dim(input_mat)
input_mat[1:5,1:10]    
#>     AC149818.2_FG001 AC149829.2_FG003 AC182617.3_FG001 AC186512.3_FG001
#> B-3         7.600901         8.782014         8.047244         6.901539
#> B-4         7.077399         8.179876         7.120668         7.389644
#> B-5         7.803434         7.900062         6.885533         6.975945
#> L-3         7.220840         8.299778         7.501391         6.859593
#> L-4         7.410408         7.529891         7.279413         7.370816
#>     AC186512.3_FG007 AC189795.3_FG001 AC190609.3_FG002 AC190623.3_FG001
#> B-3         7.919688         8.149041         12.64301         6.575155
#> B-4         7.754506         8.077571         11.99816         7.170788
#> B-5         7.670946         7.524430         12.12500         7.438024
#> L-3         7.417760         8.420552         12.36979         8.223261
#> L-4         7.988427         7.105196         11.64515         8.008850
#>     AC192451.3_FG001 AC195340.3_FG001
#> B-3         6.700385         9.104258
#> B-4         7.325447         9.135480
#> B-5         7.819142         9.023856
#> L-3         8.052019         8.908933
#> L-4         8.528875         8.583982

#Treatment/samples should be rows, and genes columns
#library(WGCNA)
allowWGCNAThreads()          # allow multi-threading (optional)
#> Allowing multi-threading with up to 4 threads.

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 25, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  input_mat,             # <= Input data
  blockSize = 9000,
  powerVector = powers,
  verbose = 5
  )
#> pickSoftThreshold: will use block size 5486.
#>  pickSoftThreshold: calculating connectivity for given powers...
#>    ..working on genes 1 through 5486 of 5486
#>    Power SFT.R.sq  slope truncated.R.sq mean.k. median.k. max.k.
#> 1      1   0.5350  2.500          0.960  1940.0    1950.0   2840
#> 2      2   0.0642  0.331          0.897   964.0     927.0   1860
#> 3      3   0.1680 -0.444          0.859   560.0     505.0   1340
#> 4      4   0.5050 -0.822          0.906   358.0     300.0   1030
#> 5      5   0.6800 -1.070          0.935   243.0     189.0    819
#> 6      6   0.7770 -1.230          0.954   173.0     125.0    673
#> 7      7   0.8330 -1.310          0.972   127.0      85.3    564
#> 8      8   0.8660 -1.390          0.980    96.4      60.2    484
#> 9      9   0.8810 -1.450          0.981    74.8      43.2    422
#> 10    10   0.8940 -1.490          0.984    59.1      31.7    371
#> 11    12   0.9070 -1.540          0.988    38.7      17.6    295
#> 12    14   0.9150 -1.580          0.988    26.7      10.3    240
#> 13    16   0.9220 -1.570          0.985    19.1       6.3    200
#> 14    18   0.9200 -1.570          0.979    14.1       4.0    169
#> 15    20   0.9240 -1.570          0.982    10.7       2.6    145

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")



dim(input_mat)
#View(input_mat)
picked_power = 7
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
dim(input_mat)
netwk <- blockwiseModules(input_mat,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "unsigned",
                          randomSeed = 2,
                          corType = "pearson",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 15, # This should be 5%
                          maxBlockSize = 40000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          #saveTOMs = T,
                          #saveTOMFileBase = "./Network/WGCNA_MG_all",
                          #loadTOM = T,

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
#Calculating module eigengenes block-wise from all genes
#   Flagging genes and samples with too many missing values...
#    ..step 1
#  ..Excluding 11 genes from the calculation due to too many missing samples or zero variance.
#    ..step 2
# ..Working on block 1 .
#    TOM calculation: adjacency..
#    ..will not use multithreading.
#     Fraction of slow calculations: 0.000000
#    ..connectivity..
#    ..matrix multiplication (system BLAS)..
#    ..normalization..
#    ..done.
#   ..saving TOM for block 1 into file ./Network/WGCNA_MG-block.1.RData
# ....clustering..
# ....detecting modules..
# ....calculating module eigengenes..
# ....checking kME in modules..
#     ...removing 4 genes from module 1 because their KME is too low.
#     ..removing 4 genes from module 2 because their KME is too low.
#     ..removing 2 genes from module 3 because their KME is too low.
#     ..removing 3 genes from module 4 because their KME is too low
# ..merging modules that are too close..
#     mergeCloseModules: Merging modules whose distance is less than 0.25
#       Calculating new MEs...

#cor <- stats::cor     # Return cor function to original namespace

#Take a look at the modules
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
unique(mergedColors)

# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )


pdf("E:/Functional_R_analysis/Network/WGCNA_tree_mOTUs_all.pdf", width = 16, height = 8)
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()

#Extract module assignments 
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]
#>            gene_id    colors
#> 1 K23094   grey
#> 2  K03392   blue
#> 3  K05359   grey
#> 4  K00476   grey
#> 5  K00471   grey

write_delim(module_df,
            file = "D:/Functional_R_analysis/Network/WGCNA_gene_modules_mOTUs_all.txt",
            delim = "\t")

#How many modules are there
length(unique(module_df$colors))

# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

#Export MEs0 for later downstream analysis
write.csv(MEs0, "D:/Functional_R_analysis/Network/MEsO_mOTUs.csv")

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

WGCNA_sample_mOTUs = mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
WGCNA_sample_mOTUs

pdf("E:/Functional_R_analysis/Network/WGCNA_sample_mOTUs_all.pdf", width = 20, height = 8)
WGCNA_sample_mOTUs
dev.off()


# pick out a few modules of interest here
#modules_of_interest = c("green", "turquoise", "tan")

# Pull out list of genes in that module
submod = module_df 

row.names(module_df) = module_df$gene_id

# Get normalized expression for those genes
wpn_vsd[1:5,1:10]

#Subset gene list - expression profiles
subexpr = wpn_vsd

#Make into a dataframe
submod_df = data.frame(subexpr) %>%
  mutate(
    gene_id = row.names(.)
  ) %>%
  pivot_longer(-gene_id) %>%
  mutate(
    module = module_df[gene_id,]$colors
  )

submod_df %>% ggplot(., aes(x=name, y=value, group=gene_id)) +
  geom_line(aes(color = module),
            alpha = 0.2) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90)
  ) +
  #scale_colour_manual(values = c("black", "blue", "brown", "green", "greenyellow", "grey", "magenta", "pink", "purple", "red", "salmon", "forestgreen", "turquoise", "yellow"))+
  facet_grid(rows = vars(module)) +
  labs(x = "sample",
       y = "normalized expression")




genes_of_interest = module_df

expr_of_interest = wpn_vsd
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

genes_of_interest = module_df

expr_of_interest = wpn_vsd
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

# Only recalculate TOM for modules of interest (faster, altho there's some online discussion if this will be slightly off)
TOM = TOMsimilarityFromExpr(t(expr_of_interest),
                            power = picked_power)
#> TOM calculation: adjacency..
#> ..will use 4 parallel threads.
#>  Fraction of slow calculations: 0.000000
#> ..connectivity..
#> ..matrix multiplication (system BLAS)..
#> ..normalization..
#> ..done.

# Add gene names to row and columns
row.names(TOM) = row.names(expr_of_interest)
colnames(TOM) = row.names(expr_of_interest)

dim(data.frame(TOM))

edge_list = data.frame(TOM) %>%
  mutate(
    gene1 = row.names(.)
  ) %>%
  pivot_longer(-gene1) %>%
  dplyr::rename(gene2 = name, correlation = value) %>%
  unique() %>%
  subset(!(gene1==gene2)) %>%
  mutate(
    module1 = module_df[gene1,]$colors,
    module2 = module_df[gene2,]$colors
  )

head(edge_list)
#> # A tibble: 6 x 5
#>   gene1            gene2            correlation module1   module2  
#>   <chr>            <chr>                  <dbl> <chr>     <chr>    
#> 1 AC186512.3_FG001 AC186512.3_FG007      0.0238 turquoise turquoise
#> 2 AC186512.3_FG001 AC190623.3_FG001      0.0719 turquoise turquoise
#> 3 AC186512.3_FG001 AC196475.3_FG004      0.143  turquoise turquoise
#> 4 AC186512.3_FG001 AC196475.3_FG005      0.0117 turquoise turquoise
#> 5 AC186512.3_FG001 AC196489.3_FG002      0.0181 turquoise turquoise
#> 6 AC186512.3_FG001 AC198481.3_FG004      0.0240 turquoise turquoise


adj = TOM[, colnames(TOM) != "samplesums"]
adj = adj[rownames(TOM) != "samplesums", ]
adj[adj > 0.1] = 1
adj[adj != 1] = 0

dim(adj)

network <- igraph::graph_from_adjacency_matrix(adj)
network <- igraph::simplify(network)  # removes self-loops
#results <- netwk
V(network)$color <- netwk$colors #Assign colours to genes for their respective modules

#Plot for sanity checking
par(mar=c(0,0,0,0))
# remove unconnected nodes
network <- delete_vertices(network, degree(network)==0)
multtest::plot(network, layout=layout.fruchterman.reingold(network), edge.arrow.size = 0.2)

#Add extra information to network plot
#E(network$label) <- ifelse(E(network)$weight > 0, '+', '-')
#E(network)$weight_abs <- abs(E(network)$weight)

#Make module tab for Gephi object
V(network)$module =  V(network)$color

#Add extra information to network plot
#V(network)$Function <- All_WGCNA_taxtable[V(network)$name, "Name"]
#V(network)$Direction <- All_WGCNA_taxtable[V(network)$name, "Direction"]
#V(network)$Compound <- All_WGCNA_taxtable[V(network)$name, "Compound"]
#V(network)$Class <- All_WGCNA_taxtable[V(network)$name, "Class"]
V(network)$label = V(network)$name


#Make df with taxa info
networktaxa.df = data.frame(taxa = V(network)$name) %>%
  separate(col = taxa, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID"))

#Add taxonomic info
V(network)$Phylum = networktaxa.df$Phylum
V(network)$Class = networktaxa.df$Class
V(network)$Order = networktaxa.df$Order
V(network)$Family = networktaxa.df$Family
V(network)$Genus = networktaxa.df$Genus
V(network)$Species = networktaxa.df$Species
V(network)$mOTU_ID = networktaxa.df$mOTU_ID

  

# Export Network file to be read into Gephi, Cytoscape, VisANT, etc
write_graph(network, "D:/Functional_R_analysis/Network/WGCNA_all_mOTUs_type.graphml", format = "graphml")

#Export edge file for back up
write_delim(edge_list,
            file = "E:/Functional_R_analysis/Network/edgelist_mOTUs_all_type.tsv",
            delim = "\t")


#Make space for other analyses
rm(Geneabund_KO_mOTUs.lng, Final_Geneabund_KO_mOTUs.lng, Geneabund_KO_mOTUs.wde, WGCNA_mOTUs_raw.df, MEs0, network, netwk, test, tmp.out, TOM, adj, edge_list, expr_of_interest, genecat_ps, input_mat, mdata, subexpr, vsd, dds, wpn_vsd.df, wpn_vsd)
gc()
```
###Correlate to environmental data

The Pearson correlation test answers something like the question

When X goes up, does Y also go up? 
When X goes down, does Y also go down?

while the Mantel test answers something like the question

When any two X observations are similar, are the corresponding Y observations also similar? 
When any two X observations are dissimilar, are the corresponding Y observations also dissimilar?
 
```{r}
#Import dataframe
#Export MEs0 for later downstream analysis
MEs0 = read.csv("D:/Functional_R_analysis/Network/MEsO_mOTUs.csv")
MEs0

#Run loop for motus vs individual physicochemical parameters
Results_WGCNA_mOTUs.df = data.frame("Data_type" = "mOTUs",
                                 "Module_name" = "DELETEME",
                                 "PhysicochemicalParameter" = "DELETEME",
                                 "Pearson_corr_value" = 9999,
                                 "pvalue" = 9999)
PP_loop.df = PP_totest.df[-c(1:3),]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric) 

i=1
x=1
for (i in 1:(which(colnames(MEs0) == "treatment")-1)) {
  
  print(paste0("Working on module ", i, " out of ", (which(colnames(MEs0) == "treatment")-1)))
  
  for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    module.name = colnames(MEs0)[i]
    
    #Remove all samples that have NAs for that PP
    PP.tmp <- PP_loop.df[x,] %>%
      as.data.frame() %>%
      dplyr::select_if(~ !any(is.na(.))) %>%
      t()
      #t(as.data.frame(PP_loop.df[x,][,is.na(PP_loop.df[x,])]))
    
    
    #Normalise PP metrics and extract module eigenvalues
    PP.tmp <- PP.tmp %>%
      as.data.frame() %>%
      mutate_at(c(PP.name), ~(scale(.) %>% as.vector))
    module.tmp = MEs0 %>%
      as.data.frame() %>%
      dplyr::select(all_of(module.name))
    
    #Make sure to only include samples/treatments that are present in both PP and microbiome dissimialrity matrices
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(rownames(PP.tmp))))
    module_samples = data.frame(module_sample = sort(as.numeric(rownames(module.tmp))))


    #Compare and put into dataframe
    PP_samples$module_match = match(PP_samples$PP_sample, module_samples$module_sample)
    module_samples$PP_match = match(module_samples$module_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_module_matches = subset(PP_samples, module_match!="NA")


    #Subset distance matrices by matching samples
    module_sub.tmp = module.tmp %>% # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = PP.tmp %>%  # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    #For bug hunting
    #dim(module.tmp)
    #dim(module_sub.tmp)
    #dim(PP.tmp)
    #dim(PP_sub.tmp)
    
    #Run correlation test
    test.tmp = cor.test(PP_sub.tmp[,1], module_sub.tmp[,1], method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTUs",
                             "Module_name" = module.name,
                             "PhysicochemicalParameter" = PP.name,
                             "Pearson_corr_value" = test.tmp$estimate,
                             "pvalue" = test.tmp$p.value
                             )
    
    #Combine results with previous dataframe
    Results_WGCNA_mOTUs.df = rbind(Results_WGCNA_mOTUs.df, Results.tmp)
    
   # print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  
    } 
  }


#Check results and clean up dataframe
Results_WGCNA_mOTUs.df = Results_WGCNA_mOTUs.df[-1,]
Results_WGCNA_mOTUs.df

#Check if each PP was included
unique(Results_WGCNA_mOTUs.df$PhysicochemicalParameter)



```

###Metatranscriptomes
####Set up microbiome taxa dataframes
```{r}

motus_final_taxa_metadata <- readRDS(file="E:/Functional_R_analysis/motus_final_taxa_metadata_mod.RDS")
metadata = Physicochem.df

##Lets check out experimental scheme
motus_final_taxa_metadata %>% 
  dplyr::select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, date) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##So when we consider fraction and date we see that Nov 21 has few samples, we should consider removing it

motus_final_taxa_metadata %>% 
  dplyr::select(sampleid, data_type, date, station, sample_type) %>% 
  group_by(data_type, sample_type, station) %>% 
  dplyr::summarise(count=n_distinct(sampleid)) %>% 
  print(n=30) 

##By station we see that Kollmar, Seemanshft and BunthausSpitze also were sampled infrequently, lets also remove these. 

motus_final_taxa_metadata <- motus_final_taxa_metadata %>% 
  filter(!grepl("Bunthaus|Kollmar|Seemans", station), !grepl("Nov 21", date))


#so to do a ternary plot we actually need to create a physeq object really quick 
motus_table <- motus_final_taxa_metadata %>%
  filter(data_type == "METAT") %>%
  dplyr::select(mOTU, sampleid, counts) %>%
  group_by(sampleid) %>% 
  mutate(total=sum(counts)) %>% 
  filter(total > 2400) %>%  ##Here we just remove those with low counts
  dplyr::select(-total) %>% 
  ungroup() %>% 
  pivot_wider(names_from = sampleid, values_from = counts, values_fill = 0) %>% 
  column_to_rownames("mOTU") %>% 
  phyloseq::otu_table(taxa_are_rows = TRUE)
motus_taxa <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAT") %>%
  dplyr::select(mOTU, phylum, class, order, family, genus, species) %>% 
  unique() %>% 
  column_to_rownames("mOTU") %>% 
  as.matrix() %>%
  phyloseq::tax_table()
motus_sampledata <- motus_final_taxa_metadata %>% 
  filter(data_type == "METAT") %>%
  dplyr::select(-phylum, -class, -order, -family, -genus, -species, -counts, -mOTU, -domain) %>% 
  unique() %>%  
  column_to_rownames("sampleid") %>% 
  sample_data()
bicest_motu_ps <- phyloseq(motus_table, motus_taxa, motus_sampledata)
bicest_motu_ps
#bicest_motu_ps_v0 = bicest_motu_ps
#bicest_motu_ps = bicest_motu_ps_v0

Stupidworkaround.df = read.csv("E:/Functional_R_analysis/SAMEAID_SampleID_simplified.csv", sep = ";")

test = motus_sampledata
i=1
x=1
for (i in 1:length(Stupidworkaround.df$BioSample)) {
  for (x in 1:length(motus_sampledata$BioSample)) {
  if(grepl(Stupidworkaround.df$BioSample[i], motus_sampledata$BioSample[x]) == T) {
    
    test$Associatednumber[x] = Stupidworkaround.df$Associatednumber[i]
    
    print(paste0("Matching ", motus_sampledata$BioSample[x], " with ", Stupidworkaround.df$BioSample[i]))
    
  }
  }
}



#Fix german computer issues that replace periods and commas weirdly
i=1
x=59
test$TEP_um2perL = 0
test$CSP_um2perL = 0
test$ParticleArea_um2perL = 0
test$Density_gpercm3 = 0
test$doc_mg_l = 0
test$dic_mg_l = 0
for (i in 1:length(Physicochem.df$Associatednumber)) {
  for (x in 1:length(test$Associatednumber)) {
  if(grepl(Physicochem.df$Associatednumber[i], test$Associatednumber[x]) == T) {
    
    print(paste0("Matching ", test$Associatednumber[x], " with ", Physicochem.df$Associatednumber[i]))
    
    #Update relevant physicochemical parameters as German computers cause weird issues
    test$doc_mg_l[x] = Physicochem.df$DOC_mg.L[i]
    test$dic_mg_l[x] = Physicochem.df$DIC_mg.L[i]
    
    test$ptc_mg_l[x] = Physicochem.df$PTC_mgperL[i]
    test$spm_mg_l[x] = Physicochem.df$SPM_mgperL[i]
    test$poc_mg_l[x] = Physicochem.df$POC_mgperL[i]
    test$Density_gpercm3[x] = Physicochem.df$Density_gpercm3[i]
    
    test$ParticleArea_um2perL[x] = Physicochem.df$ParticleArea_um2perL[i]
    test$TEP_um2perL[x] = Physicochem.df$TEP_um2perL[i]
    test$CSP_um2perL[x] = Physicochem.df$CSP_um2perL[i]
    
  }
  }
}

test$doc_um = NULL
test$dic_um = NULL
    

bicest_motu_ps <- phyloseq(motus_table, motus_taxa, test)
bicest_motu_ps@sam_data


taxa.df <- tax_glom(bicest_motu_ps, taxrank = 'species') %>%#Merge the species at the Phylum level
  transform_sample_counts(function(x) {x/sum(x)} ) %>% #Extract abundance data from phyloseq object
  psmelt() %>%#Melt it into a dataframe
  subset(date!="Nov 21")
  
taxa.df <- taxa.df[order(taxa.df$species),] #Order them at the Species level

taxa.df$species <- as.character(taxa.df$species)
  # group dataframe by Phylum, calculate relative abundance

#Remove na values
taxa.df$Abundance[grep(NaN, taxa.df$Abundance)] = 0

#Remove annoying extras from taxonomic names
taxa.df$phylum = gsub("p__", "", taxa.df$phylum)
taxa.df$class = gsub("c__", "", taxa.df$class)
taxa.df$order = gsub("o__", "", taxa.df$order)
taxa.df$family = gsub("f__", "", taxa.df$family)
taxa.df$genus = gsub("g__", "", taxa.df$genus)
taxa.df$species = gsub("s__", "", taxa.df$species)
taxa.df$species = gsub("s_", "", taxa.df$species)

taxa.df$taxapath = paste0(taxa.df$phylum, "__", taxa.df$class, "__", taxa.df$order, "__", taxa.df$family, "__", taxa.df$genus, "__", taxa.df$species)

Microbiome_wide_mOTU = taxa.df %>%
  dplyr::select(Abundance, Associatednumber, taxapath, OTU) %>%
  mutate(newname = paste0(taxapath, "__", OTU)) %>%
  dplyr::select(Abundance, Associatednumber, newname)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
Microbiome_wide_mOTU <- data.frame(spread(Microbiome_wide_mOTU,
                       key = Associatednumber, #Column that will contain new column names
                       value = Abundance)) # Value that will fill new columns

rownames(Microbiome_wide_mOTU) = Microbiome_wide_mOTU$newname
Microbiome_wide_mOTU$newname = NULL

colnames(Microbiome_wide_mOTU) = gsub("X","", colnames(Microbiome_wide_mOTU))


#We need to have samples as columns, and taxa as rows in a wide format.

#Sanity check to make sure all columns add up to 1
colSums(Microbiome_wide_mOTU)

```

#### Actual WGCNA for mOTUs
##### Sample_type
```{r}

set.seed(2)

#Generate function
scale2 <- function(x, na.rm = FALSE) (x * 100 )

data = Microbiome_wide_mOTU %>%
  as.data.frame() %>%
  dplyr::mutate(across(where(is.numeric), scale2)) %>%
  rownames_to_column(var = "mOTUId")



data[1:5,1:5]        # Look at first 5 rows and 10 columns
dim(data)

names(data)[1] = "mOTUId"
names(data)           # Look at the column names


col_sel = names(data)[-1]     # Get all but first column name
mdata <- data %>%
  tidyr::pivot_longer(
    .,                        # The dot is the the input data, magrittr tutorial
    col = all_of(col_sel),
    values_transform = as.numeric
    ) %>%
  left_join(metadata_WGCNA, by = c("name" = "Associatednumber")) %>%
  dplyr::select(mOTUId, name, value, Sample_type) %>%
  dplyr::rename(group = Sample_type)

mdata$name = as.character(mdata$name)

# ==== Plot groups (Sample Groups vs RNA Seq Counts) to identify outliers

 p <- mdata %>%
    ggplot(., aes(x = name, y = value)) +             # x = treatment, y = RNA Seq count
    geom_violin() +                                   # violin plot, show distribution
    geom_point(alpha = 0.2) +                         # scatter plot
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)          # Rotate treatment text
    ) +
    labs(x = "Treatment Groups / Samples", y = "mOTU Abundance (%)") +
    facet_grid(cols = vars(group), drop = TRUE, scales = "free_x")      # Facet by hour
p

pdf("E:/Functional_R_analysis/Network/WGCNA_OutlierHunting_mOTU_all.pdf", width = 48, height = 10)
p
dev.off()
#No outliers were detected

#Remove outliers
#mdata = mdata %>%
 # filter(value < 4000000)
#Rerun above code to make sure outliers have been removed

#Normalise data with DESeq2
library(DESeq2)
de_input = as.data.frame(data[,-1])
row.names(de_input) = data$mOTUId
de_input[1:5,1:6]


meta_df <- data.frame(Sample = names(data[-1])) %>%
  left_join(metadata_WGCNA, by = c("Sample" = "Associatednumber")) %>%
  dplyr::select(Sample, Sample_type) %>%
  dplyr::rename(Type = Sample_type)

dds <- DESeq2::DESeqDataSetFromMatrix(round(de_input),
                              meta_df,
                              design = ~ 1)
#> converting counts to integer mode
#> Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#> design formula are characters, converting to factors

dds <- DESeq(dds)
#> estimating size factors
#> estimating dispersions
#> gene-wise dispersion estimates
#> mean-dispersion relationship
#> final dispersion estimates
#> fitting model and testing
vsd <- varianceStabilizingTransformation(dds)
#>
#> Attaching package: 'genefilter'
#> The following objects are masked from 'package:matrixStats':
#>
#>     rowSds, rowVars
#> The following object is masked from 'package:readr':
#>
#>     spec
wpn_vsd <- getVarianceStabilizedData(dds)
rv_wpn <- rowVars(wpn_vsd)
summary(rv_wpn)
#>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
#>  0.00000  0.00000  0.00000  0.08044  0.03322 11.14529

q75_wpn <- quantile( rowVars(wpn_vsd), .75)  # <= original
q95_wpn <- quantile( rowVars(wpn_vsd), .95)  # <= changed to 95 quantile to reduce dataset
expr_normalized <- wpn_vsd[ rv_wpn > q95_wpn, ]

expr_normalized[1:5,1:7]
#>                       B-3      B-4      B-5      L-3      L-4      L-5      S-3
#> AC149818.2_FG001 7.600901 7.077399 7.803434 7.220840 7.410408 8.028223 7.160846
#> AC149829.2_FG003 8.782014 8.179876 7.900062 8.299778 7.529891 8.631731 8.055118
#> AC182617.3_FG001 8.047244 7.120668 6.885533 7.501391 7.279413 7.809565 7.184253
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816 6.633722 7.798843
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427 7.904850 7.484542
#>                       S-4      S-5   B_L1.1
#> AC149818.2_FG001 7.401382 7.345322 6.524435
#> AC149829.2_FG003 8.744502 8.142909 8.240407
#> AC182617.3_FG001 8.140134 6.972400 7.777347
#> AC186512.3_FG001 6.949501 6.952659 6.059033
#> AC186512.3_FG007 8.375664 7.762799 6.335663
dim(expr_normalized)
# This would give us 415 genes - so we use all genes for downstream analysis
expr_normalized_df <- data.frame(expr_normalized) %>%
  mutate(
    Gene_id = row.names(expr_normalized)
  ) %>%
  pivot_longer(-Gene_id)

wpn_vsd.df <- data.frame(wpn_vsd) %>%
  mutate(
    Gene_id = row.names(wpn_vsd)
  ) %>%
  pivot_longer(-Gene_id)

expr_normalized_df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized and 95 quantile Expression",
    x = "treatment",
    y = "normalized expression"
  )

wpn_vsd.df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized Expression",
    x = "treatment",
    y = "normalized expression"
  )

# === Carry out WGCNA

# Use "expr_normalized" for a smaller dataset, but as we have relative few genes, we'll use the full carbon processing dataset 

input_mat = t(wpn_vsd)
dim(input_mat)
input_mat[1:5,1:10]    
#>     AC149818.2_FG001 AC149829.2_FG003 AC182617.3_FG001 AC186512.3_FG001
#> B-3         7.600901         8.782014         8.047244         6.901539
#> B-4         7.077399         8.179876         7.120668         7.389644
#> B-5         7.803434         7.900062         6.885533         6.975945
#> L-3         7.220840         8.299778         7.501391         6.859593
#> L-4         7.410408         7.529891         7.279413         7.370816
#>     AC186512.3_FG007 AC189795.3_FG001 AC190609.3_FG002 AC190623.3_FG001
#> B-3         7.919688         8.149041         12.64301         6.575155
#> B-4         7.754506         8.077571         11.99816         7.170788
#> B-5         7.670946         7.524430         12.12500         7.438024
#> L-3         7.417760         8.420552         12.36979         8.223261
#> L-4         7.988427         7.105196         11.64515         8.008850
#>     AC192451.3_FG001 AC195340.3_FG001
#> B-3         6.700385         9.104258
#> B-4         7.325447         9.135480
#> B-5         7.819142         9.023856
#> L-3         8.052019         8.908933
#> L-4         8.528875         8.583982

#Treatment/samples should be rows, and genes columns
#library(WGCNA)
allowWGCNAThreads()          # allow multi-threading (optional)
#> Allowing multi-threading with up to 4 threads.

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 25, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  input_mat,             # <= Input data
  blockSize = 9000,
  powerVector = powers,
  verbose = 5
  )
#> pickSoftThreshold: will use block size 5486.
#>  pickSoftThreshold: calculating connectivity for given powers...
#>    ..working on genes 1 through 5486 of 5486
#>    Power SFT.R.sq  slope truncated.R.sq mean.k. median.k. max.k.
#> 1      1   0.5350  2.500          0.960  1940.0    1950.0   2840
#> 2      2   0.0642  0.331          0.897   964.0     927.0   1860
#> 3      3   0.1680 -0.444          0.859   560.0     505.0   1340
#> 4      4   0.5050 -0.822          0.906   358.0     300.0   1030
#> 5      5   0.6800 -1.070          0.935   243.0     189.0    819
#> 6      6   0.7770 -1.230          0.954   173.0     125.0    673
#> 7      7   0.8330 -1.310          0.972   127.0      85.3    564
#> 8      8   0.8660 -1.390          0.980    96.4      60.2    484
#> 9      9   0.8810 -1.450          0.981    74.8      43.2    422
#> 10    10   0.8940 -1.490          0.984    59.1      31.7    371
#> 11    12   0.9070 -1.540          0.988    38.7      17.6    295
#> 12    14   0.9150 -1.580          0.988    26.7      10.3    240
#> 13    16   0.9220 -1.570          0.985    19.1       6.3    200
#> 14    18   0.9200 -1.570          0.979    14.1       4.0    169
#> 15    20   0.9240 -1.570          0.982    10.7       2.6    145

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")



dim(input_mat)
#View(input_mat)
picked_power = 6
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
dim(input_mat)
netwk <- blockwiseModules(input_mat,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "unsigned",
                          randomSeed = 2,
                          corType = "pearson",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 15, # This should be 5%
                          maxBlockSize = 40000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          #saveTOMs = T,
                          #saveTOMFileBase = "./Network/WGCNA_MG_all",
                          #loadTOM = T,

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
#Calculating module eigengenes block-wise from all genes
#   Flagging genes and samples with too many missing values...
#    ..step 1
#  ..Excluding 11 genes from the calculation due to too many missing samples or zero variance.
#    ..step 2
# ..Working on block 1 .
#    TOM calculation: adjacency..
#    ..will not use multithreading.
#     Fraction of slow calculations: 0.000000
#    ..connectivity..
#    ..matrix multiplication (system BLAS)..
#    ..normalization..
#    ..done.
#   ..saving TOM for block 1 into file ./Network/WGCNA_MG-block.1.RData
# ....clustering..
# ....detecting modules..
# ....calculating module eigengenes..
# ....checking kME in modules..
#     ...removing 4 genes from module 1 because their KME is too low.
#     ..removing 4 genes from module 2 because their KME is too low.
#     ..removing 2 genes from module 3 because their KME is too low.
#     ..removing 3 genes from module 4 because their KME is too low
# ..merging modules that are too close..
#     mergeCloseModules: Merging modules whose distance is less than 0.25
#       Calculating new MEs...

#cor <- stats::cor     # Return cor function to original namespace

#Take a look at the modules
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
unique(mergedColors)

# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )


pdf("E:/Functional_R_analysis/Network/WGCNA_tree_mOTUs_all_MT.pdf", width = 16, height = 8)
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()

#Extract module assignments 
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]
#>            gene_id    colors
#> 1 K23094   grey
#> 2  K03392   blue
#> 3  K05359   grey
#> 4  K00476   grey
#> 5  K00471   grey

write_delim(module_df,
            file = "E:/Functional_R_analysis/Network/WGCNA_gene_modules_mOTUs_all_MT.txt",
            delim = "\t")

#How many modules are there
length(unique(module_df$colors))

# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

#Export MEs0 for later downstream analysis
write.csv(MEs0, "E:/Functional_R_analysis/Network/MEsO_mOTUs_MT.csv")

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

WGCNA_sample_mOTUs = mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
WGCNA_sample_mOTUs

pdf("E:/Functional_R_analysis/Network/WGCNA_sample_mOTUs_all_MT.pdf", width = 20, height = 8)
WGCNA_sample_mOTUs
dev.off()


# pick out a few modules of interest here
#modules_of_interest = c("green", "turquoise", "tan")

# Pull out list of genes in that module
submod = module_df 

row.names(module_df) = module_df$gene_id

# Get normalized expression for those genes
wpn_vsd[1:5,1:7]

#Subset gene list - expression profiles
subexpr = wpn_vsd[submod$gene_id,]

#Make into a dataframe
submod_df = data.frame(subexpr) %>%
  mutate(
    gene_id = row.names(.)
  ) %>%
  pivot_longer(-gene_id) %>%
  mutate(
    module = module_df[gene_id,]$colors
  )

submod_df %>% ggplot(., aes(x=name, y=value, group=gene_id)) +
  geom_line(aes(color = module),
            alpha = 0.2) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90)
  ) +
  #scale_colour_manual(values = c("black", "blue", "brown", "green", "greenyellow", "grey", "magenta", "pink", "purple", "red", "salmon", "forestgreen", "turquoise", "yellow"))+
  facet_grid(rows = vars(module)) +
  labs(x = "sample",
       y = "normalized expression")




genes_of_interest = module_df

expr_of_interest = wpn_vsd[module_df$gene_id,]
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

genes_of_interest = module_df

expr_of_interest = wpn_vsd[genes_of_interest$gene_id,]
expr_of_interest[1:5,1:5]
#>                       B-3      B-4      B-5      L-3      L-4
#> AC186512.3_FG001 6.901539 7.389644 6.975945 6.859593 7.370816
#> AC186512.3_FG007 7.919688 7.754506 7.670946 7.417760 7.988427
#> AC190623.3_FG001 6.575155 7.170788 7.438024 8.223261 8.008850
#> AC196475.3_FG004 6.054319 6.439899 6.424540 5.815344 6.565299
#> AC196475.3_FG005 6.194406 5.872273 6.207174 6.499828 6.314952

# Only recalculate TOM for modules of interest (faster, altho there's some online discussion if this will be slightly off)
TOM = TOMsimilarityFromExpr(t(expr_of_interest),
                            power = picked_power)
#> TOM calculation: adjacency..
#> ..will use 4 parallel threads.
#>  Fraction of slow calculations: 0.000000
#> ..connectivity..
#> ..matrix multiplication (system BLAS)..
#> ..normalization..
#> ..done.

# Add gene names to row and columns
row.names(TOM) = row.names(expr_of_interest)
colnames(TOM) = row.names(expr_of_interest)

dim(data.frame(TOM))

edge_list = data.frame(TOM) %>%
  mutate(
    gene1 = row.names(.)
  ) %>%
  pivot_longer(-gene1) %>%
  dplyr::rename(gene2 = name, correlation = value) %>%
  unique() %>%
  subset(!(gene1==gene2)) %>%
  mutate(
    module1 = module_df[gene1,]$colors,
    module2 = module_df[gene2,]$colors
  )

head(edge_list)
#> # A tibble: 6 x 5
#>   gene1            gene2            correlation module1   module2  
#>   <chr>            <chr>                  <dbl> <chr>     <chr>    
#> 1 AC186512.3_FG001 AC186512.3_FG007      0.0238 turquoise turquoise
#> 2 AC186512.3_FG001 AC190623.3_FG001      0.0719 turquoise turquoise
#> 3 AC186512.3_FG001 AC196475.3_FG004      0.143  turquoise turquoise
#> 4 AC186512.3_FG001 AC196475.3_FG005      0.0117 turquoise turquoise
#> 5 AC186512.3_FG001 AC196489.3_FG002      0.0181 turquoise turquoise
#> 6 AC186512.3_FG001 AC198481.3_FG004      0.0240 turquoise turquoise


adj = TOM[, colnames(TOM) != "samplesums"]
adj = adj[rownames(TOM) != "samplesums", ]
adj[adj > 0.1] = 1
adj[adj != 1] = 0

dim(adj)

network <- igraph::graph_from_adjacency_matrix(adj)
network <- igraph::simplify(network)  # removes self-loops
#results <- netwk
V(network)$color <- netwk$colors #Assign colours to genes for their respective modules

#Plot for sanity checking
par(mar=c(0,0,0,0))
# remove unconnected nodes
network <- delete_vertices(network, degree(network)==0)
multtest::plot(network, layout=layout.fruchterman.reingold(network), edge.arrow.size = 0.2)

#Add extra information to network plot
#E(network$label) <- ifelse(E(network)$weight > 0, '+', '-')
#E(network)$weight_abs <- abs(E(network)$weight)

#Make module tab for Gephi object
V(network)$module =  V(network)$color

#Add extra information to network plot
#V(network)$Function <- All_WGCNA_taxtable[V(network)$name, "Name"]
#V(network)$Direction <- All_WGCNA_taxtable[V(network)$name, "Direction"]
#V(network)$Compound <- All_WGCNA_taxtable[V(network)$name, "Compound"]
#V(network)$Class <- All_WGCNA_taxtable[V(network)$name, "Class"]
V(network)$label = V(network)$name


#Make df with taxa info
networktaxa.df = data.frame(taxa = V(network)$name) %>%
  separate(col = taxa, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species"))

#Add taxonomic info
V(network)$Phylum = networktaxa.df$Phylum
V(network)$Class = networktaxa.df$Class
V(network)$Order = networktaxa.df$Order
V(network)$Family = networktaxa.df$Family
V(network)$Genus = networktaxa.df$Genus
V(network)$Species = networktaxa.df$Species

  

# Export Network file to be read into Gephi, Cytoscape, VisANT, etc
write_graph(network, "E:/Functional_R_analysis/Network/WGCNA_all_mOTUs_type_MT.graphml", format = "graphml")

#Export edge file for back up
write_delim(edge_list,
            file = "E:/Functional_R_analysis/Network/edgelist_mOTUs_all_type_MT.tsv",
            delim = "\t")



```
####Correlate to environmental data

The Pearson correlation test answers something like the question

When X goes up, does Y also go up? 
When X goes down, does Y also go down?

while the Mantel test answers something like the question

When any two X observations are similar, are the corresponding Y observations also similar? 
When any two X observations are dissimilar, are the corresponding Y observations also dissimilar?
 
```{r}

MEs0

#Run loop for motus vs individual physicochemical parameters
Results_WGCNA_mOTUs_MT.df = data.frame("Data_type" = "mOTUs_MT",
                                 "Module_name" = "DELETEME",
                                 "PhysicochemicalParameter" = "DELETEME",
                                 "Pearson_corr_value" = 9999,
                                 "pvalue" = 9999)
PP_loop.df = PP_totest.df[-c(1:3),]
PP_loop.df = as.data.frame(PP_loop.df) %>%
   mutate_all(as.numeric) 

i=1
x=1
for (i in 1:(which(colnames(MEs0) == "treatment")-1)) {
  
  print(paste0("Working on module ", i, " out of ", (which(colnames(MEs0) == "treatment")-1)))
  
  for (x in 1:length(rownames(PP_loop.df))) {
    
    #Extracting names
    PP.name = rownames(as.data.frame(PP_loop.df)[x,])
    module.name = colnames(MEs0)[i]
    
    #Remove all samples that have NAs for that PP
    PP.tmp <- PP_loop.df[x,] %>%
      as.data.frame() %>%
      dplyr::select_if(~ !any(is.na(.))) %>%
      t()
      #t(as.data.frame(PP_loop.df[x,][,is.na(PP_loop.df[x,])]))
    
    
    #Normalise PP metrics and extract module eigenvalues
    PP.tmp <- PP.tmp %>%
      as.data.frame() %>%
      mutate_at(c(PP.name), ~(scale(.) %>% as.vector))
    module.tmp = MEs0 %>%
      as.data.frame() %>%
      dplyr::select(all_of(module.name))
    
    #Make sure to only include samples/treatments that are present in both PP and microbiome dissimialrity matrices
    #Extract sample numbers
    PP_samples = data.frame(PP_sample = sort(as.numeric(rownames(PP.tmp))))
    module_samples = data.frame(module_sample = sort(as.numeric(rownames(module.tmp))))


    #Compare and put into dataframe
    PP_samples$module_match = match(PP_samples$PP_sample, module_samples$module_sample)
    module_samples$PP_match = match(module_samples$module_sample, PP_samples$PP_sample)


    #Extract only matching samples
    PP_module_matches = subset(PP_samples, module_match!="NA")


    #Subset distance matrices by matching samples
    module_sub.tmp = module.tmp %>% # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    PP_sub.tmp = PP.tmp %>%  # read in data
      tibble::rownames_to_column("rowsampleid") %>% # convert rownames to a column
      filter(rowsampleid %in% PP_module_matches$PP_sample) %>% # filter for only matching samples
      tibble::column_to_rownames("rowsampleid") # remove new column and replace generic rowname with sampleid
    
    #For bug hunting
    #dim(module.tmp)
    #dim(module_sub.tmp)
    #dim(PP.tmp)
    #dim(PP_sub.tmp)
    
    #Run correlation test
    test.tmp = cor.test(PP_sub.tmp[,1], module_sub.tmp[,1], method = "pearson", permutations = 999, na.rm = TRUE)
    
    #Make df for results
    Results.tmp = data.frame("Data_type" = "mOTUs_MT",
                             "Module_name" = module.name,
                             "PhysicochemicalParameter" = PP.name,
                             "Pearson_corr_value" = test.tmp$estimate,
                             "pvalue" = test.tmp$p.value
                             )
    
    #Combine results with previous dataframe
    Results_WGCNA_mOTUs_MT.df = rbind(Results_WGCNA_mOTUs_MT.df, Results.tmp)
    
   # print(paste0("Completed ", x, " out of ", length(rownames(PP_loop.df)), " physicochemical parameters, which is ", round((x/length(rownames(PP_loop.df)))*100, digits = 2), "%"))
  
    } 
  }


#Check results and clean up dataframe
Results_WGCNA_mOTUs_MT.df = Results_WGCNA_mOTUs_MT.df[-1,]
Results_WGCNA_mOTUs_MT.df

#Check if each PP was included
unique(Results_WGCNA_mOTUs_MT.df$PhysicochemicalParameter)



```

## Plots - Figure 5
```{r}

#Combine dataframes for a single plot
WGCNA_PP.df = rbind(Results_WGCNA_MG.df, Results_WGCNA_MT.df, Results_WGCNA_mOTUs.df)

#Change variable names for nice plots
WGCNA_PP.df$PhysicochemicalParameter = gsub("station_km", "Elbe km", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("Salinity_PSU", "Salinity (PSU)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("Temperature_TBDHereon", "Temperature (C)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("dCO2_uM", "dCO2 (M)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("dCH4_nM", "dCH4 (nM)", WGCNA_PP.df$PhysicochemicalParameter)

WGCNA_PP.df$PhysicochemicalParameter = gsub("O2_uM", "dO2 (M)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("Turbidity_NTU", "Turbidity (NTU)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("PTC_mgperL", "PTC (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("SPM_mgperL", "Dry-weight (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("POC_mgperL", "POC (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("DOC_mg.L", "DOC (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("DIC_mg.L", "DIC (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)

WGCNA_PP.df$PhysicochemicalParameter = gsub("PTN_mgperL", "PTN (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("TN_mg.L", "DTN (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("Ammonium_mg.L", "NH4+ (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("Nitrite_mg.L", "NO2- (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("Nitrate_mg.L", "NO3- (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("Silicate_mg.L", "Si (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("TotalDissolvedPhosphate_mg.L", "DP (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("SRP_mgperL", "SRP (mg L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("TEP_um2perL", "TEP (m2 L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("CSP_um2perL", "CSP (m2 L-1)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("Density_gpercm3", "Density (g cm-3)", WGCNA_PP.df$PhysicochemicalParameter)
WGCNA_PP.df$PhysicochemicalParameter = gsub("ParticleArea_um2perL", "Particle area (um2 L-1)", WGCNA_PP.df$PhysicochemicalParameter)


#Reorder for easy interpretation
WGCNA_PP.df$PhysicochemicalParameter = factor(WGCNA_PP.df$PhysicochemicalParameter, 
                                              levels = c( "Elbe km",
                                                          "Salinity (PSU)",
                                                          "Temperature (C)",
                                                          "Turbidity (NTU)",
                                                          "Dry-weight (mg L-1)",
                                                          "Particle area (um2 L-1)",
                                                          "Density (g cm-3)",
                                                          "PTC (mg L-1)",
                                                          "POC (mg L-1)",
                                                          "DOC (mg L-1)",
                                                          "DIC (mg L-1)",
                                                          "dCO2 (M)",
                                                          "dCH4 (nM)",
                                                          "dO2 (M)",
                                                          "PTN (mg L-1)",
                                                          "DTN (mg L-1)",
                                                          "NH4+ (mg L-1)",
                                                          "NO2- (mg L-1)",
                                                          "NO3- (mg L-1)",
                                                          "pH",
                                                          "DP (mg L-1)",
                                                          "Si (mg L-1)",
                                                          "SRP (mg L-1)",
                                                          "TEP (m2 L-1)",
                                                          "CSP (m2 L-1)",
                                                          "Free_living",
                                                          "Light_fraction",
                                                          "Heavy_fraction",
                                                          "May.21",
                                                          "Jul.21", 
                                                          "Feb.22", 
                                                          "May.22",
                                                          "Jun.22",
                                                          "Nov.22",
                                                          "Muhlenberger.Loch",
                                                          "Twielenfleth",
                                                          "Schwarztonnensand",
                                                          "Brunsbuttel",
                                                          "Meedem.Grund"))
 


WGCNA.plt = ggplot(WGCNA_PP.df, aes(x = PhysicochemicalParameter, y = Module_name, fill = Pearson_corr_value))+
  geom_tile()+
  geom_text(aes(label = ifelse(pvalue > 0.05, "", 
                               ifelse(pvalue > 0.01, "*", 
                                      ifelse(pvalue > 0.001, "**", 
                                             ifelse(pvalue < 0.001, "***", ""))))),
            size = 20 / .pt)+
  scale_fill_gradient2("Pearson Correlation", low = "navy", mid = "white", high = "red", midpoint = 0)+ 
  #scale_x_discrete(
  #  expand = expansion(mult = c(0,0)), guide = guide_axis(angle = 90),
  #  position = "top",
  #  limits = rev
  #)+
  #scale_y_discrete(
  #  expand = expansion(mult = c(0,0)),
  #  position = "right"
  #)+
  xlab("Physicochemical parameters") + 
  ylab("WGCNA calculated module")+
  facet_grid(. ~ Data_type)+
  My_Theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
WGCNA.plt


pdf("E:/Functional_R_analysis/Figures/WGCNA_pearson_all.pdf", width = 30, height = 8)
WGCNA.plt
dev.off()


```
#Get module information for processes
##Metagenomes
```{r}
MG_modules.df = read.csv("E:/Functional_R_analysis/Network/WGCNA_all_MG_nodes.csv") %>%
  dplyr::select(v_name, v_module, X, Y) %>%
  mutate(KO = v_name) 

#Import gene list
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))


MG_modules_info.df = annot %>%
  rownames_to_column("gene_cluster") %>%
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
  mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  left_join(MG_modules.df, by = c("KO" = "KO"), relationship = "many-to-many") %>%
  dplyr::select(DESCRIPTION, KO, v_module, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = "; ", into = c("SName", "LName")) %>% #separate description
  #left_join(metadata) %>% # add metadata
  #filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  #filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  #filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  #ungroup() %>%
  distinct()

colnames(MG_modules_info.df)

WGCNA_modules_Cinfo.df = MG_modules_info.df %>%
  filter(!is.na(v_module)) %>%
  left_join(CarbonGenelist.df, by = c("KO" = "KEGG_Orthology")) %>%
  select(SName, LName, KO, v_module, Compound)

module_total = WGCNA_modules_Cinfo.df %>%
  dplyr::count(v_module) %>%
  arrange(desc(n))
module_total


# Calculate the count and percentage of compounds within each v_module
df_percentages <- WGCNA_modules_Cinfo.df %>%
  group_by(v_module) %>%  # Group by v_module
  count(Compound) %>%      # Count the number of occurrences of each Compound within each v_module
  mutate(percentage = n / sum(n) * 100) %>%  # Calculate the percentage within each v_module
  ungroup()  # Ungroup to prevent affecting subsequent operations
df_percentages

```
##Metatranscriptomes
```{r}
MT_modules.df = read.csv("D:/Functional_R_analysis/Network/WGCNA_all_MT_nodes.csv", sep = ";") %>%
  dplyr::select(v_name, v_module) %>%
  mutate(KO = v_name) 

unique(MT_modules.df$v_module)

#Import gene list
CarbonGenelist.df = read.csv("D:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))


MT_modules_info.df = annot %>%
  rownames_to_column("gene_cluster") %>%
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
  mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  left_join(MT_modules.df, by = c("KO" = "KO"), relationship = "many-to-many") %>%
  dplyr::select(DESCRIPTION, KO, v_module, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = "; ", into = c("SName", "LName")) %>% #separate description
  #left_join(metadata) %>% # add metadata
  #filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  #filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  #filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  #ungroup() %>%
  distinct()

WGCNA_modules_Cinfo.df = MT_modules_info.df %>%
  filter(!is.na(v_module)) %>%
  left_join(CarbonGenelist.df, by = c("KO" = "KEGG_Orthology")) %>%
  dplyr::select(SName, LName, KO, v_module, Compound)

colnames(WGCNA_modules_Cinfo.df)

module_total = WGCNA_modules_Cinfo.df %>%
  dplyr::count(v_module) %>%
  arrange(desc(n))
module_total


# Calculate the count and percentage of compounds within each v_module
df_percentages <- WGCNA_modules_Cinfo.df %>%
  group_by(v_module) %>%  # Group by v_module
  dplyr::count(Compound) %>%      # Count the number of occurrences of each Compound within each v_module
  mutate(percentage = n / sum(n) * 100) %>%  # Calculate the percentage within each v_module
  ungroup()  # Ungroup to prevent affecting subsequent operations
df_percentages

```


#Module abundance across spatiotemporal parameters - 

##mOTUs
###Prep taxa and module ID df
```{r}

#Read in KO and module information (numeric)
mOTUs_mod.df = read.csv("F:/Functional_R_analysis/Network/WGCNA_network_mOTUs_all.csv", sep = ";") %>%
  dplyr::select(v_name, v_module, X, Y)

#MEs0 = read.csv("E:/Functional_R_analysis/Network/MEsO_mOTUs.csv")

#Read in KO and module information (colour)
network_modules_mOTUs.df = read.csv("F:/Functional_R_analysis/Network/edgelist_mOTUs_all_type.tsv", sep = "\t") %>%
  dplyr::select(gene1, module1) %>%
  distinct()

#Combine KO and both module IDs (numeric and colour)
mOTUs_module_taxa.df = network_modules_mOTUs.df %>%
  left_join(mOTUs_mod.df, by = c("gene1" = "v_name")) %>%
  drop_na(v_module) %>%
  distinct() %>%
  dplyr::rename(taxa = gene1) %>%
  dplyr::select(taxa, v_module, module1) 
mOTUs_module_taxa.df


```
###Prep mOTU dataframe
```{r}
#Import df
Microbiome_wide_mOTU  = read.csv("F:/Functional_R_analysis/Taxaabund_all_mOTU_lng.csv", row.names = 1)

metadata = metadata_v0 %>%
  filter(data_type == "METAG") %>%
  mutate(station_km = replace(station_km, station_km == 652, 651))

```

###Combine and plot
```{r}

#Combine dataframes
mOTU_module_ab.df = Microbiome_wide_mOTU %>% #load in df
  left_join(mOTUs_module_taxa.df, by = c("newname" = "taxa")) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  distinct() %>%
  left_join(metadata, by = c("Associatednumber" = "Associatednumber"), relationship = "many-to-one") %>%
  distinct() #sanity check to ensure only one copy of each row is present

#Set up for analysis
mOTU_module_ab.sum = mOTU_module_ab.df %>%
  group_by(module1, station_km, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(Abundance),
                   sd_val = sd(Abundance)) %>%
  filter(station_km < 714 & station_km > 632)

#Set groups manually
mOTU_module_ab.sum$groups = paste0(mOTU_module_ab.sum$station_km, mOTU_module_ab.sum$module1)

#Set station km appropriately
mOTU_module_ab.sum$station_km = factor(mOTU_module_ab.sum$station_km,
                                     levels = c("713",
                                                "692",
                                                "665",
                                                "651",
                                                "633"
                                                ))

#Generate spatial plot
mOTU_km.plt = ggplot(mOTU_module_ab.sum,aes(y = sum_val*100, 
                           x = as.factor(station_km), 
                           #colour = module1,
                           fill = module1,
                           group = groups)) +
  geom_boxplot(lwd = 1) +
  scale_y_log10() +
  facet_grid(. ~ module1)+
  xlab("Elbe km") +
  ylab("Module taxa abundance (%)") +
  #scale_color_identity(guide = "legend") +
  scale_fill_identity(guide = "legend") +
  guides(colour=guide_legend(title="Module")) +
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  #stat_pvalue_manual(subset(results.df, p.adj > 0.05), 
  #                   label = "p.symbol")
  #ggpubr::stat_pwc(method = "wilcox_test",
   #                p.adjust.method = "holm")
mOTU_km.plt




#Set up for analysis

mOTU_module_ab.sum = mOTU_module_ab.df %>%
  group_by(module1, Sample_date, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(Abundance),
                   sd_val = sd(Abundance))

#Set groups manually
mOTU_module_ab.sum$Sample_date = gsub("-", " ",mOTU_module_ab.sum$Sample_date)
mOTU_module_ab.sum$groups = paste0(mOTU_module_ab.sum$Sample_date, mOTU_module_ab.sum$module1)


#Ensure order for dates
mOTU_module_ab.sum$Sample_date = factor(mOTU_module_ab.sum$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Generate spatial plot
mOTU_date.plt = ggplot(mOTU_module_ab.sum,aes(y = sum_val*100, 
                           x = as.factor(Sample_date), 
                           #colour = module1,
                           fill = module1,
                           group = groups)) +
  geom_boxplot(lwd = 1) +
  scale_y_log10() +
  facet_grid(. ~ module1)+
  xlab("Date") +
  ylab("Module taxa abundance (%)") +
  #scale_color_identity(guide = "legend") +
  scale_fill_identity(guide = "legend") +
  guides(colour=guide_legend(title="Module")) +
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  #stat_pvalue_manual(subset(results.df, p.adj > 0.05), 
  #                   label = "p.symbol")
  #ggpubr::stat_pwc(method = "wilcox_test",
   #                p.adjust.method = "holm")
  
mOTU_date.plt


```
##Metagenomes
###Prep KO and module ID df
```{r}
#Read in KO and module information (numeric)
MG_mod.df = read.csv("F:/Functional_R_analysis/Network/WGCNA_network_MG_all.csv", sep = ";") %>%
  dplyr::select(v_name, v_module, X, Y)

#Read in KO and module information (colour)
network_modules_MG.df = read.csv("F:/Functional_R_analysis/Network/edgelist_MG_all_type.tsv", sep = "\t") %>%
  dplyr::select(gene1, module1) %>%
  distinct()

#Combine KO and both module IDs (numeric and colour)
MG_module_KO.df = network_modules_MG.df %>%
  left_join(MG_mod.df, by = c("gene1" = "v_name")) %>%
  drop_na(v_module) %>%
  dplyr::rename(KO = gene1) %>%
  dplyr::select(KO, v_module, module1) %>%
  distinct()
MG_module_KO.df

unique(MG_module_KO.df$module1)

```
###Prep metagenome dataframe
```{r}
#Import precalculated dataframe
#Geneabund_KO_MG.lng = readRDS("F:/Functional_R_analysis/Network/Geneabund_KO_MG.lng.rds") 


#Correct count data
Geneabund_KO_MG.lng$counts = Geneabund_KO_MG.lng$counts / 1000

#View(Geneabund_KO_MG.lng)
dim(Geneabund_KO_MG.lng)

#Reorder factors
Geneabund_KO_MG.lng$Statio = factor(Geneabund_KO_MG.lng$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

Geneabund_KO_MG.lng$Sample_date = gsub("-", " ",Geneabund_KO_MG.lng$Sample_date)

Geneabund_KO_MG.lng$Sample_date = factor(Geneabund_KO_MG.lng$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
Geneabund_KO_MG.lng$data_type = gsub("METAG", "Metagenomes", Geneabund_KO_MG.lng$data_type)

dim(Geneabund_KO_MG.lng)
```
###Combine and plot
```{r}

#Combine dataframes
MG_module_ab.df = Geneabund_KO_MG.lng %>% #load in df
  left_join(MG_module_KO.df) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  distinct() #sanity check to ensure only one copy of each row is present

#Set groups manually
MG_module_ab.df$groups = paste0(MG_module_ab.df$station_km, MG_module_ab.df$module1)

#Run pairwise wilcoxon tests
#results.df = rstatix::pairwise_wilcox_test(MG_module_ab.df, counts ~ groups, p.adjust.method = "bonferroni") %>%
 # rstatix::add_significance(p.col = "p", output.col = "p.symbol") %>% # Adds significance labels  
  #rstatix::add_y_position(fun = "max")  # Ensures y positions are properly set

#Set up for analysis
MG_module_ab.sum = MG_module_ab.df %>%
  group_by(module1, station_km, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(counts),
                   sd_val = sd(counts))

#Set groups manually
MG_module_ab.sum$groups = paste0(MG_module_ab.sum$station_km, MG_module_ab.sum$module1)

#Set station km appropriately
MG_module_ab.sum$station_km = factor(MG_module_ab.sum$station_km,
                                     levels = c("713",
                                                "692",
                                                "665",
                                                "651",
                                                "633"
                                                ))

#Generate spatial plot
MG_km.plt = ggplot(MG_module_ab.sum,aes(y = sum_val, 
                           x = as.factor(station_km), 
                           #colour = module1,
                           fill = module1,
                           group = groups)) +
  geom_boxplot(lwd = 1) +
  scale_y_log10() +
  facet_wrap(. ~ module1, ncol = 8)+
  xlab("Elbe km") +
  ylab("Module gene count \n(per genome)") +
  #scale_color_identity(guide = "legend") +
  scale_fill_identity(guide = "legend") +
  guides(colour=guide_legend(title="Module")) +
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  #stat_pvalue_manual(subset(results.df, p.adj > 0.05), 
  #                   label = "p.symbol")
  #ggpubr::stat_pwc(method = "wilcox_test",
   #                p.adjust.method = "holm")
MG_km.plt




#Set up for analysis
MG_module_ab.sum = MG_module_ab.df %>%
  group_by(module1, Sample_date, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(counts),
                   sd_val = sd(counts))

#Set groups manually
MG_module_ab.sum$groups = paste0(MG_module_ab.sum$Sample_date, MG_module_ab.sum$module1)

#Ensure order for dates
MG_module_ab.sum$Sample_date = factor(MG_module_ab.sum$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Generate spatial plot
MG_date.plt = ggplot(MG_module_ab.sum,aes(y = sum_val, 
                           x = as.factor(Sample_date), 
                           #colour = module1,
                           fill = module1,
                           group = groups)) +
  geom_boxplot(lwd = 1) +
  scale_y_log10() +
  facet_wrap(. ~ module1, ncol = 8)+
  xlab("Date") +
  ylab("Module gene count \n(per genome)") +
  #scale_color_identity(guide = "legend") +
  scale_fill_identity(guide = "legend") +
  guides(colour=guide_legend(title="Module")) +
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  #stat_pvalue_manual(subset(results.df, p.adj > 0.05), 
  #                   label = "p.symbol")
  #ggpubr::stat_pwc(method = "wilcox_test",
   #                p.adjust.method = "holm")
  
MG_date.plt

```


##Metatranscriptomes - don't need as WGCNA failed

###Prep KO and module ID df
```{r}
#Read in KO and module information (numeric)
MT_mod.df = read.csv("F:/Functional_R_analysis/Network/WGCNA_network_MT_all.csv", sep = ";") %>%
  dplyr::select(v_name, v_module, X, Y)

#Read in KO and module information (colour)
network_modules_MT.df = read.csv("F:/Functional_R_analysis/Network/edgelist_MT_all_type.tsv", sep = "\t") %>%
  dplyr::select(gene1, module1) %>%
  distinct()

#Combine KO and both module IDs (numeric and colour)
MT_module_KO.df = network_modules_MT.df %>%
  left_join(MT_mod.df, by = c("gene1" = "v_name")) %>%
  drop_na(v_module) %>%
  dplyr::rename(KO = gene1) %>%
  dplyr::select(KO, v_module, module1) %>%
  distinct()
MT_module_KO.df

```
###Prep metatranscriptome dataframe
```{r}
#Load df
Geneabund_KO_MT.lng = read.csv( "F:/Functional_R_analysis/OccurrenceFiltered_all_TG.csv", row.names = 1)

#Reorder factors
Geneabund_KO_MT.lng$Station = factor(Geneabund_KO_MT.lng$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

Geneabund_KO_MT.lng$Sample_date = gsub("-", " ",Geneabund_KO_MT.lng$Sample_date)

Geneabund_KO_MT.lng$Sample_date = factor(Geneabund_KO_MT.lng$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
Geneabund_KO_MT.lng$data_type = gsub("METAG", "Metagenomes", Geneabund_KO_MT.lng$data_type)
Geneabund_KO_MT.lng$data_type = gsub("METAT", "Transcriptomes", Geneabund_KO_MT.lng$data_type)

#As we split it into a loop and 120 separate dataframes, we just need to run distinct one more time, but on the end dataframe
Geneabund_KO_MT.lng = Geneabund_KO_MT.lng %>%
  distinct()

#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
CO2CH4_TG.df <- tidyr::spread(Geneabund_KO_MT.lng[ , ! names(Geneabund_KO_MT.lng) %in% c("X", "sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(Geneabund_KO_MT.lng)
dim(CO2CH4_TG.df)


#Calculate Transcripts per gene copy
CO2CH4_TG.df$TranscriptsPerGenome = CO2CH4_TG.df$Transcriptomes / CO2CH4_TG.df$Metagenomes


#This is our dataset
CO2CH4_TG.df

```


###Combine and plot
```{r}

#Combine dataframes
MT_module_ab.df = CO2CH4_TG.df %>% #load in df
  left_join(MT_module_KO.df, by = c("KO" = "KO")) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  distinct() #sanity check to ensure only one copy of each row is present

#Set up for analysis
MT_module_ab.sum = MT_module_ab.df %>%
  group_by(module1, station_km, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(TranscriptsPerGenome),
                   sd_val = sd(TranscriptsPerGenome))

#Set groups manually
MT_module_ab.sum$groups = paste0(MT_module_ab.sum$station_km, MT_module_ab.sum$module1)

#Set station km appropriately
MT_module_ab.sum$station_km = factor(MT_module_ab.sum$station_km,
                                     levels = c("713",
                                                "692",
                                                "665",
                                                "651",
                                                "633"
                                                ))

#Generate spatial plot
MT_km.plt = ggplot(MT_module_ab.sum,aes(y = sum_val, 
                           x = as.factor(station_km), 
                           #colour = module1,
                           fill = module1,
                           group = groups)) +
  geom_boxplot(lwd = 1) +
  scale_y_log10() +
  facet_grid(. ~ module1)+
  xlab("Elbe km") +
  ylab("Module transcript count \n(per gene)") +
  #scale_color_identity(guide = "legend") +
  scale_fill_identity(guide = "legend") +
  guides(colour=guide_legend(title="Module")) +
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  #stat_pvalue_manual(subset(results.df, p.adj > 0.05), 
  #                   label = "p.symbol")
  #ggpubr::stat_pwc(method = "wilcox_test",
   #                p.adjust.method = "holm")
MT_km.plt



#Set up for analysis
MT_module_ab.sum = MT_module_ab.df %>%
  group_by(module1, Sample_date, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(TranscriptsPerGenome),
                   sd_val = sd(TranscriptsPerGenome))

#Set groups manually
MT_module_ab.sum$groups = paste0(MT_module_ab.sum$Sample_date, MT_module_ab.sum$module1)

#Ensure order for dates
MT_module_ab.sum$Sample_date = factor(MT_module_ab.sum$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Generate spatial plot
MT_date.plt = ggplot(MT_module_ab.sum,aes(y = sum_val, 
                           x = as.factor(Sample_date), 
                           #colour = module1,
                           fill = module1,
                           group = groups)) +
  geom_boxplot(lwd = 1) +
  scale_y_log10() +
  facet_grid(. ~ module1)+
  xlab("Date") +
  ylab("Module transcript count \n(per gene)") +
  #scale_color_identity(guide = "legend") +
  scale_fill_identity(guide = "legend") +
  guides(colour=guide_legend(title="Module")) +
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  #stat_pvalue_manual(subset(results.df, p.adj > 0.05), 
  #                   label = "p.symbol")
  #ggpubr::stat_pwc(method = "wilcox_test",
   #                p.adjust.method = "holm")
  
MT_date.plt


```


##Combine different plots and export as png and pdf
```{r}

module_abundance.plt = ggpubr::ggarrange(mOTU_km.plt, MG_km.plt, 
                                         mOTU_date.plt, MG_date.plt,
                                         
                                         ncol = 2,
                                         nrow = 2)
module_abundance.plt

png("F:/Functional_R_analysis/Figures/FigureS1_ModuleAbundance.png", units = "in", res = 300, width = 24, height = 12)
module_abundance.plt
dev.off()


pdf("F:/Functional_R_analysis/Figures/FigureS1_ModuleAbundance.pdf", width = 24, height = 12)
module_abundance.plt
dev.off()

```
##Specific modules vs PP
```{r}

require(ggpmisc)
require(SparseM)

```

###Salinity
####mOTUs
```{r}

#Combine dataframes
mOTU_module_ab.df = Microbiome_wide_mOTU %>% #load in df
  left_join(mOTUs_module_taxa.df, by = c("newname" = "taxa")) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  left_join(metadata, by = c("Associatednumber" = "Associatednumber")) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c("Turquoise", "Yellow", "Blue",
                        "Grey"))# extract only the modules we want


#Set up for analysis
mOTU_module_ab.sum = mOTU_module_ab.df %>% # load in data
  group_by(module1, station_km, Associatednumber) %>% # group by relevant columns
  dplyr::summarise(sum_val = sum(Abundance), # calculate the sum
                   sd_val = sd(Abundance)) %>% # calculate standard deviation
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(Salinity_PSU, breaks=c(0, 3, 6, 9, 12, 15, 18, 21))) %>% # bin based on ranges
  dplyr::select(bins, sum_val, module1)

#Make sure the bins column looks nice
mOTU_module_ab.sum$bins = gsub("\\(|\\]", "", mOTU_module_ab.sum$bins)
mOTU_module_ab.sum$bins = gsub(",", "-", mOTU_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
mOTU_sal.plt = ggplot(mOTU_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)), fill = module1)) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x = "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  scale_fill_identity(guide = "legend") +
  xlab("Salinity (PSU)")+
  ylab("Module taxa abundance (%)")+
  scale_x_reverse(breaks = c(1,2,3,4,5),
                   labels = c("1" = "0-3", "2" = "3-6", "3" = "9-12", "4" = "12-15", "5" = "18-21"))+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
mOTU_sal.plt


```
####Metagenomes

```{r}

#Combine dataframes
MG_module_ab.df = Geneabund_KO_MG.lng %>% #load in df
  left_join(MG_module_KO.df) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c("Lilac", "Turquoise", "Pink", "Cyan",
                        "Yellow", "Magenta", "Brown", "Grey"))# extract only the modules we want

#Set up for analysis
MG_module_ab.sum = MG_module_ab.df %>%
  group_by(module1, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(counts),
                   sd_val = sd(counts)) %>%
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(Salinity_PSU, breaks=c(0, 3, 6, 9, 12, 15, 18, 21))) %>% # bin based on ranges
  dplyr::select(bins, sum_val, module1)


#Make sure the bins column looks nice
MG_module_ab.sum$bins = gsub("\\(|\\]", "", MG_module_ab.sum$bins)
MG_module_ab.sum$bins = gsub(",", "-", MG_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
MG_sal.plt = ggplot(MG_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)), fill = module1)) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x = "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  scale_fill_identity(guide = "legend") +
  xlab("Salinity (PSU)")+
  ylab("Module gene counts")+
  scale_x_reverse(breaks = c(1,2,3,4,5),
                   labels = c("1" = "0-3", "2" = "3-6", "3" = "9-12", "4" = "12-15", "5" = "18-21"))+
  scale_y_log10()+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MG_sal.plt


```


###dCO2
####mOTUs
```{r}

#Combine dataframes
mOTU_module_ab.df = Microbiome_wide_mOTU %>% #load in df
  left_join(mOTUs_module_taxa.df, by = c("newname" = "taxa")) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  left_join(metadata, by = c("Associatednumber" = "Associatednumber")) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c("Green", # extract only the modules we want +
                        "Yellow", "Turquoise", "Blue", "Grey"))# extract only the modules we want -

#Set up for analysis
mOTU_module_ab.sum = mOTU_module_ab.df %>% # load in data
  group_by(module1, station_km, Associatednumber) %>% # group by relevant columns
  dplyr::summarise(sum_val = sum(Abundance), # calculate the sum
                   sd_val = sd(Abundance))  %>% # calculate standard deviation
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(dCO2_uM, breaks=c(0, 25, 50, 75, 100, 125, 150))) %>% # bin based on ranges
  dplyr::select(bins, sum_val, module1)

#Make sure the bins column looks nice
mOTU_module_ab.sum$bins = gsub("\\(|\\]", "", mOTU_module_ab.sum$bins)
mOTU_module_ab.sum$bins = gsub(",", "-", mOTU_module_ab.sum$bins)
unique(mOTU_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
mOTU_CO2.plt = ggplot(mOTU_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)), fill = module1)) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x= "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  scale_fill_identity(guide = "legend") +
  xlab("dCO2 (uM)")+
  ylab("Module taxa abundance (%)")+
  scale_x_continuous(breaks = c(1,2,3,4,5),
                   labels = c("1" = "25-50", "2" = "50-75", "3" = "75-100", "4" = "100-125", "5" = "125-150"))+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
mOTU_CO2.plt


```
####Metagenomes

```{r}

#Combine dataframes
MG_module_ab.df = Geneabund_KO_MG.lng %>% #load in df
  left_join(MG_module_KO.df) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c("Tan", "Magenta", # extract only the modules we want +ve
                        "Turquoise", "Cyan")) # extract only the modules we want -ve

#Set up for analysis
MG_module_ab.sum = MG_module_ab.df %>%
  group_by(module1, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(counts),
                   sd_val = sd(counts)) %>%
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(dCO2_uM, breaks=c(0, 25, 50, 75, 100, 125, 150))) %>% # bin based on ranges
  dplyr::select(bins, sum_val, module1)


#Make sure the bins column looks nice
MG_module_ab.sum$bins = gsub("\\(|\\]", "", MG_module_ab.sum$bins)
MG_module_ab.sum$bins = gsub(",", "-", MG_module_ab.sum$bins)
unique(MG_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
MG_CO2.plt = ggplot(MG_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)), fill = module1)) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x = "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  scale_fill_identity(guide = "legend") +
  xlab("dCO2 (uM)")+
  ylab("Module gene counts")+
  scale_x_continuous(breaks = c(1,2,3,4,5),
                   labels = c("1" = "25-50", "2" = "50-75", "3" = "75-100", "4" = "100-125", "5" = "125-150"))+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MG_CO2.plt


```


###dCH4
####mOTUs
```{r}

#Combine dataframes
mOTU_module_ab.df = Microbiome_wide_mOTU %>% #load in df
  left_join(mOTUs_module_taxa.df, by = c("newname" = "taxa")) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  left_join(metadata, by = c("Associatednumber" = "Associatednumber")) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c("Brown" # extract only the modules we want +
                        ))# extract only the modules we want -

#Set up for analysis
mOTU_module_ab.sum = mOTU_module_ab.df %>% # load in data
  group_by(module1, station_km, Associatednumber) %>% # group by relevant columns
  dplyr::summarise(sum_val = sum(Abundance), # calculate the sum
                   sd_val = sd(Abundance))  %>% # calculate standard deviation
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(dCH4_nM, breaks=c(0, 200, 400, 600, 800, 1000, 1200))) %>% # bin based on ranges
  dplyr::select(bins, sum_val, module1)

#Make sure the bins column looks nice
mOTU_module_ab.sum$bins = gsub("\\(|\\]", "", mOTU_module_ab.sum$bins)
mOTU_module_ab.sum$bins = gsub(",", "-", mOTU_module_ab.sum$bins)
unique(mOTU_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
mOTU_CH4.plt = ggplot(mOTU_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)), fill = module1)) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x= "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  scale_fill_identity(guide = "legend") +
  xlab("dCH4 (nM)")+
  ylab("Module taxa abundance (%)")+
  scale_x_continuous(breaks = c(1,2,3,4),
                   labels = c("1" = "0-200", "2" = "200-400", "3" = "800-1000", "4" = "1000-1200"))+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
mOTU_CH4.plt


```
####Metagenomes

```{r}

#Combine dataframes
MG_module_ab.df = Geneabund_KO_MG.lng %>% #load in df
  left_join(MG_module_KO.df) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c("Salmon", "Magenta", # extract only the modules we want +ve
                        "Black")) # extract only the modules we want -ve

#Set up for analysis
MG_module_ab.sum = MG_module_ab.df %>%
  group_by(module1, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(counts),
                   sd_val = sd(counts)) %>%
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(dCH4_nM, breaks=c(0, 200, 400, 600, 800, 1000, 1200))) %>% # bin based on ranges
  dplyr::select(bins, sum_val, module1)


#Make sure the bins column looks nice
MG_module_ab.sum$bins = gsub("\\(|\\]", "", MG_module_ab.sum$bins)
MG_module_ab.sum$bins = gsub(",", "-", MG_module_ab.sum$bins)
unique(MG_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
MG_CH4.plt = ggplot(MG_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)), fill = module1)) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x = "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  scale_fill_identity(guide = "legend") +
  xlab("dCH4 (nM)")+
  ylab("Module gene counts")+
  scale_x_continuous(breaks = c(1,2,3,4),
                   labels = c("1" = "0-200", "2" = "200-400", "3" = "800-1000", "4" = "1000-1200"))+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MG_CH4.plt


```
###DOC
####mOTUs
```{r}

#Combine dataframes
mOTU_module_ab.df = Microbiome_wide_mOTU %>% #load in df
  left_join(mOTUs_module_taxa.df, by = c("newname" = "taxa")) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.character(Associatednumber)) %>%
  left_join(metadata, by = c("Associatednumber" = "Associatednumber")) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c("Brown", # extract only the modules we want +
                        "Yellow"))# extract only the modules we want -

#Set up for analysis
mOTU_module_ab.sum = mOTU_module_ab.df %>% # load in data
  group_by(module1, station_km, Associatednumber) %>% # group by relevant columns
  dplyr::summarise(sum_val = sum(Abundance), # calculate the sum
                   sd_val = sd(Abundance))  %>% # calculate standard deviation
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(DOC_mg.L, breaks=c(0, 2, 4, 6, 8, 10, 12))) %>% # bin based on ranges
  select(bins, sum_val, module1)

#Make sure the bins column looks nice
mOTU_module_ab.sum$bins = gsub("\\(|\\]", "", mOTU_module_ab.sum$bins)
mOTU_module_ab.sum$bins = gsub(",", "-", mOTU_module_ab.sum$bins)
unique(mOTU_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
mOTU_DOC.plt = ggplot(mOTU_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)))) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x= "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  xlab("DOC (mg L-1)")+
  ylab("Module taxa abundance (%)")+
  scale_x_continuous(breaks = c(1,2,3,4,5,6),
                   labels = c("1" = "0-2", "2" = "2-4", "3" = "4-6", "4" = "6-8", "5" = "8-10", "6" = "10-12"))+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
mOTU_DOC.plt


```
####Metagenomes

```{r}

#Combine dataframes
MG_module_ab.df = Geneabund_KO_MG.lng %>% #load in df
  left_join(MG_module_KO.df) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.character(Associatednumber)) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c( # extract only the modules we want +ve
                        "Purple", "Pink", "Green")) # extract only the modules we want -ve

#Set up for analysis
MG_module_ab.sum = MG_module_ab.df %>%
  group_by(module1, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(counts),
                   sd_val = sd(counts)) %>%
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(DOC_mg.L, breaks=c(0, 2, 4, 6, 8, 10, 12))) %>% # bin based on ranges
  select(bins, sum_val, module1)


#Make sure the bins column looks nice
MG_module_ab.sum$bins = gsub("\\(|\\]", "", MG_module_ab.sum$bins)
MG_module_ab.sum$bins = gsub(",", "-", MG_module_ab.sum$bins)
unique(MG_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
MG_DOC.plt = ggplot(MG_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)))) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x = "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  xlab("dCH4 (nM)")+
  ylab("Module gene counts")+
  scale_x_continuous(breaks = c(1,2,3,4,5,6),
                   labels = c("1" = "0-2", "2" = "2-4", "3" = "4-6", "4" = "6-8", "5" = "8-10", "6" = "10-12"))+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MG_DOC.plt


```
###TEP
####mOTUs
```{r}

#Combine dataframes
mOTU_module_ab.df = Microbiome_wide_mOTU %>% #load in df
  left_join(mOTUs_module_taxa.df, by = c("newname" = "taxa")) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.character(Associatednumber)) %>%
  left_join(metadata, by = c("Associatednumber" = "Associatednumber")) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c("Turquoise" # extract only the modules we want +
                        ))# extract only the modules we want -

#Set up for analysis
mOTU_module_ab.sum = mOTU_module_ab.df %>% # load in data
  group_by(module1, station_km, Associatednumber) %>% # group by relevant columns
  dplyr::summarise(sum_val = sum(Abundance), # calculate the sum
                   sd_val = sd(Abundance))  %>% # calculate standard deviation
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(TEP_um2perL, breaks=c(0, 150000000000000, 300000000000000, 450000000000000, 600000000000000, 750000000000000, 900000000000000))) %>% # bin based on ranges
  select(bins, sum_val, module1)

#Make sure the bins column looks nice
mOTU_module_ab.sum$bins = gsub("\\(|\\]", "", mOTU_module_ab.sum$bins)
mOTU_module_ab.sum$bins = gsub(",", "-", mOTU_module_ab.sum$bins)
unique(mOTU_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
mOTU_TEP.plt = ggplot(mOTU_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)))) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x= "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  xlab("TEP concentration (um2 L-1)")+
  ylab("Module taxa abundance (%)")+
  scale_x_continuous(breaks = c(1,2,3,4,5,6),
                   labels = c("1" = "0-1.5e+14", 
                              "2" = "1.5e+14-3e+14", 
                              "3" = "3e+14-4.5e+14", 
                              "4" = "4.5e+14-6e+14", 
                              "5" = "6e+14-7.5e+14", 
                              "6" = "7.5e+14-9e+14"))+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
mOTU_TEP.plt


```
####Metagenomes

```{r}

#Combine dataframes
MG_module_ab.df = Geneabund_KO_MG.lng %>% #load in df
  left_join(MG_module_KO.df) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.character(Associatednumber)) %>%
  distinct() %>% #sanity check to ensure only one copy of each row is present
  filter(module1 %in% c("Pink", # extract only the modules we want +ve
                        "Red", "Cyan")) # extract only the modules we want -ve

#Set up for analysis
MG_module_ab.sum = MG_module_ab.df %>%
  group_by(module1, Associatednumber) %>%
  dplyr::summarise(sum_val = sum(counts),
                   sd_val = sd(counts)) %>%
  ungroup() %>% # remove the grouping it calculates everything with
  left_join(metadata) %>% # %>% # add salinity and other metadata back
  mutate(bins = cut(TEP_um2perL, breaks=c(0, 150000000000000, 300000000000000, 450000000000000, 600000000000000, 750000000000000, 900000000000000))) %>% # bin based on ranges
  select(bins, sum_val, module1)


#Make sure the bins column looks nice
MG_module_ab.sum$bins = gsub("\\(|\\]", "", MG_module_ab.sum$bins)
MG_module_ab.sum$bins = gsub(",", "-", MG_module_ab.sum$bins)
unique(MG_module_ab.sum$bins)

#Plot against salinity - might need to sum like before
MG_TEP.plt = ggplot(MG_module_ab.sum, aes(y = sum_val * 100, x = as.integer(factor(bins)))) +
  geom_boxplot(aes(group = factor(bins)))+
  ggpmisc::stat_poly_line() + # add line of best fit to data
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2")), label.x = "right") + # add line of best fit metrics to plot
  #stat_summary(geom = "line", fun = mean, group = 1) +
  facet_grid(. ~ module1) + # separate by the modules
  xlab("TEP concentration (um2 L-1)")+
  ylab("Module gene counts")+
  scale_x_continuous(breaks = c(1,2,3,4,5,6),
                   labels = c("1" = "0-1.5e+14", 
                              "2" = "1.5e+14-3e+14", 
                              "3" = "3e+14-4.5e+14", 
                              "4" = "4.5e+14-6e+14", 
                              "5" = "6e+14-7.5e+14", 
                              "6" = "7.5e+14-9e+14"))+
  My_Theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
MG_TEP.plt


```
###Combine mOTU and metagenome to PP plots and export
```{r}

Modules2PP.plt = ggpubr::ggarrange(mOTU_sal.plt, MG_sal.plt,
                                   mOTU_CO2.plt, MG_CO2.plt,
                                   mOTU_CH4.plt, MG_CH4.plt,
                                   #mOTU_DOC.plt, MG_DOC.plt,
                                   #mOTU_TEP.plt, MG_TEP.plt,
                                   ncol = 2,
                                   nrow = 3)
Modules2PP.plt

png("F:/Functional_R_analysis/Figures/FigureS1_modules2PP.png", units = "in", res = 120, width = 24, height = 12)
Modules2PP.plt
dev.off()

pdf("F:/Functional_R_analysis/Figures/FigureS1_modules2PP.pdf",width = 24, height = 12)
Modules2PP.plt
dev.off()


```

#Match mOTUs to MAGs and get functional info - sal corr. to osmoreg % in here - Figure 5 associated
##Set up dataframes and module level osmoregulation gene calculation
Jurdzinski et al, 2023; 10.1126/sciadv.adg2059
brackish vs marine - no mechanism , "K07064", "K06987", "
```{r}
#Brackish:
BrackishJurdzinskiOsmoList.ls = c("K03498", "K03499", "K07301", "K16055", "K08974", #brackish vs fresh - brackish identified
                                  #"K01480", "K04759", "K00809", "K01585", "K03782", "K21498", "K19159", "K05844", "K18310", "K14940", "K03284", "K03282", "K02237", "K03321", "K02036", "K01673", "K07007", "K07290", "K07115", "K02482", "K07343", "K03630", "K03413", "K20974", "K07497", "K02238", "K07460", "K07391", # brackish vs marine - brackish identified
                                  "K08974", "K03499", "K07301", "K16052", "" #freshwater vs marine - marine identified
                                  )


#Import mOTU ID lists that lets us link them to MAGs, and combine them
mag_nmOTUs.df = read.csv("F:/Functional_R_analysis/mag_2_new_motus", header = F, sep = "\t") %>%
  separate_rows(V2, sep = ";") %>%
  dplyr::rename(mOTU_ID = V1) %>%
  dplyr::rename(MAG_ID = V2)

mag_emOTUs.df = read.csv("F:/Functional_R_analysis/mag_2_existing_motus", header = F, sep = "\t") %>%
  separate_rows(V2, sep = ";") %>%
  dplyr::select(V1, V2) %>%
  dplyr::rename(mOTU_ID = V2) %>%
  dplyr::rename(MAG_ID = V1)

mOTUs2MAGs = rbind(mag_nmOTUs.df, mag_emOTUs.df) %>%
  filter(mOTU_ID!="NotEnoughMGs")


#Import module information and combine (number and colour)
mOTUs_mod.df = read.csv("F:/Functional_R_analysis/Network/WGCNA_network_mOTUs_all.csv", sep = ";") %>%
  dplyr::select(v_name, v_module, X, Y, v_motu_id) %>%
  dplyr::rename(mOTU_ID = v_motu_id) %>%
  dplyr::rename(taxa = v_name)

#Import list of mOTUs and their respective module colour
network_modules_mOTUs.df = read.csv("F:/Functional_R_analysis/Network/edgelist_mOTUs_all_type.tsv", sep = "\t") %>%
  dplyr::select(gene1, module1) %>%
  distinct()


#Modify the annotation df, to make linking it clearer downstream
annot_mod = annot %>%
  rownames_to_column("gene_cluster")


#Combine both module lists
mOTUs_module_KO.df = network_modules_mOTUs.df %>%
  left_join(mOTUs_mod.df, by = c("gene1" = "taxa")) %>%
  drop_na(v_module) %>% # remove taxa that haven't been assigned a module
  distinct() %>% # Remove duplicates
  dplyr::rename(taxa = gene1) %>% #Rename taxa for consistency
  dplyr::select(taxa, v_module, module1) %>% # choose only the columns that we need
  separate(col = taxa, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID")) %>% # separate the taxa information and establish the mOTU ID column needed downstream
  left_join(mOTUs2MAGs, by = c("mOTU_ID" = "mOTU_ID")) %>%
  left_join(gene_cluster_taxa, by = c("MAG_ID" = "genome")) %>%
  dplyr::select(-gene) %>%
  distinct() %>%
  left_join(annot_mod, by = c("gene_cluster" = "gene_cluster")) %>%
  filter(KO != is.na(KO)) # filter to remova all NA
  
mOTUs_module_KO.df


#How many mOTUs matched MAGs? - all, as they are MAG derived
matched_modulmOTUMAG.df = network_modules_mOTUs.df %>%
  left_join(mOTUs_mod.df, by = c("gene1" = "taxa")) %>%
  drop_na(v_module) %>% # remove taxa that haven't been assigned a module
  distinct() %>% # Remove duplicates
  dplyr::rename(taxa = gene1) %>% #Rename taxa for consistency
  dplyr::select(taxa, v_module, module1) %>% # choose only the columns that we need
  separate(col = taxa, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID")) %>% # separate the taxa information and establish the mOTU ID column needed downstream
  left_join(mOTUs2MAGs, by = c("mOTU_ID" = "mOTU_ID")) %>%
  left_join(gene_cluster_taxa, by = c("MAG_ID" = "genome")) %>%
  dplyr::select(-gene) %>%
  distinct() %>%
  dplyr::select(module1, mOTU_ID) %>%
  distinct() %>%
  group_by(module1) %>%
  summarise(totalmatches = n())
matched_modulmOTUMAG.df

dim(matched_modulmOTUMAG.df)


#Identify methanogenesis
#mcrA - generates methane
#pmoA + mmoX - utilises methane

methanemetabolism_genes.df = mOTUs_module_KO.df %>%
  filter(str_detect(DESCRIPTION, "mmoX") | 
           str_detect(DESCRIPTION, "mcrA") | 
           str_detect(DESCRIPTION, "pmoA")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, Phylum, Class, Order, Family, Genus, Species) %>%
  distinct()

dim(methanemetabolism_genes.df)


#Identify osmosis genes

Osmotic_genes.df = mOTUs_module_KO.df %>%
  filter(str_detect(DESCRIPTION, "osmo") | KO %in% BrackishJurdzinskiOsmoList.ls) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, Phylum, Class, Order, Family, Genus, Species) %>%
  distinct()

dim(Osmotic_genes.df)

#write.csv(Osmotic_genes.df, "E:/Functional_R_analysis/Osmoregulationgenes.csv")


#Identify pufM

AAP_genes.df = mOTUs_module_KO.df %>%
  filter(str_detect(KO, "K08929")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, Phylum, Class, Order, Family, Genus, Species) %>%
  distinct()

dim(AAP_genes.df)


#To calculate how many taxa in each module contain a osmoregulation gene
Osmotic_genes.df = mOTUs_module_KO.df %>%
  filter(str_detect(DESCRIPTION, "osmo") | KO %in% BrackishJurdzinskiOsmoList.ls) %>%
  dplyr::select(v_module, module1, Phylum, Class, Order, Family, Genus, Species, mOTU_ID) %>%
  distinct() %>%
  group_by(module1) %>%
  summarise(Osmoreg_numbers = n()) %>%
  left_join(matched_modulmOTUMAG.df) %>%
  mutate(PercentageOsmoTaxa = (Osmoreg_numbers / totalmatches)*100)

Osmotic_genes.df

#To calculate how many taxa in each module contain pufM
AAP_genes.df = mOTUs_module_KO.df %>%
  filter(str_detect(KO, "K08929")) %>%
  dplyr::select(v_module, module1, Phylum, Class, Order, Family, Genus, Species, mOTU_ID) %>%
  distinct() %>%
  group_by(module1) %>%
  summarise(AAPreg_numbers = n()) %>%
  left_join(matched_modulmOTUMAG.df) %>%
  mutate(PercentageAAPTaxa = (AAPreg_numbers / totalmatches)*100)
AAP_genes.df

#For later checking
mOTUMAGmatches.df = network_modules_mOTUs.df %>%
  left_join(mOTUs_mod.df, by = c("gene1" = "taxa")) %>%
  drop_na(v_module) %>% # remove taxa that haven't been assigned a module
  distinct() %>% # Remove duplicates
  dplyr::rename(taxa = gene1) %>% #Rename taxa for consistency
  dplyr::select(taxa, module1) %>% # choose only the columns that we need
  separate(col = taxa, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID")) %>% # separate the taxa information and establish the mOTU ID column needed downstream
  left_join(mOTUs2MAGs, by = c("mOTU_ID" = "mOTU_ID"))
mOTUMAGmatches.df

```

##Identify what mOTUs are in each module + osmoregulation % + methanotroph ab.
Use indicator species analysis for this. Should make it quicker/easier.

```{r}

#Read in KO and module information (numeric)
mOTUs_mod.df = read.csv("D:/Functional_R_analysis/Network/WGCNA_network_mOTUs_all.csv", sep = ";") %>%
  dplyr::select(v_name, v_module, X, Y)

#MEs0 = read.csv("E:/Functional_R_analysis/Network/MEsO_mOTUs.csv")

#Read in KO and module information (colour)
network_modules_mOTUs.df = read.csv("D:/Functional_R_analysis/Network/edgelist_mOTUs_all_type.tsv", sep = "\t") %>%
  dplyr::select(gene1, module1) %>%
  distinct()

#Combine KO and both module IDs (numeric and colour)
mOTUs_module_taxa.df = network_modules_mOTUs.df %>%
  left_join(mOTUs_mod.df, by = c("gene1" = "v_name")) %>%
  drop_na(v_module) %>%
  distinct() %>%
  dplyr::rename(taxa = gene1) %>%
  dplyr::select(taxa, v_module, module1) 
mOTUs_module_taxa.df



#Import df to prep mOTU dataframe
Microbiome_wide_mOTU  = read.csv("D:/Functional_R_analysis/Taxaabund_all_mOTU_lng.csv", row.names = 1)



#Combine dataframes
mOTU_module_ab.df = Microbiome_wide_mOTU %>% #load in df
  left_join(mOTUs_module_taxa.df, by = c("newname" = "taxa")) %>% # combine with module information
  drop_na(module1) %>% #remove genes that were not part of a module
  mutate(module1 = stringr::str_to_title(module1)) %>% #Capitalise all module names
  mutate(Associatednumber = as.numeric(Associatednumber)) %>%
  left_join(filter(metadata, data_type=="METAG"), by = c("Associatednumber" = "Associatednumber"), relationship = "many-to-one") %>%
  distinct() #sanity check to ensure only one copy of each row is present
mOTU_module_ab.df

```


###Identify taxa in the grey mOTU module
```{r}

#Extract grey module taxa
mOTU_grey.ls = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Grey") %>% #filter to only a specific module
  select(newname) %>% # choose only the informative column
  separate(newname, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "MAGID")) %>% #separate the taxa column into individual taxa names according to the level
  distinct() %>% #remove duplicates
  arrange(across(everything()))  # Reorders columns alphabetically
mOTU_grey.ls

#Export for ease and downstream analysis
#write.csv(mOTU_grey.ls, "D:/Functional_R_analysis/mOTU_WGCNAmodule_greytaxa.csv")

#Abundance across FL vs PA
mOTU_grey.df = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Grey") %>% #filter to only a specific module
  #select(newname) %>% # choose only the informative column
  distinct() %>% #remove duplicates
  mutate(Sample_type = ifelse(grepl("fraction", Sample_type), "PA", Sample_type)) %>% #replace all mention of fractions to PA
  mutate(Sample_type = ifelse(grepl("living", Sample_type), "FL", Sample_type)) #replace all mention of living to FL
mOTU_grey.df

#Identify most significantly changing  taxa
library(broom)
# Fit a linear model for each taxon and extract p-values
top5_taxa <- mOTU_grey.df %>%
  group_by(newname) %>%  # Group by taxon
  summarise(
    model = list(lm(Abundance ~ Salinity_PSU, data = cur_data())),  # Fit model
    .groups = "drop"
  ) %>%
  mutate(tidy_model = map(model, broom::tidy)) %>%  # Extract model details
  unnest(tidy_model) %>%
  filter(term == "Salinity_PSU") %>%  # Keep only the predictor term
  arrange(p.value)# %>%  # Sort by significance (ascending)
  #slice_head(n = 5)  # Select top 5 most significant taxa
top5_taxa

#Make plot to see what the difference looks like across PA vs FL
mOTU_grey.plt = ggplot(mOTU_grey.df, aes(x = Sample_type, y = Abundance*100)) +
  geom_boxplot()+
  scale_y_log10()+
  My_Theme+
  stat_compare_means()
mOTU_grey.plt



#Calculate p.value and effect size (r)
tmp.w = wilcox.test(mOTU_grey.df$Abundance ~ mOTU_grey.df$Sample_type)
W <- tmp.w$statistic
n1 <- length(subset(mOTU_grey.df, Sample_type == "FL")$Sample_type)
n2 <- length(subset(mOTU_turquoise.df, Sample_type == "PA")$Sample_type)
r <- W / (n1 * n2)
r
tmp.w

#Calculate mean abundnace difference
mean_diff = mOTU_grey.df %>%
  group_by(Sample_type) %>%
  summarise(mean_val = mean(Abundance))
mean_diff
mean_diff[2,2] / mean_diff[1,2]


```

###Identify taxa in the turquoise mOTU module
```{r}

#Extract turquoise module taxa
mOTU_turquoise.ls = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Turquoise") %>% #filter to only a specific module
  select(newname) %>% # choose only the informative column
  separate(newname, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "MAGID")) %>% #separate the taxa column into individual taxa names according to the level
  distinct() %>% #remove duplicates
  arrange(across(everything()))  # Reorders columns alphabetically
mOTU_turquoise.ls


#Export for ease and downstream analysis
#write.csv(mOTU_turquoise.ls, "D:/Functional_R_analysis/mOTU_WGCNAmodule_turquoisetaxa.csv")

#Abundance across FL vs PA
mOTU_turquoise.df = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Turquoise") %>% #filter to only a specific module
  #select(newname) %>% # choose only the informative column
  distinct() %>% #remove duplicates
  mutate(Sample_type = ifelse(grepl("fraction", Sample_type), "PA", Sample_type)) %>% #replace all mention of fractions to PA
  mutate(Sample_type = ifelse(grepl("living", Sample_type), "FL", Sample_type)) #replace all mention of living to FL
mOTU_turquoise.df

#Make plot to see what the difference looks like
mOTU_turquoise.plt = ggplot(mOTU_turquoise.df, aes(x = Sample_type, y = Abundance*100)) +
  geom_boxplot()+
  scale_y_log10()+
  My_Theme+
  stat_compare_means()
mOTU_turquoise.plt

#Calculate p.value and effect size (r)
tmp.w = wilcox.test(mOTU_turquoise.df$Abundance ~ mOTU_turquoise.df$Sample_type)
W <- tmp.w$statistic
n1 <- length(subset(mOTU_turquoise.df, Sample_type == "FL")$Sample_type)
n2 <- length(subset(mOTU_turquoise.df, Sample_type == "PA")$Sample_type)
r <- W / (n1 * n2)
r
tmp.w

#Calculate mean abundnace difference
mean_diff = mOTU_turquoise.df %>%
  group_by(Sample_type) %>%
  summarise(mean_val = mean(Abundance))
mean_diff
mean_diff[2,2] / mean_diff[1,2]


```


###Identify taxa in the Blue mOTU module
```{r}

#Extract Blue module taxa
mOTU_Blue.ls = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Blue") %>% #filter to only a specific module
  select(newname) %>% # choose only the informative column
  separate(newname, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "MAGID")) %>% #separate the taxa column into individual taxa names according to the level
  distinct() %>% #remove duplicates
  arrange(across(everything()))  # Reorders columns alphabetically
mOTU_Blue.ls

#Abundance across FL vs PA
mOTU_Blue.df = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Blue") %>% #filter to only a specific module
  #select(newname) %>% # choose only the informative column
  distinct() %>% #remove duplicates
  mutate(Sample_type = ifelse(grepl("fraction", Sample_type), "PA", Sample_type)) %>% #replace all mention of fractions to PA
  mutate(Sample_type = ifelse(grepl("living", Sample_type), "FL", Sample_type)) #replace all mention of living to FL
mOTU_Blue.df

#Make plot to see what the difference looks like
mOTU_Blue.plt = ggplot(mOTU_Blue.df, aes(x = Sample_type, y = Abundance*100)) +
  geom_boxplot()+
  scale_y_log10()+
  My_Theme+
  stat_compare_means()
mOTU_Blue.plt

#Calculate p.value and effect size (r)
tmp.w = wilcox.test(mOTU_Blue.df$Abundance ~ mOTU_Blue.df$Sample_type)
W <- tmp.w$statistic
n1 <- length(subset(mOTU_Blue.df, Sample_type == "FL")$Sample_type)
n2 <- length(subset(mOTU_Blue.df, Sample_type == "PA")$Sample_type)
r <- W / (n1 * n2)
r
tmp.w

#Calculate mean abundnace difference
mean_diff = mOTU_Blue.df %>%
  group_by(Sample_type) %>%
  summarise(mean_val = mean(Abundance))
mean_diff
mean_diff[2,2] / mean_diff[1,2]


```

###Identify taxa in the Yellow mOTU module
```{r}

#Extract Yellow module taxa
mOTU_Yellow.ls = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Yellow") %>% #filter to only a specific module
  select(newname) %>% # choose only the informative column
  separate(newname, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "MAGID")) %>% #separate the taxa column into individual taxa names according to the level
  distinct() %>% #remove duplicates
  arrange(across(everything()))  # Reorders columns alphabetically
mOTU_Yellow.ls

#Abundance across FL vs PA
mOTU_Yellow.df = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Yellow") %>% #filter to only a specific module
  #select(newname) %>% # choose only the informative column
  distinct() %>% #remove duplicates
  mutate(Sample_type = ifelse(grepl("fraction", Sample_type), "PA", Sample_type)) %>% #replace all mention of fractions to PA
  mutate(Sample_type = ifelse(grepl("living", Sample_type), "FL", Sample_type)) #replace all mention of living to FL
mOTU_Yellow.df

#Make plot to see what the difference looks like
mOTU_Yellow.plt = ggplot(mOTU_Yellow.df, aes(x = Sample_type, y = Abundance*100)) +
  geom_boxplot()+
  scale_y_log10()+
  My_Theme+
  stat_compare_means()
mOTU_Yellow.plt

#Calculate p.value and effect size (r)
tmp.w = wilcox.test(mOTU_Yellow.df$Abundance ~ mOTU_Yellow.df$Sample_type)
W <- tmp.w$statistic
n1 <- length(subset(mOTU_Yellow.df, Sample_type == "FL")$Sample_type)
n2 <- length(subset(mOTU_Yellow.df, Sample_type == "PA")$Sample_type)
r <- W / (n1 * n2)
r
tmp.w

#Calculate mean abundnace difference
mean_diff = mOTU_Yellow.df %>%
  group_by(Sample_type) %>%
  summarise(mean_val = mean(Abundance))
mean_diff
mean_diff[2,2] / mean_diff[1,2]


```
###Taxa in common from Turquoise + Blue + Yellow

```{r}
library(purrr)

#test = rbind(mOTU_turquoise.ls, mOTU_Blue.ls, mOTU_Yellow.ls)

# Create a list of dataframes with the last two columns removed
dfs <- list(
  mOTU_turquoise.ls %>% select(-((ncol(.)-2):ncol(.))),
  mOTU_Blue.ls %>% select(-((ncol(.)-2):ncol(.))),
  mOTU_Yellow.ls %>% select(-((ncol(.)-2):ncol(.)))
)

# Use reduce() and inner_join() to join the dataframes on all common columns.
common_rows <- reduce(dfs, inner_join)

# View the result
common_rows

```


###Identify taxa in the Green mOTU module
```{r}

#Extract Green module taxa
mOTU_Green.ls = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Green") %>% #filter to only a specific module
  select(newname) %>% # choose only the informative column
  separate(newname, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "MAGID")) %>% #separate the taxa column into individual taxa names according to the level
  distinct() %>% #remove duplicates
  arrange(across(everything()))  # Reorders columns alphabetically
mOTU_Green.ls

#Abundance across FL vs PA
mOTU_Green.df = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Green") %>% #filter to only a specific module
  #select(newname) %>% # choose only the informative column
  distinct() %>% #remove duplicates
  mutate(Sample_type = ifelse(grepl("fraction", Sample_type), "PA", Sample_type)) %>% #replace all mention of fractions to PA
  mutate(Sample_type = ifelse(grepl("living", Sample_type), "FL", Sample_type)) #replace all mention of living to FL
mOTU_Green.df

#Make plot to see what the difference looks like
mOTU_Green.plt = ggplot(mOTU_Green.df, aes(x = Sample_type, y = Abundance*100)) +
  geom_boxplot()+
  scale_y_log10()+
  My_Theme+
  stat_compare_means()
mOTU_Green.plt

#Calculate p.value and effect size (r)
tmp.w = wilcox.test(mOTU_Green.df$Abundance ~ mOTU_Green.df$Sample_type)
W <- tmp.w$statistic
n1 <- length(subset(mOTU_Green.df, Sample_type == "FL")$Sample_type)
n2 <- length(subset(mOTU_Green.df, Sample_type == "PA")$Sample_type)
r <- W / (n1 * n2)
r
tmp.w

#Calculate mean abundnace difference
mean_diff = mOTU_Green.df %>%
  group_by(Sample_type) %>%
  summarise(mean_val = mean(Abundance))
mean_diff
mean_diff[2,2] / mean_diff[1,2]


```
###Identify taxa in the Brown mOTU module
```{r}

#Extract Brown module taxa
mOTU_Brown.ls = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Brown") %>% #filter to only a specific module
  select(newname) %>% # choose only the informative column
  separate(newname, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "MAGID")) %>% #separate the taxa column into individual taxa names according to the level
  distinct() %>% #remove duplicates
  arrange(across(everything()))  # Reorders columns alphabetically
mOTU_Brown.ls

#Abundance across FL vs PA
mOTU_Brown.df = mOTU_module_ab.df %>% # load in data
  filter(module1 == "Brown") %>% #filter to only a specific module
  #select(newname) %>% # choose only the informative column
  distinct() %>% #remove duplicates
  mutate(Sample_type = ifelse(grepl("fraction", Sample_type), "PA", Sample_type)) %>% #replace all mention of fractions to PA
  mutate(Sample_type = ifelse(grepl("living", Sample_type), "FL", Sample_type)) #replace all mention of living to FL
mOTU_Brown.df

#Make plot to see what the difference looks like
mOTU_Brown.plt = ggplot(mOTU_Brown.df, aes(x = Sample_type, y = Abundance*100)) +
  geom_boxplot()+
  scale_y_log10()+
  My_Theme+
  stat_compare_means()
mOTU_Brown.plt

#Calculate p.value and effect size (r)
tmp.w = wilcox.test(mOTU_Brown.df$Abundance ~ mOTU_Brown.df$Sample_type)
W <- tmp.w$statistic
n1 <- length(subset(mOTU_Brown.df, Sample_type == "FL")$Sample_type)
n2 <- length(subset(mOTU_Brown.df, Sample_type == "PA")$Sample_type)
r <- W / (n1 * n2)
r
tmp.w

#Calculate mean abundnace difference
mean_diff = mOTU_Brown.df %>%
  group_by(Sample_type) %>%
  summarise(mean_val = mean(Abundance))
mean_diff
mean_diff[2,2] / mean_diff[1,2]


```
#Extract all methanotrophs
How to identify methanogenesis:
  mcrA + EC 4.99.1.2 + phnJ - generates methane
  pmoA + mmoX - utilises methane
  
  
2.8.4.1	coenzyme-B sulfoethylthiotransferase	Transferases	Both	K00399	ec00680.ec01100.ec01120	CH4
2.8.4.1	coenzyme-B sulfoethylthiotransferase	Transferases	Both	K00401	ec00680.ec01100.ec01120	CH4
2.8.4.1	coenzyme-B sulfoethylthiotransferase	Transferases	Both	K00402	ec00680.ec01100.ec01120	CH4
4.99.1.2	alkylmercury lyase	Lyases	Producing	K00221		CH4
4.7.1.1	alpha-D-ribose 1-methylphosphonate 5-phosphate C-P-lyase	Lyases		K06163	ec00440.ec01100	CH4
1.14.18.3	methane monooxygenase	Oxidoreductases		K10944	ec00680.ec01100	CH4
1.14.13.25	methane monooxygenase	Oxidoreductases		K16157	ec00680.ec01100.ec01120	CH4
1.14.13.25	methane monooxygenase	Oxidoreductases		K16158	ec00680.ec01100.ec01120	CH4
1.14.13.25	methane monooxygenase	Oxidoreductases		K16159	ec00680.ec01100.ec01120	CH4
1.14.13.25	methane monooxygenase	Oxidoreductases		K16161	ec00680.ec01100.ec01120	CH4

##Using genes - no mcrA gene identifed
```{r}


#Import gene lists
CH4Genelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946")) %>%
  filter(Compound == "CH4")
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946"))

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))


Methano_geneabund_KO_Temp = annot %>%
  filter(KO %in% CH4Genelist.df$KEGG_Orthology # | 
           #str_detect(DESCRIPTION, "mmoX") | 
          # str_detect(DESCRIPTION, "mcrA") | 
         #  str_detect(DESCRIPTION, "pmoA")
         ) %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  unite(fulltaxa, c("domain", "phylum", "class", "order", "family", "genus", "species")) %>% # make new column that contains taxa information
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering)
  mutate(DESCRIPTION = ifelse(KO == "K10944" , "pmoA; methane monooxygenase subunit A", DESCRIPTION)) # Rename description to purely pmoA
  
  dplyr::select(DESCRIPTION, KO, v_module, module1, Phylum, Class, Order, Family, Genus, Species) %>%
  distinct()

unique(Methano_geneabund_KO_Temp$KO)
unique(Methano_geneabund_KO_Temp$DESCRIPTION)
  

  
  
  
  
  
  #Remove phylogenetic level info
Methano_geneabund_KO_Temp$fulltaxa = gsub("d__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("p__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("c__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("o__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("f__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("g__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("s__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("_", "__", Methano_geneabund_KO_Temp$fulltaxa)




amoAClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  dplyr::select(gene_cluster, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)


Methano_geneabund_KO_Temp = Methano_geneabund_KO_Temp %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2/CH4 gene
  filter(fulltaxa %in% Temp_MG_MT_mOTU_taxa.ls) %>% # subset to only those 6 taxa we're interested in
anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome, fulltaxa) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(fulltaxa, genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(Methano_geneabund_KO_Temp)
#View(Methano_geneabund_KO_Temp)

Methano_geneabund_KO_Temp.lng <- Methano_geneabund_KO_Temp %>%
  pivot_longer(cols = -c(KO, genome, fulltaxa), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, fulltaxa, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == "METAG" & Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()

#Correct abundance
Methano_geneabund_KO_Temp.lng$counts = Methano_geneabund_KO_Temp.lng$counts / 1000

#Check how many unique genera
unique(Methano_geneabund_KO_Temp.lng$fulltaxa)
unique(Methano_geneabund_KO_Temp.lng$genome)

Methano_taxa_MG.df = Methano_geneabund_KO_Temp.lng %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Clean up for plot
Methano_taxa_MG.df$station_km = as.numeric(as.character(Methano_taxa_MG.df$station_km))


Methano_taxa_MG.df$Sample_date = factor(Methano_taxa_MG.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Methano_taxa_MG.sum = Rmisc::summarySE(Methano_taxa_MG.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#Keep for records
write.csv(Methano_taxa_MG.sum, "F:/Functional_R_analysis/MGMTmOTUCorr_MG_Methano.csv")

#Methano_taxa_MG.sum = read.csv("F:/Functional_R_analysis/MGMTmOTUCorr_MG_Methano.csv")

unique(Methano_taxa_MG.sum$fulltaxa)




####Metatranscriptomes ####

Methano_geneabund_KO_Temp = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  unite(fulltaxa, c("domain", "phylum", "class", "order", "family", "genus", "species")) # make new column that contains taxa information

  #Remove phylogenetic level info
Methano_geneabund_KO_Temp$fulltaxa = gsub("d__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("p__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("c__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("o__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("f__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("g__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("s__", "", Methano_geneabund_KO_Temp$fulltaxa)
Methano_geneabund_KO_Temp$fulltaxa = gsub("_", "__", Methano_geneabund_KO_Temp$fulltaxa)

Methano_geneabund_KO_Temp = Methano_geneabund_KO_Temp %>%
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2/CH4 gene
  filter(fulltaxa %in% Temp_MG_MT_mOTU_taxa.ls) %>% # subset to only those 6 taxa we're interested in
anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO, genome, fulltaxa) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(fulltaxa, genome, KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(Methano_geneabund_KO_Temp)
#View(Methano_geneabund_KO_Temp)

Methano_CO2CH4_tbl_Temp.lng <- Methano_geneabund_KO_Temp %>%
  pivot_longer(cols = -c(KO, genome, fulltaxa), names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  #left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, #DESCRIPTION,
         KO, genome, fulltaxa, ) %>% # only keep relevant columns
  #separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  #left_join(CarbonGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  #select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(Sample_type == "Free_living") %>% # select only metatranscriptome samples
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()

#Correct abundance
Methano_CO2CH4_tbl_Temp.lng$counts = Methano_CO2CH4_tbl_Temp.lng$counts / 1000

#Make data_type names informative
Methano_CO2CH4_tbl_Temp.lng$data_type = gsub("METAG", "Metagenomes", Methano_CO2CH4_tbl_Temp.lng$data_type)
Methano_CO2CH4_tbl_Temp.lng$data_type = gsub("METAT", "Transcriptomes", Methano_CO2CH4_tbl_Temp.lng$data_type)


 #Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
Methano_TG_Temp.df <- spread(Methano_CO2CH4_tbl_Temp.lng[ , ! names(amoAClean_CO2CH4_tbl_long_Temp) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  mutate_at(c("Metagenomes", "Transcriptomes"), ~replace(., is.na(.), 0)) #Replace NAs with 0 in the new columns
#Ensure that it worked
dim(Methano_CO2CH4_tbl_Temp.lng)
dim(Methano_TG_Temp.df)




#Calculate Transcripts per gene copy
Methano_TG_Temp.df$TranscriptsPerGenome = Methano_TG_Temp.df$Transcriptomes / Methano_TG_Temp.df$Metagenomes

#Add more info - remove NA's and Infinite numbers
Methano_TG_Temp.df = Methano_TG_Temp.df %>%
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.na(.), 0)) %>% # This was usuTemply the case when 0/0
  mutate_at(c("TranscriptsPerGenome"), ~replace(., is.infinite(.), "9999999999")) #Replace Infin with #/0, as Metagenome likely incomplete

#Convert from wide to long format
Methano_TG_Temp.df = gather(Methano_TG_Temp.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(Methano_TG_Temp.df)

#Remove data_types and columns that are no longer relevant 
Methano_TG_Temp.df = subset(Methano_TG_Temp.df, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber, station_km, Sample_date, genome, fulltaxa)
dim(Methano_TG_Temp.df)


#Remove samples for which we have no metatranscriptomes
Methano_TG_Temp.df = subset(Methano_TG_Temp.df, Associatednumber > 116)

#Remove samples for which sequencing failed
Methano_TG_Temp.df = subset(Methano_TG_Temp.df, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
#Make sure data is set up properly
Methano_TG_Temp.df$counts = as.numeric(as.character(Methano_TG_Temp.df$counts))
Methano_TG_Temp.df$Associatednumber = as.character(Methano_TG_Temp.df$Associatednumber)


#Check how many unique genera
unique(Methano_TG_Temp.df$fulltaxa)
unique(Methano_TG_Temp.df$genome)

Methano_taxa_MT.df = Methano_TG_Temp.df %>%
  select(counts, KO, fulltaxa, station_km, Sample_date)

#Clean up for plot
Methano_taxa_MT.df$station_km = as.numeric(as.character(Methano_taxa_MT.df$station_km))


Methano_taxa_MT.df$Sample_date = factor(Methano_taxa_MT.df$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

Methano_taxa_MT.df = Rmisc::summarySE(Methano_taxa_MT.df, measurevar = "counts", groupvars = c("fulltaxa", "station_km", "Sample_date", "KO"))

#Keep for records
write.csv(Methano_taxa_MT.df, "F:/Functional_R_analysis/MGMTmOTUCorr_MT_Methano.csv")

#Methano_taxa_MT.df = read.csv("E:/Functional_R_analysis/MGMTmOTUCorr_MT_Methano.csv")

unique(Methano_taxa_MT.df$fulltaxa)




#### Calculations - no need for MT as we calculate transcripts per gene ####

#Read in dataframes
Methano_taxa_MG.df = read.csv("F:/Functional_R_analysis/Methano_taxa_MG.sum")
#Methano_taxa_MT.df = read.csv("E:/Functional_R_analysis/MGMTmOTUCorr_MT_Methano.csv")
unique(Temp_taxa_MG.df$fulltaxa)

#Summary for ease
Methano_MG.sum = Rmisc::summarySE(Methano_taxa_MG.df, measurevar = "counts", groupvars = c("KO", "fulltaxa"))
Methano_MG.sum = Rmisc::summarySE(Methano_MG.sum, measurevar = "counts", groupvars = c("fulltaxa"))
#Temp_MT.sum = Rmisc::summarySE(Temp_taxa_MT.df, measurevar = "counts", groupvars = c("KO", "fulltaxa"))
#Temp_MT.sum = Rmisc::summarySE(Temp_MT.sum, measurevar = "counts", groupvars = c("fulltaxa"))

#How many of our selected carbon KOs are associated with each taxa?
View(Methano_MG.sum)
#Methano_MG.sum

#How many KOs shared between all taxa?
Temp_MG.sum = Rmisc::summarySE(Temp_taxa_MG.df, measurevar = "counts", groupvars = c("KO", "fulltaxa"))



```
##Using taxa 
###mOTUs
```{r}
#Import mOTU ID lists that lets us link them to MAGs, and combine them
mag_nm = read.csv("D:/Functional_R_analysis/mag_2_new_motus", header = F, sep = "\t") %>%
  separate_rows(V2, sep = ";") %>%
  dplyr::rename(mOTU_ID = V1) %>%
  dplyr::rename(MAG_ID = V2)

mag_emOTUs.df = read.csv("D:/Functional_R_analysis/mag_2_existing_motus", header = F, sep = "\t") %>%
  separate_rows(V2, sep = ";") %>%
  dplyr::select(V1, V2) %>%
  dplyr::rename(mOTU_ID = V2) %>%
  dplyr::rename(MAG_ID = V1)

mOTUs2MAGs = rbind(mag_nmOTUs.df, mag_emOTUs.df) %>%
  filter(mOTU_ID!="NotEnoughMGs")


#Import module information and combine (number and colour)
mOTUs_mod.df = read.csv("D:/Functional_R_analysis/Network/WGCNA_network_mOTUs_all.csv", sep = ";") %>%
  dplyr::select(v_name, v_module, X, Y, v_motu_id) %>%
  dplyr::rename(mOTU_ID = v_motu_id) %>%
  dplyr::rename(taxa = v_name)

#Import list of mOTUs and their respective module colour
network_modules_mOTUs.df = read.csv("D:/Functional_R_analysis/Network/edgelist_mOTUs_all_type.tsv", sep = "\t") %>%
  dplyr::select(gene1, module1) %>%
  distinct()

#How many methanotrophs in the WGCNA analysis
meths = network_modules_mOTUs.df %>%
  filter(str_detect(gene1, "meth"))


#Modify the annotation df, to make linking it clearer downstream
annot_mod = annot %>%
  rownames_to_column("gene_cluster")


#Combine both module lists
mOTUs_module_KO.df = network_modules_mOTUs.df %>%
  left_join(mOTUs_mod.df, by = c("gene1" = "taxa")) %>%
  drop_na(v_module) %>% # remove taxa that haven't been assigned a module
  distinct() %>% # Remove duplicates
  dplyr::rename(taxa = gene1) %>% #Rename taxa for consistency
  dplyr::select(taxa, v_module, module1) %>% # choose only the columns that we need
  separate(col = taxa, sep = "__", into = c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID")) %>% # separate the taxa information and establish the mOTU ID column needed downstream
  left_join(mOTUs2MAGs, by = c("mOTU_ID" = "mOTU_ID")) %>%
  left_join(gene_cluster_taxa, by = c("MAG_ID" = "genome")) %>%
  dplyr::select(-gene) %>%
  distinct() %>%
  left_join(annot_mod, by = c("gene_cluster" = "gene_cluster")) %>%
  filter(KO != is.na(KO)) # filter to remova all NA
  
mOTUs_module_KO.df



#Identify methanogens in mOTUs

Methyl_taxa.df = mOTUs_module_KO.df %>%
  unite(fulltaxa, c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID")) %>% # make new column that contains taxa information
  filter(str_detect(fulltaxa, "meth")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, fulltaxa) %>%
  distinct()

dim(Methyl_taxa.df)


#Identify CH4 correlation module taxa - brown

BrownModuleTaxa.df = mOTUs_module_KO.df %>%
  unite(fulltaxa, c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID")) %>% # make new column that contains taxa information
  filter(str_detect(module1, "brown")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, fulltaxa) %>%
  distinct()

dim(BrownModuleTaxa.df)

unique(BrownModuleTaxa.df$fulltaxa)


#Identify salinity correlation module taxa - turquoise

TurquoiseModuleTaxa.df = mOTUs_module_KO.df %>%
  unite(fulltaxa, c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID")) %>% # make new column that contains taxa information
  filter(str_detect(module1, "turquoise")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, fulltaxa, MAG_ID) %>%
  distinct()

dim(TurquoiseModuleTaxa.df)

unique(TurquoiseModuleTaxa.df$fulltaxa)
head(TurquoiseModuleTaxa.df)

unique(TurquoiseModuleTaxa.df$MAG_ID)



```

###Extract MAG osmoregulation genes from turquoise/blue/brown mOTU module

```{r}
####Turquoise####

TurquoiseModuleTaxa.df = mOTUs_module_KO.df %>%
  unite(fulltaxa, c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID")) %>% # make new column that contains taxa information
  filter(str_detect(module1, "turquoise")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, fulltaxa, mOTU_ID) %>%
  distinct()

dim(TurquoiseModuleTaxa.df)

unique(TurquoiseModuleTaxa.df$fulltaxa)
head(TurquoiseModuleTaxa.df)

unique(TurquoiseModuleTaxa.df$MAG_ID)


#Identify osmosis genes

Turquoise_Osmotic_genes.df = TurquoiseModuleTaxa.df %>%
  filter(str_detect(DESCRIPTION, "osmo")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, mOTU_ID, fulltaxa) %>%
  distinct()

dim(Turquoise_Osmotic_genes.df)

Turquoise_Osmotic_genes.df

unique(Turquoise_Osmotic_genes.df$MAG_ID)

#write.csv(Osmotic_genes.df, "E:/Functional_R_analysis/Osmoregulationgenes.csv")



####Blue ####

BlueModuleTaxa.df = mOTUs_module_KO.df %>%
  unite(fulltaxa, c("Phylum", "Class", "Order", "Family", "Genus", "Species")) %>% # make new column that contains taxa information
  filter(str_detect(module1, "blue")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, fulltaxa, mOTU_ID) %>%
  distinct()

dim(BlueModuleTaxa.df)

unique(BlueModuleTaxa.df$fulltaxa)
head(BlueModuleTaxa.df)

unique(BlueModuleTaxa.df$mOTU_ID)


#Identify osmosis genes

Blue_Osmotic_genes.df = BlueModuleTaxa.df %>%
  filter(str_detect(DESCRIPTION, "osmo")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, mOTU_ID, fulltaxa) %>%
  distinct()

dim(Blue_Osmotic_genes.df)

Blue_Osmotic_genes.df

unique(Blue_Osmotic_genes.df$mOTU_ID)

#write.csv(Osmotic_genes.df, "E:/Functional_R_analysis/Osmoregulationgenes.csv")



####Brown ####

BrownModuleTaxa.df = mOTUs_module_KO.df %>%
  unite(fulltaxa, c("Phylum", "Class", "Order", "Family", "Genus", "Species")) %>% # make new column that contains taxa information
  filter(str_detect(module1, "brown")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, fulltaxa, mOTU_ID, MAG_ID) %>%
  distinct()

dim(BrownModuleTaxa.df)

unique(BrownModuleTaxa.df$fulltaxa)
head(BrownModuleTaxa.df)

unique(BrownModuleTaxa.df$mOTU_ID)


#Identify osmosis genes

Brown_Osmotic_genes.df = BrownModuleTaxa.df %>%
  filter(str_detect(DESCRIPTION, "osmo")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, mOTU_ID, MAG_ID, fulltaxa) %>%
  distinct()

dim(Brown_Osmotic_genes.df)

Brown_Osmotic_genes.df

unique(Brown_Osmotic_genes.df$mOTU_ID)
unique(Brown_Osmotic_genes.df$MAG_ID)

Brown_MAGs.ls = Brown_Osmotic_genes.df$MAG_ID
#write.csv(Osmotic_genes.df, "E:/Functional_R_analysis/Osmoregulationgenes.csv")
```

###Extract nitrogen associated MAGs - Figure S5
```{r}


#Import gene list
CarbonGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";")%>%
  dplyr::filter(Compound %in% c("CO2", "CH4"))
dim(distinct(CarbonGenelist.df))
unique(CarbonGenelist.df$Compound)

NitrogenGenelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  dplyr::filter(Compound %nin% c("CO2", "CH4", ""))
unique(NitrogenGenelist.df$Compound)

#Subset for testing purposes
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Name == "methane monooxygenase")
#BugHunt_GeneList.df = subset(CarbonGenelist.df, Direction == "Utilising")

amoAMatches.ls = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
dim(amoAMatches.ls)
sort(unique(amoAMatches.ls$KO))

NitrogenClean_geneabund_KO = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
  mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% NitrogenGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, KO) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(NitrogenClean_geneabund_KO)

#Correct abundance
NitrogenClean_geneabund_KO[c(2:264)] = NitrogenClean_geneabund_KO[c(2:264)] / 1000


NitrogenClean_CO2CH4_tbl_long <- NitrogenClean_geneabund_KO %>%
  filter(KO %in% NitrogenGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(NitrogenGenelist.df, by = c("KO"="KEGG_Orthology")) %>%
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  distinct()

#View(amoAClean_CO2CH4_tbl_long)
dim(NitrogenClean_CO2CH4_tbl_long)

#write.csv(NitrogenClean_CO2CH4_tbl_long, "NitrogenClean.csv")

#NitrogenClean_CO2CH4_tbl_long = read.csv( "NitrogenClean.csv")

#Reorder factors
NitrogenClean_CO2CH4_tbl_long$Station = factor(NitrogenClean_CO2CH4_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

NitrogenClean_CO2CH4_tbl_long$Sample_date = gsub("-", " ",NitrogenClean_CO2CH4_tbl_long$Sample_date)

NitrogenClean_CO2CH4_tbl_long$Sample_date = factor(NitrogenClean_CO2CH4_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
NitrogenClean_CO2CH4_tbl_long$data_type = gsub("METAG", "Metagenomes", NitrogenClean_CO2CH4_tbl_long$data_type)
NitrogenClean_CO2CH4_tbl_long$data_type = gsub("METAT", "Transcriptomes", NitrogenClean_CO2CH4_tbl_long$data_type)

#Subset to split metagenomes and metatranscriptomes and remove superflous columns
NitrogenClean_CO2CH4_tbl_long_MG = subset(NitrogenClean_CO2CH4_tbl_long, data_type == "Metagenomes") 

NitrogenClean_CO2CH4_tbl_long_MG.sum = Rmisc::summarySE(NitrogenClean_CO2CH4_tbl_long_MG, 
                                                        measurevar = "counts", 
                                                        groupvars = c("station_km", "Compound", "Sample_date"))

NitrogenGenes.plt = ggplot(data = NitrogenClean_CO2CH4_tbl_long_MG.sum, aes(x = station_km, y = counts, colour = Compound, group = Compound)) +
  geom_line() +
  geom_point() +
  xlab("Elbe km")+
  ylab("Abundance (%)")+
  scale_colour_manual("Associated compound", values = expanded_cbbPalette)+
  facet_grid(. ~ Sample_date) +
  My_Theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
NitrogenGenes.plt

pdf("E:/Functional_R_analysis/Figures/NitrogenGenes_MG.pdf", width = 12, height = 4)
NitrogenGenes.plt
dev.off()

```



###MAGs
```{r}

#Import gene list
CH4Genelist.df = read.csv("E:/Functional_R_analysis/CarbonGeneList.csv", header = T, sep = ";") %>%
  filter(KEGG_Orthology %nin% c("K10945", "K10946")) %>%
  filter(Compound == "CH4")

#amoAMatches.ls = annot %>%
#  rownames_to_column("gene_cluster") %>%
#  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
#  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
#  filter(KO %in% CarbonGenelist.df$KEGG_Orthology) %>% # only extract the CO2CH4 gene
#  filter(str_detect(genus,"Nitros") & str_detect(KO, "^K10944$"))
#dim(amoAMatches.ls)
#sort(unique(amoAMatches.ls$KO))

Geneabund_KO_CH4 = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  mutate(DESCRIPTION = ifelse(gene %in% amoAMatches.ls$gene, "amoA; ammonia monooxygenase subunit A", DESCRIPTION)) %>% # Rename description based on above taxa filtering
  mutate(DESCRIPTION = ifelse(KO == "K10944" & gene %nin% amoAMatches.ls$gene, "pmoA; methane monooxygenase subunit A", DESCRIPTION)) %>% # Rename description to purely pmoA
  dplyr::select(gene_cluster, DESCRIPTION) %>% # select only the columns titled gene_cluster and KO
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  dplyr::select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(DESCRIPTION) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(Geneabund_KO_CH4)
head(Geneabund_KO_CH4)


#saveRDS(Geneabund_KO_CH4, "E:/Functional_R_analysis/Network/Geneabund_KO_CH4.rds")
Geneabund_KO_CH4 = readRDS("E:/Functional_R_analysis/Network/Geneabund_KO_CH4.rds")




Methyl_taxa.df = Geneabund_KO_CH4 %>%
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  unite(fulltaxa, c("Phylum", "Class", "Order", "Family", "Genus", "Species", "mOTU_ID")) %>% # make new column that contains taxa information
  filter(str_detect(fulltaxa, "meth")) %>%
  dplyr::select(DESCRIPTION, KO, v_module, module1, fulltaxa) %>%
  distinct()

dim(Methyl_taxa.df)





Geneabund_KO_CH4_MG.lng <- Geneabund_KO_CH4 %>%
  pivot_longer(!DESCRIPTION, names_to = "sampleid", values_to = "counts", values_drop_na = 0) # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0. 

  
##Need to cut dataframe into 120 pieces and run code on it in loop, and then stick it back together
  ##This needs to be redone
  
Final_Geneabund_KO_MG.lng = as.data.frame(matrix(ncol = 27, nrow = 1))
colnames(Final_Geneabund_KO_MG.lng) = c("sampleid", "counts", "SName", "LName", "KO", "Sample",   "Associatednumber", "DNA_concentration_ng.uL", "Station", "StationNumber", "Sample_type", "Sample_date", "SPM_mgperL", "DOC_mg.L", "TN_mg.L",  "DIC_mg.L", "DOC_uM.L", "DIC_uM.L", "POC_mgperL", "PTC_mgperL", "PTN_mgperL",  "PTH_mgperL", "BioSample", "ERANumber", "ProjectID", "data_type", "station_km")
  
i=1
i=120
for (i in 1:ceiling(dim(Geneabund_KO_MG.lng)[1]/18158)) {
  
  number = i * 18158 
  #number = i * 20
  
  tmp.lng = Geneabund_KO_MG.lng[c((number-18158):number),] 
  #tmp.lng = Geneabund_KO_MG.lng[c((number-20):number),] # Bug hunting
  
  tmp.out = tmp.lng %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information for amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()
  
  Final_Geneabund_KO_MG.lng = rbind(Final_Geneabund_KO_MG.lng, tmp.out)
  
  
  if ( i == ceiling(dim(Geneabund_KO_MG.lng)[1]/18158) ) {
    
    end = dim(Geneabund_KO_MG.lng)[1]
    number = ((i-1) * 18158)
    tmp.lng = Geneabund_KO_MG.lng[c(number:end),] 
    
    tmp.out = tmp.lng %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("DESCRIPTION" = "DESCRIPTION"), relationship = "many-to-many") %>% # add gene information
  mutate(KO = ifelse(DESCRIPTION == "amoA; ammonia monooxygenase subunit A", "K10944", KO)) %>% # add gene information fpr amoA
  mutate(KO = ifelse(DESCRIPTION == "pmoA; methane monooxygenase subunit A", "K10944", KO)) %>% # add gene information for pmoA
  dplyr::select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  filter(data_type == 'METAG') %>% # keep only metagenomes
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>%
  distinct()
  
  Final_Geneabund_KO_MG.lng = rbind(Final_Geneabund_KO_MG.lng, tmp.out)
  
  print(paste0("Finished the last one!"))
  }
  
  print(paste0("Completed ", i, " out of ", round(dim(Geneabund_KO_MG.lng)[1]/18158), " dataframes, which is ", round(i/round(dim(Geneabund_KO_MG.lng)[1]/18158) * 100), "%"))
  
  
}

#Remove unnecesary top row, as it was generated when making the initial df
Final_Geneabund_KO_MG.lng = Final_Geneabund_KO_MG.lng[-1,]

Geneabund_KO_MG.lng = Final_Geneabund_KO_MG.lng

#save in case of crashes (which are inevitable with a df of this size)
saveRDS(Final_Geneabund_KO_MG.lng, "F:/Functional_R_analysis/Network/Geneabund_KO_MG.lng.rds")
#Geneabund_KO_MG.lng = readRDS("E:/Functional_R_analysis/Network/Geneabund_KO_MG.lng.rds") 


#Correct count data
Geneabund_KO_MG.lng$counts = Geneabund_KO_MG.lng$counts / 1000

#View(Geneabund_KO_MG.lng)
dim(Geneabund_KO_MG.lng)

#Reorder factors
Geneabund_KO_MG.lng$Statio = factor(Geneabund_KO_MG.lng$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

Geneabund_KO_MG.lng$Sample_date = gsub("-", " ",Geneabund_KO_MG.lng$Sample_date)

Geneabund_KO_MG.lng$Sample_date = factor(Geneabund_KO_MG.lng$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
Geneabund_KO_MG.lng$data_type = gsub("METAG", "Metagenomes", Geneabund_KO_MG.lng$data_type)

dim(Geneabund_KO_MG.lng)

#Remove outliers and make dataframe wide from a long format
Geneabund_KO_MG.wde = Geneabund_KO_MG.lng %>%
  dplyr::select(Associatednumber, counts, KO) %>%
  pivot_wider(names_from = KO, values_from = counts, values_fn = mean) %>%
  as.data.frame() %>%
  filter(Associatednumber!="164") %>%
  column_to_rownames("Associatednumber")

#We need to have samples as columns, and genes as rows in a wide format.
WGCNA_MG_raw.df = t(Geneabund_KO_MG.wde)

```














#Osmoregulation transcripts and how they link to mOTU taxa modules - no matches

```{r}
mOTUMAGmatches.df

Geneabund_Osmo = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(DESCRIPTION %in% "osmo") %>% # only extract the osmoregulation
  anti_join(data.frame(gene = amoAMatches.ls$gene), by = "gene") %>% # Remove rows based on above taxa filtering
  select(gene_cluster, genome, KO) %>% # select only the columns titled gene_cluster and KO
  
  
  #Need to test this
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(amoAClean_geneabund_KO)


  filter(str_detect(SName, "osmo") | str_detect(LName, "osmo"))

Osmo_tbl_long <- Geneabund_Osmo %>%
  filter(DESCRIPTION %in% "osmo") %>% # only extract the osmoregulation
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  #mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  #mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  #group_by(KO) %>% 
  #mutate(occurrence = sum(abundance)/nsamples) %>% 
  #ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  #filter(occurrence > 0.2) %>%
  distinct()

#Correct abundance
Osmo_tbl_long$counts = Osmo_tbl_long$counts / 1000


#View(Osmo_tbl_long)
dim(Osmo_tbl_long)

#write.csv(Osmo_tbl_long, "Osmo_tbl_long.csv")

#Osmo_tbl_long = read.csv( "Osmo_tbl_long.csv")

#Reorder factors
Osmo_tbl_long$Station = factor(Osmo_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

Osmo_tbl_long$Sample_date = gsub("-", " ",Osmo_tbl_long$Sample_date)

Osmo_tbl_long$Sample_date = factor(Osmo_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
Osmo_tbl_long$data_type = gsub("METAT", "Transcriptomes", Osmo_tbl_long$data_type)
Osmo_tbl_long$data_type = gsub("METAG", "Metagenomes", Osmo_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
Osmo_TG.df <- spread(Osmo_tbl_long[ , ! names(Osmo_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(Osmo_tbl_long)
dim(Osmo_TG.df)


#Calculate Transcripts per gene copy
Osmo_TG.df$TranscriptsPerGenome = Osmo_TG.df$Transcriptomes / Osmo_TG.df$Metagenomes


#Convert from wide to long format
Osmo_TG.df = gather(Osmo_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(Osmo_TG.df)

#Remove data_types and columns that are no longer relevant 
Osmo_TG.df = subset(Osmo_TG.df, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber)
dim(Osmo_TG.df)


#Remove samples for which we have no metatranscriptomes
Osmo_TG.df = subset(Osmo_TG.df, Associatednumber > 116)
dim(Osmo_TG.df)
#Remove samples for which sequencing failed
Osmo_TG.df = subset(Osmo_TG.df, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
dim(Osmo_TG.df)

#Make sure data is set up properly
Osmo_TG.df$counts = as.numeric(as.character(Osmo_TG.df$counts))
Osmo_TG.df$Associatednumber = as.character(Osmo_TG.df$Associatednumber)





```
#Link mOTU module taxa to AAP - pufM

```{r}

mOTUMAGmatches.df

Geneabund_AAP = annot %>%
  rownames_to_column("gene_cluster") %>%
  left_join(gene_cluster_taxa, by=c("gene_cluster" = "gene_cluster")) %>% # add MAG information
  left_join(taxa, by = c("genome" = "GENOME"), relationship = "many-to-many") %>% # add taxonomic information
  filter(KO %in% "K08929") %>% # only extract the AAPregulation
  select(gene_cluster, genome, KO) %>% # select only the columns titled gene_cluster and KO
  
  
  #Need to test this
  left_join(geneabund_2, by=c("gene_cluster" = "gene_cluster")) %>% # join these two columns to the gene abundance dataframe based on the gene_cluster column
  select(-length, -gene_cluster) %>% # remove the length and gene_cluster column
  group_by(KO) %>% #aggregate the data by the KEGG ID
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) # summarise the data using the sum to get abundance data - this still needs to be divided by 1000 for actual per genome values
dim(pufMClean_geneabund_KO)


  filter(str_detect(SName, "AAP") | str_detect(LName, "AAP"))

AAP_tbl_long <- Geneabund_AAP %>%
  filter(DESCRIPTION %in% "AAP") %>% # only extract the AAPregulation
  pivot_longer(!KO, names_to = "sampleid", values_to = "counts", values_drop_na = 0) %>% # reformat from a wide to long format, remove gene-cluster information, column names will be in the sampleid column, and values that would be NA are replaced with a 0.
  left_join(annot, by = c("KO" = "KO"), relationship = "many-to-many") %>% # add gene information
  select(sampleid, counts, DESCRIPTION, KO, ) %>% # only keep relevant columns
  separate(col = DESCRIPTION, sep = ";", into = c("SName", "LName")) %>% #separate description
  select(!c(EC_Number, Pathway)) %>%
  left_join(metadata) %>% # add metadata
  filter(Sample_date != "Nov 21") %>% # remove samples from Nov 21
  filter(Station != 'BunthausSpitze') %>% #remove sample from BunthausSpitze
  ##Identify genes occurring at 0.1% abundance in at least 30% of samples
  ungroup() %>% 
  #mutate(nsamples = n_distinct(sampleid)) %>%  ## 245 samples
  #mutate(abundance = if_else(counts < 0.1, 0, 1)) %>% 
  #group_by(KO) %>% 
  #mutate(occurrence = sum(abundance)/nsamples) %>% 
  #ungroup() %>% 
#  filter(occurrence > 0, occurrence < .3)  %>% 
#  select(taxa) %>%  
#  unique() ##790 Conditionally Rare Taxa,  mOTUs occurring above 0.1% in less than 30% of samples 
  #filter(occurrence > 0.2) %>%
  distinct()

#Correct abundance
AAP_tbl_long$counts = AAP_tbl_long$counts / 1000


#View(AAP_tbl_long)
dim(AAP_tbl_long)

#write.csv(AAP_tbl_long, "AAP_tbl_long.csv")

#AAP_tbl_long = read.csv( "AAP_tbl_long.csv")

#Reorder factors
AAP_tbl_long$Station = factor(AAP_tbl_long$Station,
                                   levels = c("Medemgrund",
                                              "Brunsbuettel",
                                              "Schwarztonnensand",
                                              "Twielenfleth",
                                              "Muehlenberger Loch"))

AAP_tbl_long$Sample_date = gsub("-", " ",AAP_tbl_long$Sample_date)

AAP_tbl_long$Sample_date = factor(AAP_tbl_long$Sample_date,
                                   levels = c("May 21",
                                              "Jul 21",
                                              "Nov 21",
                                              "Feb 22",
                                              "May 22",
                                              "Jun 22",
                                              "Nov 22"))

#Make data_type names informative
AAP_tbl_long$data_type = gsub("METAT", "Transcriptomes", AAP_tbl_long$data_type)
AAP_tbl_long$data_type = gsub("METAG", "Metagenomes", AAP_tbl_long$data_type)


#Long to wide, in preparation for transcripts per gene copy calculation
# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
AAP_TG.df <- spread(AAP_tbl_long[ , ! names(AAP_tbl_long) %in% c("sampleid", "abundance", "occurrence", "X")], #Remove columns that will cause problems
                       data_type, #Column that will contain new column names
                       counts) %>% # Value that will fill new columns
  filter(Transcriptomes > 0 & Metagenomes > 0) %>% #Remove all 0 values
  filter(!is.na(Transcriptomes), !is.na(Metagenomes)) # remove all NAs
#Ensure that it worked
dim(AAP_tbl_long)
dim(AAP_TG.df)


#Calculate Transcripts per gene copy
AAP_TG.df$TranscriptsPerGenome = AAP_TG.df$Transcriptomes / AAP_TG.df$Metagenomes


#Convert from wide to long format
AAP_TG.df = gather(AAP_TG.df, key = data_type, value = counts, Metagenomes:TranscriptsPerGenome)
dim(AAP_TG.df)

#Remove data_types and columns that are no longer relevant 
AAP_TG.df = subset(AAP_TG.df, data_type == "TranscriptsPerGenome") %>%
  select(counts, KO, Associatednumber)
dim(AAP_TG.df)


#Remove samples for which we have no metatranscriptomes
AAP_TG.df = subset(AAP_TG.df, Associatednumber > 116)
dim(AAP_TG.df)
#Remove samples for which sequencing failed
AAP_TG.df = subset(AAP_TG.df, !(Associatednumber %in% c(127, 128, 140, 145, 146, 157, 169, 170,
                                                               119, 125, 126, 136, 137, 153, 154)))
dim(AAP_TG.df)

#Make sure data is set up properly
AAP_TG.df$counts = as.numeric(as.character(AAP_TG.df$counts))
AAP_TG.df$Associatednumber = as.character(AAP_TG.df$Associatednumber)



```







